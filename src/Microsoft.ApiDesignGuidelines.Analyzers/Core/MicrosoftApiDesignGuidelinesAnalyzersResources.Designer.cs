//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Microsoft.ApiDesignGuidelines.Analyzers {
    using System;
    using System.Reflection;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class MicrosoftApiDesignGuidelinesAnalyzersResources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal MicrosoftApiDesignGuidelinesAnalyzersResources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Microsoft.ApiDesignGuidelines.Analyzers.MicrosoftApiDesignGuidelinesAnalyzersReso" +
                            "urces", typeof(MicrosoftApiDesignGuidelinesAnalyzersResources).GetTypeInfo().Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Constructors on abstract types can be called only by derived types. Because public constructors create instances of a type, and you cannot create instances of an abstract type, an abstract type that has a public constructor is incorrectly designed..
        /// </summary>
        internal static string AbstractTypesShouldNotHaveConstructorsDescription {
            get {
                return ResourceManager.GetString("AbstractTypesShouldNotHaveConstructorsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Abstract types should not have constructors.
        /// </summary>
        internal static string AbstractTypesShouldNotHaveConstructorsMessage {
            get {
                return ResourceManager.GetString("AbstractTypesShouldNotHaveConstructorsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Abstract types should not have constructors.
        /// </summary>
        internal static string AbstractTypesShouldNotHaveConstructorsTitle {
            get {
                return ResourceManager.GetString("AbstractTypesShouldNotHaveConstructorsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #N/A.
        /// </summary>
        internal static string AsyncMethodNamesShouldEndInAsyncDescription {
            get {
                return ResourceManager.GetString("AsyncMethodNamesShouldEndInAsyncDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Async Method Names Should End in Async.
        /// </summary>
        internal static string AsyncMethodNamesShouldEndInAsyncMessage {
            get {
                return ResourceManager.GetString("AsyncMethodNamesShouldEndInAsyncMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Async Method Names Should End in Async.
        /// </summary>
        internal static string AsyncMethodNamesShouldEndInAsyncTitle {
            get {
                return ResourceManager.GetString("AsyncMethodNamesShouldEndInAsyncTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #N/A.
        /// </summary>
        internal static string AvoidAsyncVoidDescription {
            get {
                return ResourceManager.GetString("AvoidAsyncVoidDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid Async Void.
        /// </summary>
        internal static string AvoidAsyncVoidMessage {
            get {
                return ResourceManager.GetString("AvoidAsyncVoidMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid Async Void.
        /// </summary>
        internal static string AvoidAsyncVoidTitle {
            get {
                return ResourceManager.GetString("AvoidAsyncVoidTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #N/A.
        /// </summary>
        internal static string CancellationTokenParametersMustComeLastDescription {
            get {
                return ResourceManager.GetString("CancellationTokenParametersMustComeLastDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to CancellationToken parameters must come last.
        /// </summary>
        internal static string CancellationTokenParametersMustComeLastMessage {
            get {
                return ResourceManager.GetString("CancellationTokenParametersMustComeLastMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to CancellationToken parameters must come last.
        /// </summary>
        internal static string CancellationTokenParametersMustComeLastTitle {
            get {
                return ResourceManager.GetString("CancellationTokenParametersMustComeLastTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to ApiDesign.
        /// </summary>
        internal static string CategoryApiDesign {
            get {
                return ResourceManager.GetString("CategoryApiDesign", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Design.
        /// </summary>
        internal static string CategoryDesign {
            get {
                return ResourceManager.GetString("CategoryDesign", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Library.
        /// </summary>
        internal static string CategoryLibrary {
            get {
                return ResourceManager.GetString("CategoryLibrary", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Naming.
        /// </summary>
        internal static string CategoryNaming {
            get {
                return ResourceManager.GetString("CategoryNaming", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Performance.
        /// </summary>
        internal static string CategoryPerformance {
            get {
                return ResourceManager.GetString("CategoryPerformance", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Usage.
        /// </summary>
        internal static string CategoryUsage {
            get {
                return ResourceManager.GetString("CategoryUsage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A writable collection property allows a user to replace the collection with a different collection. A read-only property stops the collection from being replaced but still allows the individual members to be set..
        /// </summary>
        internal static string CollectionPropertiesShouldBeReadOnlyDescription {
            get {
                return ResourceManager.GetString("CollectionPropertiesShouldBeReadOnlyDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Collection properties should be read only.
        /// </summary>
        internal static string CollectionPropertiesShouldBeReadOnlyMessage {
            get {
                return ResourceManager.GetString("CollectionPropertiesShouldBeReadOnlyMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Collection properties should be read only.
        /// </summary>
        internal static string CollectionPropertiesShouldBeReadOnlyTitle {
            get {
                return ResourceManager.GetString("CollectionPropertiesShouldBeReadOnlyTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to When a base class is noninheritable because its constructor is internal, a derived class should not make it inheritable by having a public or protected constructor..
        /// </summary>
        internal static string ConstructorMakeNoninheritableBaseClassInheritableDescription {
            get {
                return ResourceManager.GetString("ConstructorMakeNoninheritableBaseClassInheritableDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Constructor make noninheritable base class inheritable.
        /// </summary>
        internal static string ConstructorMakeNoninheritableBaseClassInheritableMessage {
            get {
                return ResourceManager.GetString("ConstructorMakeNoninheritableBaseClassInheritableMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Constructor make noninheritable base class inheritable.
        /// </summary>
        internal static string ConstructorMakeNoninheritableBaseClassInheritableTitle {
            get {
                return ResourceManager.GetString("ConstructorMakeNoninheritableBaseClassInheritableTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Attributes can define mandatory arguments that must be specified when you apply the attribute to a target. These are also known as positional arguments because they are supplied to attribute constructors as positional parameters. For every mandatory argument, the attribute should also provide a corresponding read-only property so that the value of the argument can be retrieved at execution time. Attributes can also define optional arguments, which are also known as named arguments. These arguments are suppl [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string DefineAccessorsForAttributeArgumentsDescription {
            get {
                return ResourceManager.GetString("DefineAccessorsForAttributeArgumentsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Add a public read-only property accessor for positional argument {0} of Attribute {1}..
        /// </summary>
        internal static string DefineAccessorsForAttributeArgumentsMessageDefault {
            get {
                return ResourceManager.GetString("DefineAccessorsForAttributeArgumentsMessageDefault", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to If {0} is the property accessor for positional argument {1}, make it public..
        /// </summary>
        internal static string DefineAccessorsForAttributeArgumentsMessageIncreaseVisibility {
            get {
                return ResourceManager.GetString("DefineAccessorsForAttributeArgumentsMessageIncreaseVisibility", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove the property setter from {0} or reduce its accessibility because it corresponds to positional argument {1}..
        /// </summary>
        internal static string DefineAccessorsForAttributeArgumentsMessageRemoveSetter {
            get {
                return ResourceManager.GetString("DefineAccessorsForAttributeArgumentsMessageRemoveSetter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Define accessors for attribute arguments.
        /// </summary>
        internal static string DefineAccessorsForAttributeArgumentsTitle {
            get {
                return ResourceManager.GetString("DefineAccessorsForAttributeArgumentsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to You should not change the access modifier for inherited members. Changing an inherited member to private does not prevent callers from accessing the base class implementation of the method..
        /// </summary>
        internal static string DoNotDecreaseInheritedMemberVisibilityDescription {
            get {
                return ResourceManager.GetString("DoNotDecreaseInheritedMemberVisibilityDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not decrease inherited member visibility.
        /// </summary>
        internal static string DoNotDecreaseInheritedMemberVisibilityMessage {
            get {
                return ResourceManager.GetString("DoNotDecreaseInheritedMemberVisibilityMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not decrease inherited member visibility.
        /// </summary>
        internal static string DoNotDecreaseInheritedMemberVisibilityTitle {
            get {
                return ResourceManager.GetString("DoNotDecreaseInheritedMemberVisibilityTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An externally visible enumeration is marked by using FlagsAttribute, and it has one or more values that are not powers of two or a combination of the other defined values on the enumeration..
        /// </summary>
        internal static string DoNotMarkEnumsWithFlagsDescription {
            get {
                return ResourceManager.GetString("DoNotMarkEnumsWithFlagsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not mark enums with FlagsAttribute.
        /// </summary>
        internal static string DoNotMarkEnumsWithFlagsMessage {
            get {
                return ResourceManager.GetString("DoNotMarkEnumsWithFlagsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not mark enums with FlagsAttribute.
        /// </summary>
        internal static string DoNotMarkEnumsWithFlagsTitle {
            get {
                return ResourceManager.GetString("DoNotMarkEnumsWithFlagsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #N/A.
        /// </summary>
        internal static string DonTMixBlockingAndAsyncDescription {
            get {
                return ResourceManager.GetString("DonTMixBlockingAndAsyncDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Don&apos;t Mix Blocking and Async.
        /// </summary>
        internal static string DonTMixBlockingAndAsyncMessage {
            get {
                return ResourceManager.GetString("DonTMixBlockingAndAsyncMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Don&apos;t Mix Blocking and Async.
        /// </summary>
        internal static string DonTMixBlockingAndAsyncTitle {
            get {
                return ResourceManager.GetString("DonTMixBlockingAndAsyncTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #N/A.
        /// </summary>
        internal static string DonTPassAsyncLambdasAsVoidReturningDelegateTypesDescription {
            get {
                return ResourceManager.GetString("DonTPassAsyncLambdasAsVoidReturningDelegateTypesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Don&apos;t Pass Async Lambdas as Void Returning Delegate Types.
        /// </summary>
        internal static string DonTPassAsyncLambdasAsVoidReturningDelegateTypesMessage {
            get {
                return ResourceManager.GetString("DonTPassAsyncLambdasAsVoidReturningDelegateTypesMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Don&apos;t Pass Async Lambdas as Void Returning Delegate Types.
        /// </summary>
        internal static string DonTPassAsyncLambdasAsVoidReturningDelegateTypesTitle {
            get {
                return ResourceManager.GetString("DonTPassAsyncLambdasAsVoidReturningDelegateTypesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #N/A.
        /// </summary>
        internal static string DonTStoreAsyncLambdasAsVoidReturningDelegateTypesDescription {
            get {
                return ResourceManager.GetString("DonTStoreAsyncLambdasAsVoidReturningDelegateTypesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Don&apos;t Store Async Lambdas as Void Returning Delegate Types.
        /// </summary>
        internal static string DonTStoreAsyncLambdasAsVoidReturningDelegateTypesMessage {
            get {
                return ResourceManager.GetString("DonTStoreAsyncLambdasAsVoidReturningDelegateTypesMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Don&apos;t Store Async Lambdas as Void Returning Delegate Types.
        /// </summary>
        internal static string DonTStoreAsyncLambdasAsVoidReturningDelegateTypesTitle {
            get {
                return ResourceManager.GetString("DonTStoreAsyncLambdasAsVoidReturningDelegateTypesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The default value of an uninitialized enumeration, just as other value types, is zero. A nonflags-attributed enumeration should define a member by using the value of zero so that the default value is a valid value of the enumeration. If an enumeration that has the FlagsAttribute attribute applied defines a zero-valued member, its name should be &quot;&quot;None&quot;&quot; to indicate that no values have been set in the enumeration..
        /// </summary>
        internal static string EnumsShouldHaveZeroValueDescription {
            get {
                return ResourceManager.GetString("EnumsShouldHaveZeroValueDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove all members that have the value zero from {0} except for one member that is named &apos;None&apos;..
        /// </summary>
        internal static string EnumsShouldHaveZeroValueMessageFlagsMultipleZeros {
            get {
                return ResourceManager.GetString("EnumsShouldHaveZeroValueMessageFlagsMultipleZeros", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In enum {0}, change the name of {1} to &apos;None&apos;..
        /// </summary>
        internal static string EnumsShouldHaveZeroValueMessageFlagsRename {
            get {
                return ResourceManager.GetString("EnumsShouldHaveZeroValueMessageFlagsRename", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Add a member to {0} that has a value of zero with a suggested name of &apos;None&apos;..
        /// </summary>
        internal static string EnumsShouldHaveZeroValueMessageNotFlagsNoZeroValue {
            get {
                return ResourceManager.GetString("EnumsShouldHaveZeroValueMessageNotFlagsNoZeroValue", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Enums should have zero value.
        /// </summary>
        internal static string EnumsShouldHaveZeroValueTitle {
            get {
                return ResourceManager.GetString("EnumsShouldHaveZeroValueTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Identifiers for namespaces, types, members, and parameters cannot differ only by case because languages that target the common language runtime are not required to be case-sensitive..
        /// </summary>
        internal static string IdentifiersShouldDifferByMoreThanCaseDescription {
            get {
                return ResourceManager.GetString("IdentifiersShouldDifferByMoreThanCaseDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Change member names {0} and &apos;{1}&apos; so that they differ by more than case..
        /// </summary>
        internal static string IdentifiersShouldDifferByMoreThanCaseMessageMember {
            get {
                return ResourceManager.GetString("IdentifiersShouldDifferByMoreThanCaseMessageMember", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Change namespace names {0} and &apos;{1}&apos; so that they differ by more than case..
        /// </summary>
        internal static string IdentifiersShouldDifferByMoreThanCaseMessageNamespace {
            get {
                return ResourceManager.GetString("IdentifiersShouldDifferByMoreThanCaseMessageNamespace", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Change parameter names {0} and &apos;{1}&apos; so that they differ by more than case..
        /// </summary>
        internal static string IdentifiersShouldDifferByMoreThanCaseMessageParameter {
            get {
                return ResourceManager.GetString("IdentifiersShouldDifferByMoreThanCaseMessageParameter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Change type names {0} and &apos;{1}&apos; so that they differ by more than case..
        /// </summary>
        internal static string IdentifiersShouldDifferByMoreThanCaseMessageType {
            get {
                return ResourceManager.GetString("IdentifiersShouldDifferByMoreThanCaseMessageType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Identifiers should differ by more than case.
        /// </summary>
        internal static string IdentifiersShouldDifferByMoreThanCaseTitle {
            get {
                return ResourceManager.GetString("IdentifiersShouldDifferByMoreThanCaseTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The name of an externally visible interface does not start with an uppercase &quot;&quot;I&quot;&quot;. The name of a generic type parameter on an externally visible type or method does not start with an uppercase &quot;&quot;T&quot;&quot;..
        /// </summary>
        internal static string IdentifiersShouldHaveCorrectPrefixDescription {
            get {
                return ResourceManager.GetString("IdentifiersShouldHaveCorrectPrefixDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Prefix interface name {0} with &apos;I&apos;..
        /// </summary>
        internal static string IdentifiersShouldHaveCorrectPrefixMessageInterface {
            get {
                return ResourceManager.GetString("IdentifiersShouldHaveCorrectPrefixMessageInterface", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to On method {0}, prefix generic type parameter name {1} with &apos;T&apos;..
        /// </summary>
        internal static string IdentifiersShouldHaveCorrectPrefixMessageMethodTypeParameter {
            get {
                return ResourceManager.GetString("IdentifiersShouldHaveCorrectPrefixMessageMethodTypeParameter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to On type {0}, prefix generic type parameter name {1} with &apos;T&apos;..
        /// </summary>
        internal static string IdentifiersShouldHaveCorrectPrefixMessageTypeTypeParameter {
            get {
                return ResourceManager.GetString("IdentifiersShouldHaveCorrectPrefixMessageTypeTypeParameter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Identifiers should have correct prefix.
        /// </summary>
        internal static string IdentifiersShouldHaveCorrectPrefixTitle {
            get {
                return ResourceManager.GetString("IdentifiersShouldHaveCorrectPrefixTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 
        ///Names of parameters and members are better used to communicate their meaning than to describe their type, which is expected to be provided by development tools. For names of members, if a data type name must be used, use a language-independent name instead of a language-specific one..
        /// </summary>
        internal static string IdentifiersShouldNotContainTypeNamesDescription {
            get {
                return ResourceManager.GetString("IdentifiersShouldNotContainTypeNamesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Identifier &apos;{0}&apos; contains type name.
        /// </summary>
        internal static string IdentifiersShouldNotContainTypeNamesMessage {
            get {
                return ResourceManager.GetString("IdentifiersShouldNotContainTypeNamesMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Identifier contains type name.
        /// </summary>
        internal static string IdentifiersShouldNotContainTypeNamesTitle {
            get {
                return ResourceManager.GetString("IdentifiersShouldNotContainTypeNamesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #N/A.
        /// </summary>
        internal static string ImplementIEquatableWhenOverridingObjectEqualsDescription {
            get {
                return ResourceManager.GetString("ImplementIEquatableWhenOverridingObjectEqualsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implement IEquatable when overriding Object.Equals.
        /// </summary>
        internal static string ImplementIEquatableWhenOverridingObjectEqualsMessage {
            get {
                return ResourceManager.GetString("ImplementIEquatableWhenOverridingObjectEqualsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implement IEquatable when overriding Object.Equals.
        /// </summary>
        internal static string ImplementIEquatableWhenOverridingObjectEqualsTitle {
            get {
                return ResourceManager.GetString("ImplementIEquatableWhenOverridingObjectEqualsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An unsealed externally visible type provides an explicit method implementation of a public interface and does not provide an alternative externally visible method that has the same name..
        /// </summary>
        internal static string InterfaceMethodsShouldBeCallableByChildTypesDescription {
            get {
                return ResourceManager.GetString("InterfaceMethodsShouldBeCallableByChildTypesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Interface methods should be callable by child types.
        /// </summary>
        internal static string InterfaceMethodsShouldBeCallableByChildTypesMessage {
            get {
                return ResourceManager.GetString("InterfaceMethodsShouldBeCallableByChildTypesMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Interface methods should be callable by child types.
        /// </summary>
        internal static string InterfaceMethodsShouldBeCallableByChildTypesTitle {
            get {
                return ResourceManager.GetString("InterfaceMethodsShouldBeCallableByChildTypesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The .NET Framework uses the version number to uniquely identify an assembly, and to bind to types in strongly named assemblies. The version number is used together with version and publisher policy. By default, applications run only with the assembly version with which they were built..
        /// </summary>
        internal static string MarkAssembliesWithAssemblyVersionDescription {
            get {
                return ResourceManager.GetString("MarkAssembliesWithAssemblyVersionDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mark assemblies with assembly version.
        /// </summary>
        internal static string MarkAssembliesWithAssemblyVersionMessage {
            get {
                return ResourceManager.GetString("MarkAssembliesWithAssemblyVersionMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mark assemblies with assembly version.
        /// </summary>
        internal static string MarkAssembliesWithAssemblyVersionTitle {
            get {
                return ResourceManager.GetString("MarkAssembliesWithAssemblyVersionTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Common Language Specification (CLS) defines naming restrictions, data types, and rules to which assemblies must conform if they will be used across programming languages. Good design dictates that all assemblies explicitly indicate CLS compliance by using CLSCompliantAttribute . If this attribute is not present on an assembly, the assembly is not compliant..
        /// </summary>
        internal static string MarkAssembliesWithClsCompliantDescription {
            get {
                return ResourceManager.GetString("MarkAssembliesWithClsCompliantDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mark assemblies with CLSCompliant.
        /// </summary>
        internal static string MarkAssembliesWithClsCompliantMessage {
            get {
                return ResourceManager.GetString("MarkAssembliesWithClsCompliantMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mark assemblies with CLSCompliant.
        /// </summary>
        internal static string MarkAssembliesWithClsCompliantTitle {
            get {
                return ResourceManager.GetString("MarkAssembliesWithClsCompliantTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to ComVisibleAttribute determines how COM clients access managed code. Good design dictates that assemblies explicitly indicate COM visibility. COM visibility can be set for the whole assembly and then overridden for individual types and type members. If this attribute is not present, the contents of the assembly are visible to COM clients..
        /// </summary>
        internal static string MarkAssembliesWithComVisibleDescription {
            get {
                return ResourceManager.GetString("MarkAssembliesWithComVisibleDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Consider changing the ComVisible attribute on {0} to false, and opting in at the type level..
        /// </summary>
        internal static string MarkAssembliesWithComVisibleMessageAttributeTrue {
            get {
                return ResourceManager.GetString("MarkAssembliesWithComVisibleMessageAttributeTrue", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Because {0} exposes externally visible types, mark it with ComVisible(false) at the assembly level and then mark all types within the assembly that should be exposed to COM clients with ComVisible(true)..
        /// </summary>
        internal static string MarkAssembliesWithComVisibleMessageNoAttribute {
            get {
                return ResourceManager.GetString("MarkAssembliesWithComVisibleMessageNoAttribute", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mark assemblies with ComVisible.
        /// </summary>
        internal static string MarkAssembliesWithComVisibleTitle {
            get {
                return ResourceManager.GetString("MarkAssembliesWithComVisibleTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to When you define a custom attribute, mark it by using AttributeUsageAttribute to indicate where in the source code the custom attribute can be applied. The meaning and intended usage of an attribute will determine its valid locations in code..
        /// </summary>
        internal static string MarkAttributesWithAttributeUsageDescription {
            get {
                return ResourceManager.GetString("MarkAttributesWithAttributeUsageDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Specify AttributeUsage on {0}..
        /// </summary>
        internal static string MarkAttributesWithAttributeUsageMessageDefault {
            get {
                return ResourceManager.GetString("MarkAttributesWithAttributeUsageMessageDefault", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Even though attribute {0} inherits AttributeUsage from its base type, you should consider explicitly specifying AttributeUsage on the type to improve code readability and documentation..
        /// </summary>
        internal static string MarkAttributesWithAttributeUsageMessageInherited {
            get {
                return ResourceManager.GetString("MarkAttributesWithAttributeUsageMessageInherited", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mark attributes with AttributeUsageAttribute.
        /// </summary>
        internal static string MarkAttributesWithAttributeUsageTitle {
            get {
                return ResourceManager.GetString("MarkAttributesWithAttributeUsageTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An enumeration is a value type that defines a set of related named constants. Apply FlagsAttribute to an enumeration when its named constants can be meaningfully combined..
        /// </summary>
        internal static string MarkEnumsWithFlagsDescription {
            get {
                return ResourceManager.GetString("MarkEnumsWithFlagsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mark enums with FlagsAttribute.
        /// </summary>
        internal static string MarkEnumsWithFlagsMessage {
            get {
                return ResourceManager.GetString("MarkEnumsWithFlagsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mark enums with FlagsAttribute.
        /// </summary>
        internal static string MarkEnumsWithFlagsTitle {
            get {
                return ResourceManager.GetString("MarkEnumsWithFlagsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Platform Invocation methods, such as those that are marked by using the System.Runtime.InteropServices.DllImportAttribute attribute, or methods that are defined by using the Declare keyword in Visual Basic, access unmanaged code. These methods should be of the NativeMethods, SafeNativeMethods, or UnsafeNativeMethods class..
        /// </summary>
        internal static string MovePInvokesToNativeMethodsClassDescription {
            get {
                return ResourceManager.GetString("MovePInvokesToNativeMethodsClassDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Move pinvokes to native methods class.
        /// </summary>
        internal static string MovePInvokesToNativeMethodsClassMessage {
            get {
                return ResourceManager.GetString("MovePInvokesToNativeMethodsClassMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Move pinvokes to native methods class.
        /// </summary>
        internal static string MovePInvokesToNativeMethodsClassTitle {
            get {
                return ResourceManager.GetString("MovePInvokesToNativeMethodsClassTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Static fields that are neither constants nor read-only are not thread-safe. Access to such a field must be carefully controlled and requires advanced programming techniques to synchronize access to the class object..
        /// </summary>
        internal static string NonConstantFieldsShouldNotBeVisibleDescription {
            get {
                return ResourceManager.GetString("NonConstantFieldsShouldNotBeVisibleDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Non-constant fields should not be visible.
        /// </summary>
        internal static string NonConstantFieldsShouldNotBeVisibleMessage {
            get {
                return ResourceManager.GetString("NonConstantFieldsShouldNotBeVisibleMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Non-constant fields should not be visible.
        /// </summary>
        internal static string NonConstantFieldsShouldNotBeVisibleTitle {
            get {
                return ResourceManager.GetString("NonConstantFieldsShouldNotBeVisibleTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An operator overload was detected, and the expected named alternative method was not found. The named alternative member provides access to the same functionality as the operator and is provided for developers who program in languages that do not support overloaded operators..
        /// </summary>
        internal static string OperatorOverloadsHaveNamedAlternatesDescription {
            get {
                return ResourceManager.GetString("OperatorOverloadsHaveNamedAlternatesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Provide a method named &apos;{0}&apos; as a friendly alternate for operator {1}..
        /// </summary>
        internal static string OperatorOverloadsHaveNamedAlternatesMessageDefault {
            get {
                return ResourceManager.GetString("OperatorOverloadsHaveNamedAlternatesMessageDefault", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Provide a method named &apos;{0}&apos; or &apos;{1}&apos; as an alternate for operator {2}..
        /// </summary>
        internal static string OperatorOverloadsHaveNamedAlternatesMessageMultiple {
            get {
                return ResourceManager.GetString("OperatorOverloadsHaveNamedAlternatesMessageMultiple", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Provide a property named &apos;{0}&apos; as a friendly alternate for operator {1}..
        /// </summary>
        internal static string OperatorOverloadsHaveNamedAlternatesMessageProperty {
            get {
                return ResourceManager.GetString("OperatorOverloadsHaveNamedAlternatesMessageProperty", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mark {0} as public because it is a friendly alternate for operator {1}..
        /// </summary>
        internal static string OperatorOverloadsHaveNamedAlternatesMessageVisibility {
            get {
                return ResourceManager.GetString("OperatorOverloadsHaveNamedAlternatesMessageVisibility", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Operator overloads have named alternates.
        /// </summary>
        internal static string OperatorOverloadsHaveNamedAlternatesTitle {
            get {
                return ResourceManager.GetString("OperatorOverloadsHaveNamedAlternatesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A type implements the equality or inequality operator and does not implement the opposite operator..
        /// </summary>
        internal static string OperatorsShouldHaveSymmetricalOverloadsDescription {
            get {
                return ResourceManager.GetString("OperatorsShouldHaveSymmetricalOverloadsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Operators should have symmetrical overloads.
        /// </summary>
        internal static string OperatorsShouldHaveSymmetricalOverloadsMessage {
            get {
                return ResourceManager.GetString("OperatorsShouldHaveSymmetricalOverloadsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Operators should have symmetrical overloads.
        /// </summary>
        internal static string OperatorsShouldHaveSymmetricalOverloadsTitle {
            get {
                return ResourceManager.GetString("OperatorsShouldHaveSymmetricalOverloadsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In most programming languages there is no default implementation of the equality operator (==) for value types. If your programming language supports operator overloads, you should consider implementing the equality operator. Its behavior should be identical to that of Equals.
        /// </summary>
        internal static string OverloadOperatorEqualsOnOverridingValueTypeEqualsDescription {
            get {
                return ResourceManager.GetString("OverloadOperatorEqualsOnOverridingValueTypeEqualsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Overload operator equals on overriding value type Equals.
        /// </summary>
        internal static string OverloadOperatorEqualsOnOverridingValueTypeEqualsMessage {
            get {
                return ResourceManager.GetString("OverloadOperatorEqualsOnOverridingValueTypeEqualsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Overload operator equals on overriding value type Equals.
        /// </summary>
        internal static string OverloadOperatorEqualsOnOverridingValueTypeEqualsTitle {
            get {
                return ResourceManager.GetString("OverloadOperatorEqualsOnOverridingValueTypeEqualsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A public or protected type implements the System.IComparable interface. It does not override Object.Equals nor does it overload the language-specific operator for equality, inequality, less than, or greater than..
        /// </summary>
        internal static string OverrideMethodsOnComparableTypesDescription {
            get {
                return ResourceManager.GetString("OverrideMethodsOnComparableTypesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} should override Equals since it implements IComparable..
        /// </summary>
        internal static string OverrideMethodsOnComparableTypesMessageEquals {
            get {
                return ResourceManager.GetString("OverrideMethodsOnComparableTypesMessageEquals", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} should define operator &apos;{1}&apos; since it implements IComparable..
        /// </summary>
        internal static string OverrideMethodsOnComparableTypesMessageOperator {
            get {
                return ResourceManager.GetString("OverrideMethodsOnComparableTypesMessageOperator", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Override methods on comparable types.
        /// </summary>
        internal static string OverrideMethodsOnComparableTypesTitle {
            get {
                return ResourceManager.GetString("OverrideMethodsOnComparableTypesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A call is made to a method that has a string parameter whose name contains &quot;uri&quot;, &quot;URI&quot;, &quot;urn&quot;, &quot;URN&quot;, &quot;url&quot;, or &quot;URL&quot;. The declaring type of the method contains a corresponding method overload that has a System.Uri parameter..
        /// </summary>
        internal static string PassSystemUriObjectsInsteadOfStringsDescription {
            get {
                return ResourceManager.GetString("PassSystemUriObjectsInsteadOfStringsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Pass system uri objects instead of strings.
        /// </summary>
        internal static string PassSystemUriObjectsInsteadOfStringsMessage {
            get {
                return ResourceManager.GetString("PassSystemUriObjectsInsteadOfStringsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Pass system uri objects instead of strings.
        /// </summary>
        internal static string PassSystemUriObjectsInsteadOfStringsTitle {
            get {
                return ResourceManager.GetString("PassSystemUriObjectsInsteadOfStringsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #N/A.
        /// </summary>
        internal static string PropagateCancellationTokensWhenPossibleDescription {
            get {
                return ResourceManager.GetString("PropagateCancellationTokensWhenPossibleDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Propagate CancellationTokens When Possible.
        /// </summary>
        internal static string PropagateCancellationTokensWhenPossibleMessage {
            get {
                return ResourceManager.GetString("PropagateCancellationTokensWhenPossibleMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Propagate CancellationTokens When Possible.
        /// </summary>
        internal static string PropagateCancellationTokensWhenPossibleTitle {
            get {
                return ResourceManager.GetString("PropagateCancellationTokensWhenPossibleTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A public or protected type contains only static members and is not declared by using the sealed (C# Reference) (NotInheritable) modifier. A type that is not meant to be inherited should be marked by using the sealed modifier to prevent its use as a base type..
        /// </summary>
        internal static string StaticHolderTypesShouldBeSealedDescription {
            get {
                return ResourceManager.GetString("StaticHolderTypesShouldBeSealedDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Because type {0} contains only &apos;static&apos; members, mark it as &apos;static&apos; to prevent consumers from inheriting from it..
        /// </summary>
        internal static string StaticHolderTypesShouldBeSealedMessageCSharp20 {
            get {
                return ResourceManager.GetString("StaticHolderTypesShouldBeSealedMessageCSharp20", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Because type {0} contains only &apos;static&apos; (&apos;Shared&apos; in Visual Basic) members, mark it as &apos;sealed&apos; (&apos;NotInheritable&apos; in Visual Basic) to prevent consumers from inheriting from it..
        /// </summary>
        internal static string StaticHolderTypesShouldBeSealedMessageDefault {
            get {
                return ResourceManager.GetString("StaticHolderTypesShouldBeSealedMessageDefault", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Static holder types should be sealed.
        /// </summary>
        internal static string StaticHolderTypesShouldBeSealedTitle {
            get {
                return ResourceManager.GetString("StaticHolderTypesShouldBeSealedTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A public or nested public type declares only static members and has a public or protected default constructor. The constructor is unnecessary because calling static members does not require an instance of the type. The string overload should call the uniform resource identifier (URI) overload by using the string argument for safety and security..
        /// </summary>
        internal static string StaticHolderTypesShouldNotHaveConstructorsDescription {
            get {
                return ResourceManager.GetString("StaticHolderTypesShouldNotHaveConstructorsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Because type {0} contains only &apos;static&apos; members, mark it as &apos;static&apos; to prevent the compiler from adding a default public constructor..
        /// </summary>
        internal static string StaticHolderTypesShouldNotHaveConstructorsMessageCSharp20 {
            get {
                return ResourceManager.GetString("StaticHolderTypesShouldNotHaveConstructorsMessageCSharp20", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Because type {0} contains only &apos;static&apos; (&apos;Shared&apos; in Visual Basic) members, add a default private constructor to prevent the compiler from adding a default public constructor..
        /// </summary>
        internal static string StaticHolderTypesShouldNotHaveConstructorsMessageDefault {
            get {
                return ResourceManager.GetString("StaticHolderTypesShouldNotHaveConstructorsMessageDefault", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Static holder types should not have constructors.
        /// </summary>
        internal static string StaticHolderTypesShouldNotHaveConstructorsTitle {
            get {
                return ResourceManager.GetString("StaticHolderTypesShouldNotHaveConstructorsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A class declares and implements an instance field that is a System.IDisposable type, and the class does not implement IDisposable. A class that declares an IDisposable field indirectly owns an unmanaged resource and should implement the IDisposable interface..
        /// </summary>
        internal static string TypesThatOwnDisposableFieldsShouldBeDisposableDescription {
            get {
                return ResourceManager.GetString("TypesThatOwnDisposableFieldsShouldBeDisposableDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implement IDisposable on {0} because it creates members of the following IDisposable types: {1}. If {0} has previously shipped, adding new members that implement IDisposable to this type is considered a breaking change to existing consumers..
        /// </summary>
        internal static string TypesThatOwnDisposableFieldsShouldBeDisposableMessageDependsOnFix {
            get {
                return ResourceManager.GetString("TypesThatOwnDisposableFieldsShouldBeDisposableMessageDependsOnFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implement IDisposable on {0} because it creates members of the following IDisposable types: {1}..
        /// </summary>
        internal static string TypesThatOwnDisposableFieldsShouldBeDisposableMessageNonBreaking {
            get {
                return ResourceManager.GetString("TypesThatOwnDisposableFieldsShouldBeDisposableMessageNonBreaking", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Types that own disposable fields should be disposable.
        /// </summary>
        internal static string TypesThatOwnDisposableFieldsShouldBeDisposableTitle {
            get {
                return ResourceManager.GetString("TypesThatOwnDisposableFieldsShouldBeDisposableTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A type contains a delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets Microsoft .NET Framework?2.0..
        /// </summary>
        internal static string UseGenericEventHandlerInstancesDescription {
            get {
                return ResourceManager.GetString("UseGenericEventHandlerInstancesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove {0} and replace its usage with EventHandler&lt;T&gt;.
        /// </summary>
        internal static string UseGenericEventHandlerInstancesMessageDefault {
            get {
                return ResourceManager.GetString("UseGenericEventHandlerInstancesMessageDefault", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Visual Basic generates EventHandler delegates for events that use the following pattern: Event MyEvent(ByVal Sender As Object, ByVal e as MyEventArgs). Change the event that defines EventHandler {0} to use EventHandler&lt;T&gt; by defining the event type explicitly, e.g. Event MyEvent As EventHandler(Of MyEventArgs)..
        /// </summary>
        internal static string UseGenericEventHandlerInstancesMessageVB {
            get {
                return ResourceManager.GetString("UseGenericEventHandlerInstancesMessageVB", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use generic event handler instances.
        /// </summary>
        internal static string UseGenericEventHandlerInstancesTitle {
            get {
                return ResourceManager.GetString("UseGenericEventHandlerInstancesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A public or protected method has a name that starts with &quot;&quot;Get&quot;&quot;, takes no parameters, and returns a value that is not an array. The method might be a good candidate to become a property..
        /// </summary>
        internal static string UsePropertiesWhereAppropriateDescription {
            get {
                return ResourceManager.GetString("UsePropertiesWhereAppropriateDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use properties where appropriate.
        /// </summary>
        internal static string UsePropertiesWhereAppropriateMessage {
            get {
                return ResourceManager.GetString("UsePropertiesWhereAppropriateMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use properties where appropriate.
        /// </summary>
        internal static string UsePropertiesWhereAppropriateTitle {
            get {
                return ResourceManager.GetString("UsePropertiesWhereAppropriateTitle", resourceCulture);
            }
        }
    }
}

//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Microsoft.ApiDesignGuidelines.Analyzers {
    using System;
    using System.Reflection;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class MicrosoftApiDesignGuidelinesAnalyzersResources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal MicrosoftApiDesignGuidelinesAnalyzersResources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Microsoft.ApiDesignGuidelines.Analyzers.MicrosoftApiDesignGuidelinesAnalyzersReso" +
                            "urces", typeof(MicrosoftApiDesignGuidelinesAnalyzersResources).GetTypeInfo().Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Constructors on abstract types can be called only by derived types. Because public constructors create instances of a type, and you cannot create instances of an abstract type, an abstract type that has a public constructor is incorrectly designed..
        /// </summary>
        internal static string AbstractTypesShouldNotHaveConstructorsDescription {
            get {
                return ResourceManager.GetString("AbstractTypesShouldNotHaveConstructorsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Abstract type {0} should not have constructors.
        /// </summary>
        internal static string AbstractTypesShouldNotHaveConstructorsMessage {
            get {
                return ResourceManager.GetString("AbstractTypesShouldNotHaveConstructorsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Abstract types should not have constructors.
        /// </summary>
        internal static string AbstractTypesShouldNotHaveConstructorsTitle {
            get {
                return ResourceManager.GetString("AbstractTypesShouldNotHaveConstructorsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Change the accessibility of public constructors to protected..
        /// </summary>
        internal static string AbstractTypesShouldNotHavePublicConstructorsCodeFix {
            get {
                return ResourceManager.GetString("AbstractTypesShouldNotHavePublicConstructorsCodeFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Because {0} exposes externally visible types, mark it with ComVisible(false) at the assembly level and then mark all types within the assembly that should be exposed to COM clients with ComVisible(true)..
        /// </summary>
        internal static string AddAssemblyLevelComVisibleFalse {
            get {
                return ResourceManager.GetString("AddAssemblyLevelComVisibleFalse", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Append .ConfigureAwait(false).
        /// </summary>
        internal static string AppendConfigureAwaitFalse {
            get {
                return ResourceManager.GetString("AppendConfigureAwaitFalse", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The strong name protects clients from unknowingly loading an assembly that has been tampered with. Assemblies without strong names should not be deployed outside very limited scenarios. If you share or distribute assemblies that are not correctly signed, the assembly can be tampered with, the common language runtime might not load the assembly, or the user might have to disable verification on his or her computer..
        /// </summary>
        internal static string AssembliesShouldHaveValidStrongNamesDescription {
            get {
                return ResourceManager.GetString("AssembliesShouldHaveValidStrongNamesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Sign {0} with a strong name key..
        /// </summary>
        internal static string AssembliesShouldHaveValidStrongNamesMessageNoStrongName {
            get {
                return ResourceManager.GetString("AssembliesShouldHaveValidStrongNamesMessageNoStrongName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Verify that {0} has a valid strong name before deploying..
        /// </summary>
        internal static string AssembliesShouldHaveValidStrongNamesMessageNotValid {
            get {
                return ResourceManager.GetString("AssembliesShouldHaveValidStrongNamesMessageNotValid", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Assemblies should have valid strong names.
        /// </summary>
        internal static string AssembliesShouldHaveValidStrongNamesTitle {
            get {
                return ResourceManager.GetString("AssembliesShouldHaveValidStrongNamesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #N/A.
        /// </summary>
        internal static string AsyncMethodNamesShouldEndInAsyncDescription {
            get {
                return ResourceManager.GetString("AsyncMethodNamesShouldEndInAsyncDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Async Method Names Should End in Async.
        /// </summary>
        internal static string AsyncMethodNamesShouldEndInAsyncMessage {
            get {
                return ResourceManager.GetString("AsyncMethodNamesShouldEndInAsyncMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Async Method Names Should End in Async.
        /// </summary>
        internal static string AsyncMethodNamesShouldEndInAsyncTitle {
            get {
                return ResourceManager.GetString("AsyncMethodNamesShouldEndInAsyncTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #N/A.
        /// </summary>
        internal static string AvoidAsyncVoidDescription {
            get {
                return ResourceManager.GetString("AvoidAsyncVoidDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid Async Void.
        /// </summary>
        internal static string AvoidAsyncVoidMessage {
            get {
                return ResourceManager.GetString("AvoidAsyncVoidMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid Async Void.
        /// </summary>
        internal static string AvoidAsyncVoidTitle {
            get {
                return ResourceManager.GetString("AvoidAsyncVoidTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Interfaces define members that provide a behavior or usage contract. The functionality that is described by the interface can be adopted by any type, regardless of where the type appears in the inheritance hierarchy. A type implements an interface by providing implementations for the members of the interface. An empty interface does not define any members; therefore, it does not define a contract that can be implemented..
        /// </summary>
        internal static string AvoidEmptyInterfacesDescription {
            get {
                return ResourceManager.GetString("AvoidEmptyInterfacesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid empty interfaces.
        /// </summary>
        internal static string AvoidEmptyInterfacesMessage {
            get {
                return ResourceManager.GetString("AvoidEmptyInterfacesMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid empty interfaces.
        /// </summary>
        internal static string AvoidEmptyInterfacesTitle {
            get {
                return ResourceManager.GetString("AvoidEmptyInterfacesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Method &apos;{0}&apos; should take CancellationToken as the last parameter.
        /// </summary>
        internal static string CancellationTokenParametersMustComeLastMessage {
            get {
                return ResourceManager.GetString("CancellationTokenParametersMustComeLastMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to CancellationToken parameters must come last.
        /// </summary>
        internal static string CancellationTokenParametersMustComeLastTitle {
            get {
                return ResourceManager.GetString("CancellationTokenParametersMustComeLastTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Consider changing the ComVisible attribute on {0} to false, and opting in at the type level..
        /// </summary>
        internal static string ChangeAssemblyLevelComVisibleToFalse {
            get {
                return ResourceManager.GetString("ChangeAssemblyLevelComVisibleToFalse", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A writable collection property allows a user to replace the collection with a different collection. A read-only property stops the collection from being replaced but still allows the individual members to be set..
        /// </summary>
        internal static string CollectionPropertiesShouldBeReadOnlyDescription {
            get {
                return ResourceManager.GetString("CollectionPropertiesShouldBeReadOnlyDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Collection properties should be read only.
        /// </summary>
        internal static string CollectionPropertiesShouldBeReadOnlyMessage {
            get {
                return ResourceManager.GetString("CollectionPropertiesShouldBeReadOnlyMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Collection properties should be read only.
        /// </summary>
        internal static string CollectionPropertiesShouldBeReadOnlyTitle {
            get {
                return ResourceManager.GetString("CollectionPropertiesShouldBeReadOnlyTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to To broaden the usability of a collection, implement one of the generic collection interfaces. Then the collection can be used to populate generic collection types..
        /// </summary>
        internal static string CollectionsShouldImplementGenericInterfaceDescription {
            get {
                return ResourceManager.GetString("CollectionsShouldImplementGenericInterfaceDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Collections should implement generic interface.
        /// </summary>
        internal static string CollectionsShouldImplementGenericInterfaceMessage {
            get {
                return ResourceManager.GetString("CollectionsShouldImplementGenericInterfaceMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Collections should implement generic interface.
        /// </summary>
        internal static string CollectionsShouldImplementGenericInterfaceTitle {
            get {
                return ResourceManager.GetString("CollectionsShouldImplementGenericInterfaceTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to When a base class is noninheritable because its constructor is internal, a derived class should not make it inheritable by having a public or protected constructor..
        /// </summary>
        internal static string ConstructorMakeNoninheritableBaseClassInheritableDescription {
            get {
                return ResourceManager.GetString("ConstructorMakeNoninheritableBaseClassInheritableDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Constructor make noninheritable base class inheritable.
        /// </summary>
        internal static string ConstructorMakeNoninheritableBaseClassInheritableMessage {
            get {
                return ResourceManager.GetString("ConstructorMakeNoninheritableBaseClassInheritableMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Constructor make noninheritable base class inheritable.
        /// </summary>
        internal static string ConstructorMakeNoninheritableBaseClassInheritableTitle {
            get {
                return ResourceManager.GetString("ConstructorMakeNoninheritableBaseClassInheritableTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Create a property accessor..
        /// </summary>
        internal static string CreatePropertyAccessorForParameter {
            get {
                return ResourceManager.GetString("CreatePropertyAccessorForParameter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Types are declared in namespaces to prevent name collisions and as a way to organize related types in an object hierarchy..
        /// </summary>
        internal static string DeclareTypesInNamespacesDescription {
            get {
                return ResourceManager.GetString("DeclareTypesInNamespacesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Declare types in namespaces.
        /// </summary>
        internal static string DeclareTypesInNamespacesMessage {
            get {
                return ResourceManager.GetString("DeclareTypesInNamespacesMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Declare types in namespaces.
        /// </summary>
        internal static string DeclareTypesInNamespacesTitle {
            get {
                return ResourceManager.GetString("DeclareTypesInNamespacesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Attributes can define mandatory arguments that must be specified when you apply the attribute to a target. These are also known as positional arguments because they are supplied to attribute constructors as positional parameters. For every mandatory argument, the attribute should also provide a corresponding read-only property so that the value of the argument can be retrieved at execution time. Attributes can also define optional arguments, which are also known as named arguments. These arguments are suppl [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string DefineAccessorsForAttributeArgumentsDescription {
            get {
                return ResourceManager.GetString("DefineAccessorsForAttributeArgumentsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Add a public read-only property accessor for positional argument {0} of Attribute {1}..
        /// </summary>
        internal static string DefineAccessorsForAttributeArgumentsMessageDefault {
            get {
                return ResourceManager.GetString("DefineAccessorsForAttributeArgumentsMessageDefault", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to If {0} is the property accessor for positional argument {1}, make it public..
        /// </summary>
        internal static string DefineAccessorsForAttributeArgumentsMessageIncreaseVisibility {
            get {
                return ResourceManager.GetString("DefineAccessorsForAttributeArgumentsMessageIncreaseVisibility", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove the property setter from {0} or reduce its accessibility because it corresponds to positional argument {1}..
        /// </summary>
        internal static string DefineAccessorsForAttributeArgumentsMessageRemoveSetter {
            get {
                return ResourceManager.GetString("DefineAccessorsForAttributeArgumentsMessageRemoveSetter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Define accessors for attribute arguments.
        /// </summary>
        internal static string DefineAccessorsForAttributeArgumentsTitle {
            get {
                return ResourceManager.GetString("DefineAccessorsForAttributeArgumentsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to When a static member of a generic type is called, the type argument must be specified for the type. When a generic instance member that does not support inference is called, the type argument must be specified for the member. In these two cases, the syntax for specifying the type argument is different and easily confused..
        /// </summary>
        internal static string DoNotDeclareStaticMembersOnGenericTypesDescription {
            get {
                return ResourceManager.GetString("DoNotDeclareStaticMembersOnGenericTypesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not declare static members on generic types.
        /// </summary>
        internal static string DoNotDeclareStaticMembersOnGenericTypesMessage {
            get {
                return ResourceManager.GetString("DoNotDeclareStaticMembersOnGenericTypesMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not declare static members on generic types.
        /// </summary>
        internal static string DoNotDeclareStaticMembersOnGenericTypesTitle {
            get {
                return ResourceManager.GetString("DoNotDeclareStaticMembersOnGenericTypesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The primary use of a field should be as an implementation detail. Fields should be private or internal and should be exposed by using properties..
        /// </summary>
        internal static string DoNotDeclareVisibleInstanceFieldsDescription {
            get {
                return ResourceManager.GetString("DoNotDeclareVisibleInstanceFieldsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not declare visible instance fields.
        /// </summary>
        internal static string DoNotDeclareVisibleInstanceFieldsMessage {
            get {
                return ResourceManager.GetString("DoNotDeclareVisibleInstanceFieldsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not declare visible instance fields.
        /// </summary>
        internal static string DoNotDeclareVisibleInstanceFieldsTitle {
            get {
                return ResourceManager.GetString("DoNotDeclareVisibleInstanceFieldsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Increase visibility for &apos;{0}&apos;.
        /// </summary>
        internal static string DoNotDecreaseInheritedMemberVisibilityCodeFix {
            get {
                return ResourceManager.GetString("DoNotDecreaseInheritedMemberVisibilityCodeFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to You should not change the access modifier for inherited members. Changing an inherited member to private does not prevent callers from accessing the base class implementation of the method..
        /// </summary>
        internal static string DoNotDecreaseInheritedMemberVisibilityDescription {
            get {
                return ResourceManager.GetString("DoNotDecreaseInheritedMemberVisibilityDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not decrease inherited member visibility.
        /// </summary>
        internal static string DoNotDecreaseInheritedMemberVisibilityMessage {
            get {
                return ResourceManager.GetString("DoNotDecreaseInheritedMemberVisibilityMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not decrease inherited member visibility.
        /// </summary>
        internal static string DoNotDecreaseInheritedMemberVisibilityTitle {
            get {
                return ResourceManager.GetString("DoNotDecreaseInheritedMemberVisibilityTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to While authoring a library where the consumer is not known and when there is no need for a SynchronizationContext,  consider using ConfigureAwait(false). Otherwise, the consumers of the library may face deadlocks by consuming the asynchronous methods in a blocking fashion..
        /// </summary>
        internal static string DoNotDirectlyAwaitATaskDescription {
            get {
                return ResourceManager.GetString("DoNotDirectlyAwaitATaskDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not directly await a Task without calling ConfigureAwait.
        /// </summary>
        internal static string DoNotDirectlyAwaitATaskMessage {
            get {
                return ResourceManager.GetString("DoNotDirectlyAwaitATaskMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not directly await a Task.
        /// </summary>
        internal static string DoNotDirectlyAwaitATaskTitle {
            get {
                return ResourceManager.GetString("DoNotDirectlyAwaitATaskTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove FlagsAttribute from enum..
        /// </summary>
        internal static string DoNotMarkEnumsWithFlagsCodeFix {
            get {
                return ResourceManager.GetString("DoNotMarkEnumsWithFlagsCodeFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An externally visible enumeration is marked by using FlagsAttribute, and it has one or more values that are not powers of two or a combination of the other defined values on the enumeration..
        /// </summary>
        internal static string DoNotMarkEnumsWithFlagsDescription {
            get {
                return ResourceManager.GetString("DoNotMarkEnumsWithFlagsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not mark enums with FlagsAttribute.
        /// </summary>
        internal static string DoNotMarkEnumsWithFlagsMessage {
            get {
                return ResourceManager.GetString("DoNotMarkEnumsWithFlagsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not mark enums with FlagsAttribute.
        /// </summary>
        internal static string DoNotMarkEnumsWithFlagsTitle {
            get {
                return ResourceManager.GetString("DoNotMarkEnumsWithFlagsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #N/A.
        /// </summary>
        internal static string DoNotMixBlockingAndAsyncDescription {
            get {
                return ResourceManager.GetString("DoNotMixBlockingAndAsyncDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Don&apos;t Mix Blocking and Async.
        /// </summary>
        internal static string DoNotMixBlockingAndAsyncMessage {
            get {
                return ResourceManager.GetString("DoNotMixBlockingAndAsyncMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Don&apos;t Mix Blocking and Async.
        /// </summary>
        internal static string DoNotMixBlockingAndAsyncTitle {
            get {
                return ResourceManager.GetString("DoNotMixBlockingAndAsyncTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #N/A.
        /// </summary>
        internal static string DoNotPassAsyncLambdasAsVoidReturningDelegateTypesDescription {
            get {
                return ResourceManager.GetString("DoNotPassAsyncLambdasAsVoidReturningDelegateTypesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Don&apos;t Pass Async Lambdas as Void Returning Delegate Types.
        /// </summary>
        internal static string DoNotPassAsyncLambdasAsVoidReturningDelegateTypesMessage {
            get {
                return ResourceManager.GetString("DoNotPassAsyncLambdasAsVoidReturningDelegateTypesMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Don&apos;t Pass Async Lambdas as Void Returning Delegate Types.
        /// </summary>
        internal static string DoNotPassAsyncLambdasAsVoidReturningDelegateTypesTitle {
            get {
                return ResourceManager.GetString("DoNotPassAsyncLambdasAsVoidReturningDelegateTypesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A method that is not expected to throw exceptions throws an exception..
        /// </summary>
        internal static string DoNotRaiseExceptionsInUnexpectedLocationsDescription {
            get {
                return ResourceManager.GetString("DoNotRaiseExceptionsInUnexpectedLocationsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} creates an exception of type {1}, an exception type that should not be raised in this type of method. If this exception instance might be raised, either use a different exception type or change this method&apos;s logic so that it no longer raises an exception..
        /// </summary>
        internal static string DoNotRaiseExceptionsInUnexpectedLocationsMessageHasAllowedExceptions {
            get {
                return ResourceManager.GetString("DoNotRaiseExceptionsInUnexpectedLocationsMessageHasAllowedExceptions", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} creates an exception of type {1}. Exceptions should not be raised in this type of method. If this exception instance might be raised, change this method&apos;s logic so it no longer raises an exception..
        /// </summary>
        internal static string DoNotRaiseExceptionsInUnexpectedLocationsMessageNoAllowedExceptions {
            get {
                return ResourceManager.GetString("DoNotRaiseExceptionsInUnexpectedLocationsMessageNoAllowedExceptions", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} creates an exception of type {1}, an exception type that should not be raised in a property. If this exception instance might be raised, use a different exception type, convert this property into a method, or change this property&apos;s logic so that it no longer raises an exception..
        /// </summary>
        internal static string DoNotRaiseExceptionsInUnexpectedLocationsMessagePropertyGetter {
            get {
                return ResourceManager.GetString("DoNotRaiseExceptionsInUnexpectedLocationsMessagePropertyGetter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not raise exceptions in unexpected locations.
        /// </summary>
        internal static string DoNotRaiseExceptionsInUnexpectedLocationsTitle {
            get {
                return ResourceManager.GetString("DoNotRaiseExceptionsInUnexpectedLocationsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #N/A.
        /// </summary>
        internal static string DoNotStoreAsyncLambdasAsVoidReturningDelegateTypesDescription {
            get {
                return ResourceManager.GetString("DoNotStoreAsyncLambdasAsVoidReturningDelegateTypesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Don&apos;t Store Async Lambdas as Void Returning Delegate Types.
        /// </summary>
        internal static string DoNotStoreAsyncLambdasAsVoidReturningDelegateTypesMessage {
            get {
                return ResourceManager.GetString("DoNotStoreAsyncLambdasAsVoidReturningDelegateTypesMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Don&apos;t Store Async Lambdas as Void Returning Delegate Types.
        /// </summary>
        internal static string DoNotStoreAsyncLambdasAsVoidReturningDelegateTypesTitle {
            get {
                return ResourceManager.GetString("DoNotStoreAsyncLambdasAsVoidReturningDelegateTypesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The default value of an uninitialized enumeration, just as other value types, is zero. A nonflags-attributed enumeration should define a member by using the value of zero so that the default value is a valid value of the enumeration. If an enumeration that has the FlagsAttribute attribute applied defines a zero-valued member, its name should be &quot;&quot;None&quot;&quot; to indicate that no values have been set in the enumeration..
        /// </summary>
        internal static string EnumsShouldHaveZeroValueDescription {
            get {
                return ResourceManager.GetString("EnumsShouldHaveZeroValueDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove all members that have the value zero from {0} except for one member that is named &apos;None&apos;..
        /// </summary>
        internal static string EnumsShouldHaveZeroValueMessageFlagsMultipleZeros {
            get {
                return ResourceManager.GetString("EnumsShouldHaveZeroValueMessageFlagsMultipleZeros", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In enum {0}, change the name of {1} to &apos;None&apos;..
        /// </summary>
        internal static string EnumsShouldHaveZeroValueMessageFlagsRename {
            get {
                return ResourceManager.GetString("EnumsShouldHaveZeroValueMessageFlagsRename", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Add a member to {0} that has a value of zero with a suggested name of &apos;None&apos;..
        /// </summary>
        internal static string EnumsShouldHaveZeroValueMessageNotFlagsNoZeroValue {
            get {
                return ResourceManager.GetString("EnumsShouldHaveZeroValueMessageNotFlagsNoZeroValue", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Enums should have zero value.
        /// </summary>
        internal static string EnumsShouldHaveZeroValueTitle {
            get {
                return ResourceManager.GetString("EnumsShouldHaveZeroValueTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove all members that have the value zero except for one member that is named &apos;None&apos;..
        /// </summary>
        internal static string EnumsShouldZeroValueFlagsMultipleZeroCodeFix {
            get {
                return ResourceManager.GetString("EnumsShouldZeroValueFlagsMultipleZeroCodeFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Rename zero-valued enum field to &apos;None&apos;..
        /// </summary>
        internal static string EnumsShouldZeroValueFlagsRenameCodeFix {
            get {
                return ResourceManager.GetString("EnumsShouldZeroValueFlagsRenameCodeFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Add a zero-valued member &apos;None&apos; to enum..
        /// </summary>
        internal static string EnumsShouldZeroValueNotFlagsNoZeroValueCodeFix {
            get {
                return ResourceManager.GetString("EnumsShouldZeroValueNotFlagsNoZeroValueCodeFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An enumeration is a value type that defines a set of related named constants. By default, the System.Int32 data type is used to store the constant value. Although you can change this underlying type, it is not required or recommended for most scenarios..
        /// </summary>
        internal static string EnumStorageShouldBeInt32Description {
            get {
                return ResourceManager.GetString("EnumStorageShouldBeInt32Description", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to If possible, make the underlying type of {0} System.Int32 instead of {1}..
        /// </summary>
        internal static string EnumStorageShouldBeInt32Message {
            get {
                return ResourceManager.GetString("EnumStorageShouldBeInt32Message", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Enum Storage should be Int32.
        /// </summary>
        internal static string EnumStorageShouldBeInt32Title {
            get {
                return ResourceManager.GetString("EnumStorageShouldBeInt32Title", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An internal exception is visible only inside its own internal scope. After the exception falls outside the internal scope, only the base exception can be used to catch the exception. If the internal exception is inherited from T:System.Exception, T:System.SystemException, or T:System.ApplicationException, the external code will not have sufficient information to know what to do with the exception..
        /// </summary>
        internal static string ExceptionsShouldBePublicDescription {
            get {
                return ResourceManager.GetString("ExceptionsShouldBePublicDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Exceptions should be public.
        /// </summary>
        internal static string ExceptionsShouldBePublicMessage {
            get {
                return ResourceManager.GetString("ExceptionsShouldBePublicMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Exceptions should be public.
        /// </summary>
        internal static string ExceptionsShouldBePublicTitle {
            get {
                return ResourceManager.GetString("ExceptionsShouldBePublicTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A public enumeration has the System.FlagsAttribute attribute, and its name does not end in &quot;&quot;s&quot;&quot;. Types that are marked by using FlagsAttribute have names that are plural because the attribute indicates that more than one value can be specified..
        /// </summary>
        internal static string FlagsEnumsShouldHavePluralNamesDescription {
            get {
                return ResourceManager.GetString("FlagsEnumsShouldHavePluralNamesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Flags enums should have plural names.
        /// </summary>
        internal static string FlagsEnumsShouldHavePluralNamesMessage {
            get {
                return ResourceManager.GetString("FlagsEnumsShouldHavePluralNamesMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Flags enums should have plural names.
        /// </summary>
        internal static string FlagsEnumsShouldHavePluralNamesTitle {
            get {
                return ResourceManager.GetString("FlagsEnumsShouldHavePluralNamesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Generate missing operators.
        /// </summary>
        internal static string Generate_missing_operators {
            get {
                return ResourceManager.GetString("Generate_missing_operators", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Identifiers for namespaces, types, members, and parameters cannot differ only by case because languages that target the common language runtime are not required to be case-sensitive..
        /// </summary>
        internal static string IdentifiersShouldDifferByMoreThanCaseDescription {
            get {
                return ResourceManager.GetString("IdentifiersShouldDifferByMoreThanCaseDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Names of &apos;{0}&apos; and &apos;{1}&apos; should differ by more than case..
        /// </summary>
        internal static string IdentifiersShouldDifferByMoreThanCaseMessage {
            get {
                return ResourceManager.GetString("IdentifiersShouldDifferByMoreThanCaseMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Identifiers should differ by more than case.
        /// </summary>
        internal static string IdentifiersShouldDifferByMoreThanCaseTitle {
            get {
                return ResourceManager.GetString("IdentifiersShouldDifferByMoreThanCaseTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The name of an externally visible interface does not start with an uppercase &quot;&quot;I&quot;&quot;. The name of a generic type parameter on an externally visible type or method does not start with an uppercase &quot;&quot;T&quot;&quot;..
        /// </summary>
        internal static string IdentifiersShouldHaveCorrectPrefixDescription {
            get {
                return ResourceManager.GetString("IdentifiersShouldHaveCorrectPrefixDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Prefix interface name {0} with &apos;I&apos;..
        /// </summary>
        internal static string IdentifiersShouldHaveCorrectPrefixMessageInterface {
            get {
                return ResourceManager.GetString("IdentifiersShouldHaveCorrectPrefixMessageInterface", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Prefix generic type parameter name {0} with &apos;T&apos;..
        /// </summary>
        internal static string IdentifiersShouldHaveCorrectPrefixMessageTypeParameter {
            get {
                return ResourceManager.GetString("IdentifiersShouldHaveCorrectPrefixMessageTypeParameter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Identifiers should have correct prefix.
        /// </summary>
        internal static string IdentifiersShouldHaveCorrectPrefixTitle {
            get {
                return ResourceManager.GetString("IdentifiersShouldHaveCorrectPrefixTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to By convention, the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, have a suffix that is associated with the base type or interface..
        /// </summary>
        internal static string IdentifiersShouldHaveCorrectSuffixDescription {
            get {
                return ResourceManager.GetString("IdentifiersShouldHaveCorrectSuffixDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Rename {0} to end in &apos;{1}&apos;..
        /// </summary>
        internal static string IdentifiersShouldHaveCorrectSuffixMessageDefault {
            get {
                return ResourceManager.GetString("IdentifiersShouldHaveCorrectSuffixMessageDefault", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Rename {0} to end in either &apos;Collection&apos; or &apos;{1}&apos;..
        /// </summary>
        internal static string IdentifiersShouldHaveCorrectSuffixMessageSpecialCollection {
            get {
                return ResourceManager.GetString("IdentifiersShouldHaveCorrectSuffixMessageSpecialCollection", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Identifiers should have correct suffix.
        /// </summary>
        internal static string IdentifiersShouldHaveCorrectSuffixTitle {
            get {
                return ResourceManager.GetString("IdentifiersShouldHaveCorrectSuffixTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to 
        ///Names of parameters and members are better used to communicate their meaning than to describe their type, which is expected to be provided by development tools. For names of members, if a data type name must be used, use a language-independent name instead of a language-specific one..
        /// </summary>
        internal static string IdentifiersShouldNotContainTypeNamesDescription {
            get {
                return ResourceManager.GetString("IdentifiersShouldNotContainTypeNamesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Identifier &apos;{0}&apos; contains type name.
        /// </summary>
        internal static string IdentifiersShouldNotContainTypeNamesMessage {
            get {
                return ResourceManager.GetString("IdentifiersShouldNotContainTypeNamesMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Identifier contains type name.
        /// </summary>
        internal static string IdentifiersShouldNotContainTypeNamesTitle {
            get {
                return ResourceManager.GetString("IdentifiersShouldNotContainTypeNamesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to By convention, identifier names do not contain the underscore (_) character. This rule checks namespaces, types, members, and parameters..
        /// </summary>
        internal static string IdentifiersShouldNotContainUnderscoresDescription {
            get {
                return ResourceManager.GetString("IdentifiersShouldNotContainUnderscoresDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove the underscores from assembly name {0}..
        /// </summary>
        internal static string IdentifiersShouldNotContainUnderscoresMessageAssembly {
            get {
                return ResourceManager.GetString("IdentifiersShouldNotContainUnderscoresMessageAssembly", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In delegate {0}, remove the underscores from parameter name {1}..
        /// </summary>
        internal static string IdentifiersShouldNotContainUnderscoresMessageDelegateParameter {
            get {
                return ResourceManager.GetString("IdentifiersShouldNotContainUnderscoresMessageDelegateParameter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove the underscores from member name {0}..
        /// </summary>
        internal static string IdentifiersShouldNotContainUnderscoresMessageMember {
            get {
                return ResourceManager.GetString("IdentifiersShouldNotContainUnderscoresMessageMember", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In member {0}, remove the underscores from parameter name {1}..
        /// </summary>
        internal static string IdentifiersShouldNotContainUnderscoresMessageMemberParameter {
            get {
                return ResourceManager.GetString("IdentifiersShouldNotContainUnderscoresMessageMemberParameter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to On method {0}, remove the underscores from generic type parameter name {1}..
        /// </summary>
        internal static string IdentifiersShouldNotContainUnderscoresMessageMethodTypeParameter {
            get {
                return ResourceManager.GetString("IdentifiersShouldNotContainUnderscoresMessageMethodTypeParameter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove the underscores from namespace name &apos;{0}&apos;..
        /// </summary>
        internal static string IdentifiersShouldNotContainUnderscoresMessageNamespace {
            get {
                return ResourceManager.GetString("IdentifiersShouldNotContainUnderscoresMessageNamespace", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove the underscores from type name {0}..
        /// </summary>
        internal static string IdentifiersShouldNotContainUnderscoresMessageType {
            get {
                return ResourceManager.GetString("IdentifiersShouldNotContainUnderscoresMessageType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to On type {0}, remove the underscores from generic type parameter name {1}..
        /// </summary>
        internal static string IdentifiersShouldNotContainUnderscoresMessageTypeTypeParameter {
            get {
                return ResourceManager.GetString("IdentifiersShouldNotContainUnderscoresMessageTypeTypeParameter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Identifiers should not contain underscores.
        /// </summary>
        internal static string IdentifiersShouldNotContainUnderscoresTitle {
            get {
                return ResourceManager.GetString("IdentifiersShouldNotContainUnderscoresTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to By convention, only the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, should end with specific reserved suffixes. Other type names should not use these reserved suffixes..
        /// </summary>
        internal static string IdentifiersShouldNotHaveIncorrectSuffixDescription {
            get {
                return ResourceManager.GetString("IdentifiersShouldNotHaveIncorrectSuffixDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Either replace the suffix &apos;{0}&apos; in member name {1} with the suggested numeric alternate &apos;2&apos; or provide a more meaningful suffix that distinguishes it from the member it replaces..
        /// </summary>
        internal static string IdentifiersShouldNotHaveIncorrectSuffixMessageMemberNewerVersion {
            get {
                return ResourceManager.GetString("IdentifiersShouldNotHaveIncorrectSuffixMessageMemberNewerVersion", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Either replace the suffix &apos;{0}&apos; in member name &apos;{1}&apos; with the suggested alternate &apos;{2}&apos; or remove the suffix completely..
        /// </summary>
        internal static string IdentifiersShouldNotHaveIncorrectSuffixMessageMemberWithAlternate {
            get {
                return ResourceManager.GetString("IdentifiersShouldNotHaveIncorrectSuffixMessageMemberWithAlternate", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Either replace the suffix &apos;{0}&apos; in type name {1} with the suggested numeric alternate &apos;2&apos; or provide a more meaningful suffix that distinguishes it from the type it replaces..
        /// </summary>
        internal static string IdentifiersShouldNotHaveIncorrectSuffixMessageTypeNewerVersion {
            get {
                return ResourceManager.GetString("IdentifiersShouldNotHaveIncorrectSuffixMessageTypeNewerVersion", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Rename type name {0} so that it does not end in &apos;{1}&apos;..
        /// </summary>
        internal static string IdentifiersShouldNotHaveIncorrectSuffixMessageTypeNoAlternate {
            get {
                return ResourceManager.GetString("IdentifiersShouldNotHaveIncorrectSuffixMessageTypeNoAlternate", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Identifiers should not have incorrect suffix.
        /// </summary>
        internal static string IdentifiersShouldNotHaveIncorrectSuffixTitle {
            get {
                return ResourceManager.GetString("IdentifiersShouldNotHaveIncorrectSuffixTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A namespace name or a type name matches a reserved keyword in a programming language. Identifiers for namespaces and types should not match keywords that are defined by languages that target the common language runtime..
        /// </summary>
        internal static string IdentifiersShouldNotMatchKeywordsDescription {
            get {
                return ResourceManager.GetString("IdentifiersShouldNotMatchKeywordsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Rename virtual/interface member {0} so that it no longer conflicts with the reserved language keyword &apos;{1}&apos;. Using a reserved keyword as the name of a virtual/interface member makes it harder for consumers in other languages to override/implement the member..
        /// </summary>
        internal static string IdentifiersShouldNotMatchKeywordsMessageMember {
            get {
                return ResourceManager.GetString("IdentifiersShouldNotMatchKeywordsMessageMember", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In virtual/interface member {0}, rename parameter {1} so that it no longer conflicts with the reserved language keyword &apos;{2}&apos;. Using a reserved keyword as the name of a parameter on a virtual/interface member makes it harder for consumers in other languages to override/implement the member..
        /// </summary>
        internal static string IdentifiersShouldNotMatchKeywordsMessageMemberParameter {
            get {
                return ResourceManager.GetString("IdentifiersShouldNotMatchKeywordsMessageMemberParameter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Rename namespace {0} so that it no longer conflicts with the reserved language keyword &apos;{1}&apos;. Using a reserved keyword as the name of a namespace makes it harder for consumers in other languages to use the namespace..
        /// </summary>
        internal static string IdentifiersShouldNotMatchKeywordsMessageNamespace {
            get {
                return ResourceManager.GetString("IdentifiersShouldNotMatchKeywordsMessageNamespace", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Rename type {0} so that it no longer conflicts with the reserved language keyword &apos;{1}&apos;. Using a reserved keyword as the name of a type makes it harder for consumers in other languages to use the type..
        /// </summary>
        internal static string IdentifiersShouldNotMatchKeywordsMessageType {
            get {
                return ResourceManager.GetString("IdentifiersShouldNotMatchKeywordsMessageType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Identifiers should not match keywords.
        /// </summary>
        internal static string IdentifiersShouldNotMatchKeywordsTitle {
            get {
                return ResourceManager.GetString("IdentifiersShouldNotMatchKeywordsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implement Equality and Comparison methods and operators.
        /// </summary>
        internal static string ImplementComparable {
            get {
                return ResourceManager.GetString("ImplementComparable", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to All IDisposable types should implement the Dispose pattern correctly..
        /// </summary>
        internal static string ImplementIDisposableCorrectlyDescription {
            get {
                return ResourceManager.GetString("ImplementIDisposableCorrectlyDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure that {0} is declared as protected, virtual, and unsealed..
        /// </summary>
        internal static string ImplementIDisposableCorrectlyMessageDisposeBoolSignature {
            get {
                return ResourceManager.GetString("ImplementIDisposableCorrectlyMessageDisposeBoolSignature", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Modify {0} so that it calls Dispose(true), then calls GC.SuppressFinalize on the current object instance (&apos;this&apos; or &apos;Me&apos; in Visual Basic), and then returns..
        /// </summary>
        internal static string ImplementIDisposableCorrectlyMessageDisposeImplementation {
            get {
                return ResourceManager.GetString("ImplementIDisposableCorrectlyMessageDisposeImplementation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove {0}, override Dispose(bool disposing), and put the dispose logic in the code path where &apos;disposing&apos; is true..
        /// </summary>
        internal static string ImplementIDisposableCorrectlyMessageDisposeOverride {
            get {
                return ResourceManager.GetString("ImplementIDisposableCorrectlyMessageDisposeOverride", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Ensure that {0} is declared as public and sealed..
        /// </summary>
        internal static string ImplementIDisposableCorrectlyMessageDisposeSignature {
            get {
                return ResourceManager.GetString("ImplementIDisposableCorrectlyMessageDisposeSignature", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Modify {0} so that it calls Dispose(false) and then returns..
        /// </summary>
        internal static string ImplementIDisposableCorrectlyMessageFinalizeImplementation {
            get {
                return ResourceManager.GetString("ImplementIDisposableCorrectlyMessageFinalizeImplementation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove the finalizer from type {0}, override Dispose(bool disposing), and put the finalization logic in the code path where &apos;disposing&apos; is false..
        /// </summary>
        internal static string ImplementIDisposableCorrectlyMessageFinalizeOverride {
            get {
                return ResourceManager.GetString("ImplementIDisposableCorrectlyMessageFinalizeOverride", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove IDisposable from the list of interfaces implemented by {0} and override the base class Dispose implementation instead..
        /// </summary>
        internal static string ImplementIDisposableCorrectlyMessageIDisposableReimplementation {
            get {
                return ResourceManager.GetString("ImplementIDisposableCorrectlyMessageIDisposableReimplementation", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Provide an overridable implementation of Dispose(bool) on {0} or mark the type as sealed. A call to Dispose(false) should only clean up native resources. A call to Dispose(true) should clean up both managed and native resources..
        /// </summary>
        internal static string ImplementIDisposableCorrectlyMessageProvideDisposeBool {
            get {
                return ResourceManager.GetString("ImplementIDisposableCorrectlyMessageProvideDisposeBool", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Rename {0} to &apos;Dispose&apos; and ensure that it is declared as public and sealed..
        /// </summary>
        internal static string ImplementIDisposableCorrectlyMessageRenameDispose {
            get {
                return ResourceManager.GetString("ImplementIDisposableCorrectlyMessageRenameDispose", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implement IDisposable Correctly.
        /// </summary>
        internal static string ImplementIDisposableCorrectlyTitle {
            get {
                return ResourceManager.GetString("ImplementIDisposableCorrectlyTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implement IDisposable Interface.
        /// </summary>
        internal static string ImplementIDisposableInterface {
            get {
                return ResourceManager.GetString("ImplementIDisposableInterface", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to When a type T overrides Object.Equals(object), the implementation must cast the object argument to the correct type T before performing the comparison. If the type implements IEquatable&lt;T&gt;, and therefore offers the method T.Equals(T), and if the argument is known at compile time to be of type T, then the compiler can call IEquatable&lt;T&gt;.Equals(T) instead of Object.Equals(object), and no cast is necessary, improving performance..
        /// </summary>
        internal static string ImplementIEquatableWhenOverridingObjectEqualsDescription {
            get {
                return ResourceManager.GetString("ImplementIEquatableWhenOverridingObjectEqualsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implement IEquatable when overriding Object.Equals.
        /// </summary>
        internal static string ImplementIEquatableWhenOverridingObjectEqualsMessage {
            get {
                return ResourceManager.GetString("ImplementIEquatableWhenOverridingObjectEqualsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type {0} should implement IEquatable&lt;T&gt; because it overrides Equals.
        /// </summary>
        internal static string ImplementIEquatableWhenOverridingObjectEqualsTitle {
            get {
                return ResourceManager.GetString("ImplementIEquatableWhenOverridingObjectEqualsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Failure to provide the full set of constructors can make it difficult to correctly handle exceptions..
        /// </summary>
        internal static string ImplementStandardExceptionConstructorsDescription {
            get {
                return ResourceManager.GetString("ImplementStandardExceptionConstructorsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Change the accessibility of {0} to {1}..
        /// </summary>
        internal static string ImplementStandardExceptionConstructorsMessageAccessibility {
            get {
                return ResourceManager.GetString("ImplementStandardExceptionConstructorsMessageAccessibility", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Add the following constructor to {0}: {1}..
        /// </summary>
        internal static string ImplementStandardExceptionConstructorsMessageMissingConstructor {
            get {
                return ResourceManager.GetString("ImplementStandardExceptionConstructorsMessageMissingConstructor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implement standard exception constructors.
        /// </summary>
        internal static string ImplementStandardExceptionConstructorsTitle {
            get {
                return ResourceManager.GetString("ImplementStandardExceptionConstructorsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An unsealed externally visible type provides an explicit method implementation of a public interface and does not provide an alternative externally visible method that has the same name..
        /// </summary>
        internal static string InterfaceMethodsShouldBeCallableByChildTypesDescription {
            get {
                return ResourceManager.GetString("InterfaceMethodsShouldBeCallableByChildTypesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Make &apos;{0}&apos; protected..
        /// </summary>
        internal static string InterfaceMethodsShouldBeCallableByChildTypesFix1 {
            get {
                return ResourceManager.GetString("InterfaceMethodsShouldBeCallableByChildTypesFix1", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Change &apos;{0}&apos; to a public interface implementation..
        /// </summary>
        internal static string InterfaceMethodsShouldBeCallableByChildTypesFix2 {
            get {
                return ResourceManager.GetString("InterfaceMethodsShouldBeCallableByChildTypesFix2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Make the containing type &apos;{0}&apos; sealed..
        /// </summary>
        internal static string InterfaceMethodsShouldBeCallableByChildTypesFix3 {
            get {
                return ResourceManager.GetString("InterfaceMethodsShouldBeCallableByChildTypesFix3", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Interface methods should be callable by child types.
        /// </summary>
        internal static string InterfaceMethodsShouldBeCallableByChildTypesMessage {
            get {
                return ResourceManager.GetString("InterfaceMethodsShouldBeCallableByChildTypesMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Interface methods should be callable by child types.
        /// </summary>
        internal static string InterfaceMethodsShouldBeCallableByChildTypesTitle {
            get {
                return ResourceManager.GetString("InterfaceMethodsShouldBeCallableByChildTypesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Make Class Static.
        /// </summary>
        internal static string MakeClassStatic {
            get {
                return ResourceManager.GetString("MakeClassStatic", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Make exception public.
        /// </summary>
        internal static string MakeExceptionPublic {
            get {
                return ResourceManager.GetString("MakeExceptionPublic", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Make the getter of the property public.
        /// </summary>
        internal static string MakeGetterPublic {
            get {
                return ResourceManager.GetString("MakeGetterPublic", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Make the setter of the property non-public.
        /// </summary>
        internal static string MakeSetterNonPublic {
            get {
                return ResourceManager.GetString("MakeSetterNonPublic", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The .NET Framework uses the version number to uniquely identify an assembly, and to bind to types in strongly named assemblies. The version number is used together with version and publisher policy. By default, applications run only with the assembly version with which they were built..
        /// </summary>
        internal static string MarkAssembliesWithAssemblyVersionDescription {
            get {
                return ResourceManager.GetString("MarkAssembliesWithAssemblyVersionDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mark assemblies with assembly version.
        /// </summary>
        internal static string MarkAssembliesWithAssemblyVersionMessage {
            get {
                return ResourceManager.GetString("MarkAssembliesWithAssemblyVersionMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mark assemblies with assembly version.
        /// </summary>
        internal static string MarkAssembliesWithAssemblyVersionTitle {
            get {
                return ResourceManager.GetString("MarkAssembliesWithAssemblyVersionTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The Common Language Specification (CLS) defines naming restrictions, data types, and rules to which assemblies must conform if they will be used across programming languages. Good design dictates that all assemblies explicitly indicate CLS compliance by using CLSCompliantAttribute . If this attribute is not present on an assembly, the assembly is not compliant..
        /// </summary>
        internal static string MarkAssembliesWithClsCompliantDescription {
            get {
                return ResourceManager.GetString("MarkAssembliesWithClsCompliantDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mark assemblies with CLSCompliant.
        /// </summary>
        internal static string MarkAssembliesWithClsCompliantMessage {
            get {
                return ResourceManager.GetString("MarkAssembliesWithClsCompliantMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mark assemblies with CLSCompliant.
        /// </summary>
        internal static string MarkAssembliesWithClsCompliantTitle {
            get {
                return ResourceManager.GetString("MarkAssembliesWithClsCompliantTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to ComVisibleAttribute determines how COM clients access managed code. Good design dictates that assemblies explicitly indicate COM visibility. COM visibility can be set for the whole assembly and then overridden for individual types and type members. If this attribute is not present, the contents of the assembly are visible to COM clients..
        /// </summary>
        internal static string MarkAssembliesWithComVisibleDescription {
            get {
                return ResourceManager.GetString("MarkAssembliesWithComVisibleDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Consider changing the ComVisible attribute on {0} to false, and opting in at the type level..
        /// </summary>
        internal static string MarkAssembliesWithComVisibleMessageAttributeTrue {
            get {
                return ResourceManager.GetString("MarkAssembliesWithComVisibleMessageAttributeTrue", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Because {0} exposes externally visible types, mark it with ComVisible(false) at the assembly level and then mark all types within the assembly that should be exposed to COM clients with ComVisible(true)..
        /// </summary>
        internal static string MarkAssembliesWithComVisibleMessageNoAttribute {
            get {
                return ResourceManager.GetString("MarkAssembliesWithComVisibleMessageNoAttribute", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mark assemblies with ComVisible.
        /// </summary>
        internal static string MarkAssembliesWithComVisibleTitle {
            get {
                return ResourceManager.GetString("MarkAssembliesWithComVisibleTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to When you define a custom attribute, mark it by using AttributeUsageAttribute to indicate where in the source code the custom attribute can be applied. The meaning and intended usage of an attribute will determine its valid locations in code..
        /// </summary>
        internal static string MarkAttributesWithAttributeUsageDescription {
            get {
                return ResourceManager.GetString("MarkAttributesWithAttributeUsageDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Specify AttributeUsage on {0}..
        /// </summary>
        internal static string MarkAttributesWithAttributeUsageMessageDefault {
            get {
                return ResourceManager.GetString("MarkAttributesWithAttributeUsageMessageDefault", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Even though attribute {0} inherits AttributeUsage from its base type, you should consider explicitly specifying AttributeUsage on the type to improve code readability and documentation..
        /// </summary>
        internal static string MarkAttributesWithAttributeUsageMessageInherited {
            get {
                return ResourceManager.GetString("MarkAttributesWithAttributeUsageMessageInherited", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mark attributes with AttributeUsageAttribute.
        /// </summary>
        internal static string MarkAttributesWithAttributeUsageTitle {
            get {
                return ResourceManager.GetString("MarkAttributesWithAttributeUsageTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Apply FlagsAttribute to enum..
        /// </summary>
        internal static string MarkEnumsWithFlagsCodeFix {
            get {
                return ResourceManager.GetString("MarkEnumsWithFlagsCodeFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An enumeration is a value type that defines a set of related named constants. Apply FlagsAttribute to an enumeration when its named constants can be meaningfully combined..
        /// </summary>
        internal static string MarkEnumsWithFlagsDescription {
            get {
                return ResourceManager.GetString("MarkEnumsWithFlagsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mark enums with FlagsAttribute.
        /// </summary>
        internal static string MarkEnumsWithFlagsMessage {
            get {
                return ResourceManager.GetString("MarkEnumsWithFlagsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mark enums with FlagsAttribute.
        /// </summary>
        internal static string MarkEnumsWithFlagsTitle {
            get {
                return ResourceManager.GetString("MarkEnumsWithFlagsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Platform Invocation methods, such as those that are marked by using the System.Runtime.InteropServices.DllImportAttribute attribute, or methods that are defined by using the Declare keyword in Visual Basic, access unmanaged code. These methods should be of the NativeMethods, SafeNativeMethods, or UnsafeNativeMethods class..
        /// </summary>
        internal static string MovePInvokesToNativeMethodsClassDescription {
            get {
                return ResourceManager.GetString("MovePInvokesToNativeMethodsClassDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Move pinvokes to native methods class.
        /// </summary>
        internal static string MovePInvokesToNativeMethodsClassMessage {
            get {
                return ResourceManager.GetString("MovePInvokesToNativeMethodsClassMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Move pinvokes to native methods class.
        /// </summary>
        internal static string MovePInvokesToNativeMethodsClassTitle {
            get {
                return ResourceManager.GetString("MovePInvokesToNativeMethodsClassTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A nested type is a type that is declared in the scope of another type. Nested types are useful to encapsulate private implementation details of the containing type. Used for this purpose, nested types should not be externally visible..
        /// </summary>
        internal static string NestedTypesShouldNotBeVisibleDescription {
            get {
                return ResourceManager.GetString("NestedTypesShouldNotBeVisibleDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not nest type {0}. Alternatively, change its accessibility so that it is not externally visible..
        /// </summary>
        internal static string NestedTypesShouldNotBeVisibleMessageDefault {
            get {
                return ResourceManager.GetString("NestedTypesShouldNotBeVisibleMessageDefault", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not nest type {0}. Alternatively, change its accessibility so that it is not externally visible. If this type is defined in a Visual Basic Module, it will be considered a nested type to other .NET languages. In that case, consider moving the type outside of the Module..
        /// </summary>
        internal static string NestedTypesShouldNotBeVisibleMessageVisualBasicModule {
            get {
                return ResourceManager.GetString("NestedTypesShouldNotBeVisibleMessageVisualBasicModule", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Nested types should not be visible.
        /// </summary>
        internal static string NestedTypesShouldNotBeVisibleTitle {
            get {
                return ResourceManager.GetString("NestedTypesShouldNotBeVisibleTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Static fields that are neither constants nor read-only are not thread-safe. Access to such a field must be carefully controlled and requires advanced programming techniques to synchronize access to the class object..
        /// </summary>
        internal static string NonConstantFieldsShouldNotBeVisibleDescription {
            get {
                return ResourceManager.GetString("NonConstantFieldsShouldNotBeVisibleDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Non-constant fields should not be visible.
        /// </summary>
        internal static string NonConstantFieldsShouldNotBeVisibleMessage {
            get {
                return ResourceManager.GetString("NonConstantFieldsShouldNotBeVisibleMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Non-constant fields should not be visible.
        /// </summary>
        internal static string NonConstantFieldsShouldNotBeVisibleTitle {
            get {
                return ResourceManager.GetString("NonConstantFieldsShouldNotBeVisibleTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Naming conventions dictate that a plural name for an enumeration indicates that more than one value of the enumeration can be specified at the same time..
        /// </summary>
        internal static string OnlyFlagsEnumsShouldHavePluralNamesDescription {
            get {
                return ResourceManager.GetString("OnlyFlagsEnumsShouldHavePluralNamesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Only FlagsAttribute enums should have plural names.
        /// </summary>
        internal static string OnlyFlagsEnumsShouldHavePluralNamesMessage {
            get {
                return ResourceManager.GetString("OnlyFlagsEnumsShouldHavePluralNamesMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Only FlagsAttribute enums should have plural names.
        /// </summary>
        internal static string OnlyFlagsEnumsShouldHavePluralNamesTitle {
            get {
                return ResourceManager.GetString("OnlyFlagsEnumsShouldHavePluralNamesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An operator overload was detected, and the expected named alternative method was not found. The named alternative member provides access to the same functionality as the operator and is provided for developers who program in languages that do not support overloaded operators..
        /// </summary>
        internal static string OperatorOverloadsHaveNamedAlternatesDescription {
            get {
                return ResourceManager.GetString("OperatorOverloadsHaveNamedAlternatesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Provide a method named &apos;{0}&apos; as a friendly alternate for operator {1}..
        /// </summary>
        internal static string OperatorOverloadsHaveNamedAlternatesMessageDefault {
            get {
                return ResourceManager.GetString("OperatorOverloadsHaveNamedAlternatesMessageDefault", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Provide a method named &apos;{0}&apos; or &apos;{1}&apos; as an alternate for operator {2}..
        /// </summary>
        internal static string OperatorOverloadsHaveNamedAlternatesMessageMultiple {
            get {
                return ResourceManager.GetString("OperatorOverloadsHaveNamedAlternatesMessageMultiple", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Provide a property named &apos;{0}&apos; as a friendly alternate for operator {1}..
        /// </summary>
        internal static string OperatorOverloadsHaveNamedAlternatesMessageProperty {
            get {
                return ResourceManager.GetString("OperatorOverloadsHaveNamedAlternatesMessageProperty", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mark {0} as public because it is a friendly alternate for operator {1}..
        /// </summary>
        internal static string OperatorOverloadsHaveNamedAlternatesMessageVisibility {
            get {
                return ResourceManager.GetString("OperatorOverloadsHaveNamedAlternatesMessageVisibility", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Operator overloads have named alternates.
        /// </summary>
        internal static string OperatorOverloadsHaveNamedAlternatesTitle {
            get {
                return ResourceManager.GetString("OperatorOverloadsHaveNamedAlternatesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A type implements the equality or inequality operator and does not implement the opposite operator..
        /// </summary>
        internal static string OperatorsShouldHaveSymmetricalOverloadsDescription {
            get {
                return ResourceManager.GetString("OperatorsShouldHaveSymmetricalOverloadsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Operators should have symmetrical overloads.
        /// </summary>
        internal static string OperatorsShouldHaveSymmetricalOverloadsMessage {
            get {
                return ResourceManager.GetString("OperatorsShouldHaveSymmetricalOverloadsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Operators should have symmetrical overloads.
        /// </summary>
        internal static string OperatorsShouldHaveSymmetricalOverloadsTitle {
            get {
                return ResourceManager.GetString("OperatorsShouldHaveSymmetricalOverloadsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In most programming languages there is no default implementation of the equality operator (==) for value types. If your programming language supports operator overloads, you should consider implementing the equality operator. Its behavior should be identical to that of Equals.
        /// </summary>
        internal static string OverloadOperatorEqualsOnOverridingValueTypeEqualsDescription {
            get {
                return ResourceManager.GetString("OverloadOperatorEqualsOnOverridingValueTypeEqualsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Overload operator equals on overriding value type Equals.
        /// </summary>
        internal static string OverloadOperatorEqualsOnOverridingValueTypeEqualsMessage {
            get {
                return ResourceManager.GetString("OverloadOperatorEqualsOnOverridingValueTypeEqualsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Overload operator equals on overriding value type Equals.
        /// </summary>
        internal static string OverloadOperatorEqualsOnOverridingValueTypeEqualsTitle {
            get {
                return ResourceManager.GetString("OverloadOperatorEqualsOnOverridingValueTypeEqualsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to For value types, the inherited implementation of Equals uses the Reflection library and compares the contents of all fields. Reflection is computationally expensive, and comparing every field for equality might be unnecessary. If you expect users to compare or sort instances, or to use instances as hash table keys, your value type should implement Equals..
        /// </summary>
        internal static string OverrideEqualsAndOperatorEqualsOnValueTypesDescription {
            get {
                return ResourceManager.GetString("OverrideEqualsAndOperatorEqualsOnValueTypesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} should override Equals..
        /// </summary>
        internal static string OverrideEqualsAndOperatorEqualsOnValueTypesMessageEquals {
            get {
                return ResourceManager.GetString("OverrideEqualsAndOperatorEqualsOnValueTypesMessageEquals", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} should override the equality (==) and inequality (!=) operators..
        /// </summary>
        internal static string OverrideEqualsAndOperatorEqualsOnValueTypesMessageOpEquality {
            get {
                return ResourceManager.GetString("OverrideEqualsAndOperatorEqualsOnValueTypesMessageOpEquality", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Override equals and operator equals on value types.
        /// </summary>
        internal static string OverrideEqualsAndOperatorEqualsOnValueTypesTitle {
            get {
                return ResourceManager.GetString("OverrideEqualsAndOperatorEqualsOnValueTypesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Override object.Equals.
        /// </summary>
        internal static string OverrideEqualsOnOverloadingOperatorEqualsCodeActionTitle {
            get {
                return ResourceManager.GetString("OverrideEqualsOnOverloadingOperatorEqualsCodeActionTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A public type implements the equality operator but does not override Object.Equals..
        /// </summary>
        internal static string OverrideEqualsOnOverloadingOperatorEqualsDescription {
            get {
                return ResourceManager.GetString("OverrideEqualsOnOverloadingOperatorEqualsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Override Equals on overloading operator equals.
        /// </summary>
        internal static string OverrideEqualsOnOverloadingOperatorEqualsMessage {
            get {
                return ResourceManager.GetString("OverrideEqualsOnOverloadingOperatorEqualsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Override Equals on overloading operator equals.
        /// </summary>
        internal static string OverrideEqualsOnOverloadingOperatorEqualsTitle {
            get {
                return ResourceManager.GetString("OverrideEqualsOnOverloadingOperatorEqualsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Override object.GetHashCode.
        /// </summary>
        internal static string OverrideGetHashCodeOnOverridingEqualsCodeActionTitle {
            get {
                return ResourceManager.GetString("OverrideGetHashCodeOnOverridingEqualsCodeActionTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to GetHashCode returns a value, based on the current instance, that is suited for hashing algorithms and data structures such as a hash table. Two objects that are the same type and are equal must return the same hash code..
        /// </summary>
        internal static string OverrideGetHashCodeOnOverridingEqualsDescription {
            get {
                return ResourceManager.GetString("OverrideGetHashCodeOnOverridingEqualsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Override GetHashCode on overriding Equals.
        /// </summary>
        internal static string OverrideGetHashCodeOnOverridingEqualsMessage {
            get {
                return ResourceManager.GetString("OverrideGetHashCodeOnOverridingEqualsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Override GetHashCode on overriding Equals.
        /// </summary>
        internal static string OverrideGetHashCodeOnOverridingEqualsTitle {
            get {
                return ResourceManager.GetString("OverrideGetHashCodeOnOverridingEqualsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A public or protected type implements the System.IComparable interface. It does not override Object.Equals nor does it overload the language-specific operator for equality, inequality, less than, less than or equal, greater than or greater than or equal..
        /// </summary>
        internal static string OverrideMethodsOnComparableTypesDescription {
            get {
                return ResourceManager.GetString("OverrideMethodsOnComparableTypesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} should override Equals since it implements IComparable..
        /// </summary>
        internal static string OverrideMethodsOnComparableTypesMessageEquals {
            get {
                return ResourceManager.GetString("OverrideMethodsOnComparableTypesMessageEquals", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} should define operator &apos;{1}&apos; since it implements IComparable..
        /// </summary>
        internal static string OverrideMethodsOnComparableTypesMessageOperator {
            get {
                return ResourceManager.GetString("OverrideMethodsOnComparableTypesMessageOperator", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Override methods on comparable types.
        /// </summary>
        internal static string OverrideMethodsOnComparableTypesTitle {
            get {
                return ResourceManager.GetString("OverrideMethodsOnComparableTypesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to When a type T implements the interface IEquatable&lt;T&gt;, it suggests to a user who sees a call to the Equals method in source code that an instance of the type can be equated with an instance of any other type. The user might be confused if their attempt to equate the type with an instance of another type fails to compile. This violates the &quot;principle of least surprise&quot;..
        /// </summary>
        internal static string OverrideObjectEqualsDescription {
            get {
                return ResourceManager.GetString("OverrideObjectEqualsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type {0} should override Equals because it implements IEquatable&lt;T&gt;.
        /// </summary>
        internal static string OverrideObjectEqualsMessage {
            get {
                return ResourceManager.GetString("OverrideObjectEqualsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Override Object.Equals(object) when implementing IEquatable&lt;T&gt;.
        /// </summary>
        internal static string OverrideObjectEqualsTitle {
            get {
                return ResourceManager.GetString("OverrideObjectEqualsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Consistent naming of parameters in an override hierarchy increases the usability of the method overrides. A parameter name in a derived method that differs from the name in the base declaration can cause confusion about whether the method is an override of the base method or a new overload of the method..
        /// </summary>
        internal static string ParameterNamesShouldMatchBaseDeclarationDescription {
            get {
                return ResourceManager.GetString("ParameterNamesShouldMatchBaseDeclarationDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In member {0}, change parameter name {1} to {2} in order to match the identifier as it has been declared in {3}..
        /// </summary>
        internal static string ParameterNamesShouldMatchBaseDeclarationMessage {
            get {
                return ResourceManager.GetString("ParameterNamesShouldMatchBaseDeclarationMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Parameter names should match base declaration.
        /// </summary>
        internal static string ParameterNamesShouldMatchBaseDeclarationTitle {
            get {
                return ResourceManager.GetString("ParameterNamesShouldMatchBaseDeclarationTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A call is made to a method that has a string parameter whose name contains &quot;uri&quot;, &quot;URI&quot;, &quot;urn&quot;, &quot;URN&quot;, &quot;url&quot;, or &quot;URL&quot;. The declaring type of the method contains a corresponding method overload that has a System.Uri parameter..
        /// </summary>
        internal static string PassSystemUriObjectsInsteadOfStringsDescription {
            get {
                return ResourceManager.GetString("PassSystemUriObjectsInsteadOfStringsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Modify &apos;{0}&apos; to call &apos;{1}&apos; instead of &apos;{2}&apos;..
        /// </summary>
        internal static string PassSystemUriObjectsInsteadOfStringsMessage {
            get {
                return ResourceManager.GetString("PassSystemUriObjectsInsteadOfStringsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Pass system uri objects instead of strings.
        /// </summary>
        internal static string PassSystemUriObjectsInsteadOfStringsTitle {
            get {
                return ResourceManager.GetString("PassSystemUriObjectsInsteadOfStringsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to #N/A.
        /// </summary>
        internal static string PropagateCancellationTokensWhenPossibleDescription {
            get {
                return ResourceManager.GetString("PropagateCancellationTokensWhenPossibleDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Propagate CancellationTokens When Possible.
        /// </summary>
        internal static string PropagateCancellationTokensWhenPossibleMessage {
            get {
                return ResourceManager.GetString("PropagateCancellationTokensWhenPossibleMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Propagate CancellationTokens When Possible.
        /// </summary>
        internal static string PropagateCancellationTokensWhenPossibleTitle {
            get {
                return ResourceManager.GetString("PropagateCancellationTokensWhenPossibleTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Although it is acceptable and often necessary to have a read-only property, the design guidelines prohibit the use of write-only properties. This is because letting a user set a value, and then preventing the user from viewing that value, does not provide any security. Also, without read access, the state of shared objects cannot be viewed, which limits their usefulness..
        /// </summary>
        internal static string PropertiesShouldNotBeWriteOnlyDescription {
            get {
                return ResourceManager.GetString("PropertiesShouldNotBeWriteOnlyDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Because property {0} is write-only, either add a property getter with an accessibility that is greater than or equal to its setter or convert this property into a method..
        /// </summary>
        internal static string PropertiesShouldNotBeWriteOnlyMessageAddGetter {
            get {
                return ResourceManager.GetString("PropertiesShouldNotBeWriteOnlyMessageAddGetter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Because the property getter for {0} is less visible than its setter, either increase the accessibility of its getter or decrease the accessibility of its setter..
        /// </summary>
        internal static string PropertiesShouldNotBeWriteOnlyMessageMakeMoreAccessible {
            get {
                return ResourceManager.GetString("PropertiesShouldNotBeWriteOnlyMessageMakeMoreAccessible", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Properties should not be write only.
        /// </summary>
        internal static string PropertiesShouldNotBeWriteOnlyTitle {
            get {
                return ResourceManager.GetString("PropertiesShouldNotBeWriteOnlyTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Arrays that are returned by properties are not write-protected, even when the property is read-only. To keep the array tamper-proof, the property must return a copy of the array. Typically, users will not understand the adverse performance implications of calling such a property..
        /// </summary>
        internal static string PropertiesShouldNotReturnArraysDescription {
            get {
                return ResourceManager.GetString("PropertiesShouldNotReturnArraysDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Properties should not return arrays.
        /// </summary>
        internal static string PropertiesShouldNotReturnArraysMessage {
            get {
                return ResourceManager.GetString("PropertiesShouldNotReturnArraysMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Properties should not return arrays.
        /// </summary>
        internal static string PropertiesShouldNotReturnArraysTitle {
            get {
                return ResourceManager.GetString("PropertiesShouldNotReturnArraysTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The name of a public or protected member starts with &quot;&quot;Get&quot;&quot; and otherwise matches the name of a public or protected property. &quot;&quot;Get&quot;&quot; methods and properties should have names that clearly distinguish their function..
        /// </summary>
        internal static string PropertyNamesShouldNotMatchGetMethodsDescription {
            get {
                return ResourceManager.GetString("PropertyNamesShouldNotMatchGetMethodsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The property name &apos;{0}&apos; is confusing given the existence of method &apos;{1}&apos;. Rename or remove one of these members..
        /// </summary>
        internal static string PropertyNamesShouldNotMatchGetMethodsMessage {
            get {
                return ResourceManager.GetString("PropertyNamesShouldNotMatchGetMethodsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Property names should not match get methods.
        /// </summary>
        internal static string PropertyNamesShouldNotMatchGetMethodsTitle {
            get {
                return ResourceManager.GetString("PropertyNamesShouldNotMatchGetMethodsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A type or member is marked by using a System.ObsoleteAttribute attribute that does not have its ObsoleteAttribute.Message property specified. When a type or member that is marked by using ObsoleteAttribute is compiled, the Message property of the attribute is displayed. This gives the user information about the obsolete type or member..
        /// </summary>
        internal static string ProvideObsoleteAttributeMessageDescription {
            get {
                return ResourceManager.GetString("ProvideObsoleteAttributeMessageDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Provide a message for the ObsoleteAttribute that marks {0} as Obsolete.
        /// </summary>
        internal static string ProvideObsoleteAttributeMessageMessage {
            get {
                return ResourceManager.GetString("ProvideObsoleteAttributeMessageMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Provide ObsoleteAttribute message.
        /// </summary>
        internal static string ProvideObsoleteAttributeMessageTitle {
            get {
                return ResourceManager.GetString("ProvideObsoleteAttributeMessageTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Rename to &apos;{0}&apos;.
        /// </summary>
        internal static string RenameToTitle {
            get {
                return ResourceManager.GetString("RenameToTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Since &apos;{0}&apos; redefines operator &apos;{1}&apos;, it should also redefine operator &apos;{2}&apos;.
        /// </summary>
        internal static string Since_0_redefines_operator_1_it_should_also_redefine_operator_2 {
            get {
                return ResourceManager.GetString("Since_0_redefines_operator_1_it_should_also_redefine_operator_2", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; is a static holder type but is neither static nor NotInheritable.
        /// </summary>
        internal static string StaticHolderTypeIsNotStatic {
            get {
                return ResourceManager.GetString("StaticHolderTypeIsNotStatic", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Static holder types should be Static or NotInheritable.
        /// </summary>
        internal static string StaticHolderTypesShouldBeStaticOrNotInheritable {
            get {
                return ResourceManager.GetString("StaticHolderTypesShouldBeStaticOrNotInheritable", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type names should not match the names of namespaces that are defined in the .NET Framework class library. Violating this rule can reduce the usability of the library..
        /// </summary>
        internal static string TypeNamesShouldNotMatchNamespacesDescription {
            get {
                return ResourceManager.GetString("TypeNamesShouldNotMatchNamespacesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The type name {0} conflicts in whole or in part with the namespace name &apos;{1}&apos;. Change either name to eliminate the conflict..
        /// </summary>
        internal static string TypeNamesShouldNotMatchNamespacesMessageDefault {
            get {
                return ResourceManager.GetString("TypeNamesShouldNotMatchNamespacesMessageDefault", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The type name {0} conflicts in whole or in part with the namespace name &apos;{1}&apos; defined in the .NET Framework. Rename the type to eliminate the conflict..
        /// </summary>
        internal static string TypeNamesShouldNotMatchNamespacesMessageSystem {
            get {
                return ResourceManager.GetString("TypeNamesShouldNotMatchNamespacesMessageSystem", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type names should not match namespaces.
        /// </summary>
        internal static string TypeNamesShouldNotMatchNamespacesTitle {
            get {
                return ResourceManager.GetString("TypeNamesShouldNotMatchNamespacesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A class declares and implements an instance field that is a System.IDisposable type, and the class does not implement IDisposable. A class that declares an IDisposable field indirectly owns an unmanaged resource and should implement the IDisposable interface..
        /// </summary>
        internal static string TypesThatOwnDisposableFieldsShouldBeDisposableDescription {
            get {
                return ResourceManager.GetString("TypesThatOwnDisposableFieldsShouldBeDisposableDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implement IDisposable on {0} because it creates members of the following IDisposable types: {1}. If {0} has previously shipped, adding new members that implement IDisposable to this type is considered a breaking change to existing consumers..
        /// </summary>
        internal static string TypesThatOwnDisposableFieldsShouldBeDisposableMessageDependsOnFix {
            get {
                return ResourceManager.GetString("TypesThatOwnDisposableFieldsShouldBeDisposableMessageDependsOnFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; owns disposable fields but is not disposable.
        /// </summary>
        internal static string TypesThatOwnDisposableFieldsShouldBeDisposableMessageNonBreaking {
            get {
                return ResourceManager.GetString("TypesThatOwnDisposableFieldsShouldBeDisposableMessageNonBreaking", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Types that own disposable fields should be disposable.
        /// </summary>
        internal static string TypesThatOwnDisposableFieldsShouldBeDisposableTitle {
            get {
                return ResourceManager.GetString("TypesThatOwnDisposableFieldsShouldBeDisposableTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to If a method takes a string representation of a URI, a corresponding overload should be provided that takes an instance of the URI class, which provides these services in a safe and secure manner..
        /// </summary>
        internal static string UriParametersShouldNotBeStringsDescription {
            get {
                return ResourceManager.GetString("UriParametersShouldNotBeStringsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Change the type of parameter {0} of method {1} from string to System.Uri, or provide an overload to {1} that allows {0} to be passed as a System.Uri object..
        /// </summary>
        internal static string UriParametersShouldNotBeStringsMessage {
            get {
                return ResourceManager.GetString("UriParametersShouldNotBeStringsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Uri parameters should not be strings.
        /// </summary>
        internal static string UriParametersShouldNotBeStringsTitle {
            get {
                return ResourceManager.GetString("UriParametersShouldNotBeStringsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule assumes that the property represents a Uniform Resource Identifier (URI). A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner..
        /// </summary>
        internal static string UriPropertiesShouldNotBeStringsDescription {
            get {
                return ResourceManager.GetString("UriPropertiesShouldNotBeStringsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Change the type of property {0} from string to System.Uri..
        /// </summary>
        internal static string UriPropertiesShouldNotBeStringsMessage {
            get {
                return ResourceManager.GetString("UriPropertiesShouldNotBeStringsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Uri properties should not be strings.
        /// </summary>
        internal static string UriPropertiesShouldNotBeStringsTitle {
            get {
                return ResourceManager.GetString("UriPropertiesShouldNotBeStringsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule assumes that the method returns a URI. A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner..
        /// </summary>
        internal static string UriReturnValuesShouldNotBeStringsDescription {
            get {
                return ResourceManager.GetString("UriReturnValuesShouldNotBeStringsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Change the return type of method {0} from string to System.Uri..
        /// </summary>
        internal static string UriReturnValuesShouldNotBeStringsMessage {
            get {
                return ResourceManager.GetString("UriReturnValuesShouldNotBeStringsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Uri return values should not be strings.
        /// </summary>
        internal static string UriReturnValuesShouldNotBeStringsTitle {
            get {
                return ResourceManager.GetString("UriReturnValuesShouldNotBeStringsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to This rule detects methods that have names that ordinarily would be used for events. If a method is called in response to a clearly defined state change, the method should be invoked by an event handler. Objects that call the method should raise events instead of calling the method directly..
        /// </summary>
        internal static string UseEventsWhereAppropriateDescription {
            get {
                return ResourceManager.GetString("UseEventsWhereAppropriateDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Consider making &apos;{0}&apos; an event..
        /// </summary>
        internal static string UseEventsWhereAppropriateMessage {
            get {
                return ResourceManager.GetString("UseEventsWhereAppropriateMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use events where appropriate.
        /// </summary>
        internal static string UseEventsWhereAppropriateTitle {
            get {
                return ResourceManager.GetString("UseEventsWhereAppropriateTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A type contains a delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets Microsoft .NET Framework?2.0..
        /// </summary>
        internal static string UseGenericEventHandlerInstancesDescription {
            get {
                return ResourceManager.GetString("UseGenericEventHandlerInstancesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove {0} and replace its usage with EventHandler&lt;T&gt;.
        /// </summary>
        internal static string UseGenericEventHandlerInstancesMessageDefault {
            get {
                return ResourceManager.GetString("UseGenericEventHandlerInstancesMessageDefault", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Visual Basic generates EventHandler delegates for events that use the following pattern: Event MyEvent(ByVal Sender As Object, ByVal e as MyEventArgs). Change the event that defines EventHandler {0} to use EventHandler&lt;T&gt; by defining the event type explicitly, e.g. Event MyEvent As EventHandler(Of MyEventArgs)..
        /// </summary>
        internal static string UseGenericEventHandlerInstancesMessageVB {
            get {
                return ResourceManager.GetString("UseGenericEventHandlerInstancesMessageVB", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use generic event handler instances.
        /// </summary>
        internal static string UseGenericEventHandlerInstancesTitle {
            get {
                return ResourceManager.GetString("UseGenericEventHandlerInstancesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Indexers, that is, indexed properties, should use integer or string types for the index. These types are typically used for indexing data structures and increase the usability of the library. Use of the Object type should be restricted to those cases where the specific integer or string type cannot be specified at design time. If the design requires other types for the index, reconsider whether the type represents a logical data store. If it does not represent a logical data store, use a method..
        /// </summary>
        internal static string UseIntegralOrStringArgumentForIndexersDescription {
            get {
                return ResourceManager.GetString("UseIntegralOrStringArgumentForIndexersDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use Integral Or String Argument For Indexers.
        /// </summary>
        internal static string UseIntegralOrStringArgumentForIndexersMessage {
            get {
                return ResourceManager.GetString("UseIntegralOrStringArgumentForIndexersMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use Integral Or String Argument For Indexers.
        /// </summary>
        internal static string UseIntegralOrStringArgumentForIndexersTitle {
            get {
                return ResourceManager.GetString("UseIntegralOrStringArgumentForIndexersTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The name of an externally visible identifier includes a term for which an alternative, preferred term exists. Alternatively, the name includes the term &quot;&quot;Flag&quot;&quot; or &quot;&quot;Flags&quot;&quot;..
        /// </summary>
        internal static string UsePreferredTermsDescription {
            get {
                return ResourceManager.GetString("UsePreferredTermsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Replace the term &apos;{0}&apos; in assembly name {1} with the preferred alternate &apos;{2}&apos;..
        /// </summary>
        internal static string UsePreferredTermsMessageAssembly {
            get {
                return ResourceManager.GetString("UsePreferredTermsMessageAssembly", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Replace the term &apos;{0}&apos; in assembly name {1} with an appropriate alternate or remove it entirely..
        /// </summary>
        internal static string UsePreferredTermsMessageAssemblyNoAlternate {
            get {
                return ResourceManager.GetString("UsePreferredTermsMessageAssemblyNoAlternate", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In delegate {0}, replace the term &apos;{1}&apos; in parameter name {2} with the preferred alternate &apos;{3}&apos;..
        /// </summary>
        internal static string UsePreferredTermsMessageDelegateParameter {
            get {
                return ResourceManager.GetString("UsePreferredTermsMessageDelegateParameter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In delegate {0}, replace the term &apos;{1}&apos; in parameter name {2} with an appropriate alternate or remove it entirely..
        /// </summary>
        internal static string UsePreferredTermsMessageDelegateParameterNoAlternate {
            get {
                return ResourceManager.GetString("UsePreferredTermsMessageDelegateParameterNoAlternate", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Replace the term &apos;{0}&apos; in member name {1} with the preferred alternate &apos;{2}&apos;..
        /// </summary>
        internal static string UsePreferredTermsMessageMember {
            get {
                return ResourceManager.GetString("UsePreferredTermsMessageMember", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Replace the term &apos;{0}&apos; in member name {1} with an appropriate alternate or remove it entirely..
        /// </summary>
        internal static string UsePreferredTermsMessageMemberNoAlternate {
            get {
                return ResourceManager.GetString("UsePreferredTermsMessageMemberNoAlternate", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In member {0}, replace the term &apos;{1}&apos; in parameter name {2} with the preferred alternate &apos;{3}&apos;..
        /// </summary>
        internal static string UsePreferredTermsMessageMemberParameter {
            get {
                return ResourceManager.GetString("UsePreferredTermsMessageMemberParameter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In member {0}, replace the term &apos;{1}&apos; in parameter name {2} with an appropriate alternate or remove it entirely..
        /// </summary>
        internal static string UsePreferredTermsMessageMemberParameterNoAlternate {
            get {
                return ResourceManager.GetString("UsePreferredTermsMessageMemberParameterNoAlternate", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to On method {0}, replace the term &apos;{1}&apos; in generic type parameter name {2} with the preferred alternate &apos;{3}&apos;..
        /// </summary>
        internal static string UsePreferredTermsMessageMethodTypeParameter {
            get {
                return ResourceManager.GetString("UsePreferredTermsMessageMethodTypeParameter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to On method {0}, replace the term &apos;{1}&apos; in generic type parameter name {2} with an appropriate alternate or remove it entirely..
        /// </summary>
        internal static string UsePreferredTermsMessageMethodTypeParameterNoAlternate {
            get {
                return ResourceManager.GetString("UsePreferredTermsMessageMethodTypeParameterNoAlternate", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Replace the term &apos;{0}&apos; in namespace name &apos;{1}&apos; with the preferred alternate &apos;{2}&apos;..
        /// </summary>
        internal static string UsePreferredTermsMessageNamespace {
            get {
                return ResourceManager.GetString("UsePreferredTermsMessageNamespace", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Replace the term &apos;{0}&apos; in namespace name &apos;{1}&apos; with an appropriate alternate or remove it entirely..
        /// </summary>
        internal static string UsePreferredTermsMessageNamespaceNoAlternate {
            get {
                return ResourceManager.GetString("UsePreferredTermsMessageNamespaceNoAlternate", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Replace the term &apos;{0}&apos; in type name {1} with the preferred alternate &apos;{2}&apos;..
        /// </summary>
        internal static string UsePreferredTermsMessageType {
            get {
                return ResourceManager.GetString("UsePreferredTermsMessageType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Replace the term &apos;{0}&apos; in type name {1} with an appropriate alternate or remove it entirely..
        /// </summary>
        internal static string UsePreferredTermsMessageTypeNoAlternate {
            get {
                return ResourceManager.GetString("UsePreferredTermsMessageTypeNoAlternate", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to On type {0}, replace the term &apos;{1}&apos; in generic type parameter name {2} with the preferred alternate &apos;{3}&apos;..
        /// </summary>
        internal static string UsePreferredTermsMessageTypeTypeParameter {
            get {
                return ResourceManager.GetString("UsePreferredTermsMessageTypeTypeParameter", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to On type {0}, replace the term &apos;{1}&apos; in generic type parameter name {2} with an appropriate alternate or remove it entirely..
        /// </summary>
        internal static string UsePreferredTermsMessageTypeTypeParameterNoAlternate {
            get {
                return ResourceManager.GetString("UsePreferredTermsMessageTypeTypeParameterNoAlternate", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use preferred terms.
        /// </summary>
        internal static string UsePreferredTermsTitle {
            get {
                return ResourceManager.GetString("UsePreferredTermsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A public or protected method has a name that starts with &quot;&quot;Get&quot;&quot;, takes no parameters, and returns a value that is not an array. The method might be a good candidate to become a property..
        /// </summary>
        internal static string UsePropertiesWhereAppropriateDescription {
            get {
                return ResourceManager.GetString("UsePropertiesWhereAppropriateDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use properties where appropriate.
        /// </summary>
        internal static string UsePropertiesWhereAppropriateMessage {
            get {
                return ResourceManager.GetString("UsePropertiesWhereAppropriateMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use properties where appropriate.
        /// </summary>
        internal static string UsePropertiesWhereAppropriateTitle {
            get {
                return ResourceManager.GetString("UsePropertiesWhereAppropriateTitle", resourceCulture);
            }
        }
    }
}

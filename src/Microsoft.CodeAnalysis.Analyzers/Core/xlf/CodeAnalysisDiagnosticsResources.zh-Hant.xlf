<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="zh-Hant" original="../CodeAnalysisDiagnosticsResources.resx">
    <body>
      <trans-unit id="CompareSymbolsCorrectlyCodeFix">
        <source>Compare symbols correctly</source>
        <target state="new">Compare symbols correctly</target>
        <note />
      </trans-unit>
      <trans-unit id="CompareSymbolsCorrectlyDescription">
        <source>Symbols should be compared for equality, not identity.</source>
        <target state="new">Symbols should be compared for equality, not identity.</target>
        <note />
      </trans-unit>
      <trans-unit id="CompareSymbolsCorrectlyMessage">
        <source>Compare symbols correctly</source>
        <target state="new">Compare symbols correctly</target>
        <note />
      </trans-unit>
      <trans-unit id="CompareSymbolsCorrectlyTitle">
        <source>Compare symbols correctly</source>
        <target state="new">Compare symbols correctly</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingAttributeMessage">
        <source>Missing '{0}' attribute.</source>
        <target state="translated">遺漏 '{0}' 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingDiagnosticAnalyzerAttributeTitle">
        <source>Missing diagnostic analyzer attribute.</source>
        <target state="translated">遺漏診斷分析器屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingDiagnosticAnalyzerAttributeDescription">
        <source>Non-abstract sub-types of DiagnosticAnalyzer should be marked with DiagnosticAnalyzerAttribute(s). The argument to this attribute(s), if any, determine the supported languages for the analyzer. Analyzer types without this attribute will be ignored by the analysis engine.</source>
        <target state="translated">DiagnosticAnalyzer 的非抽象子類型應標記為 DiagnosticAnalyzerAttribute。此屬性的引數 (若有的話) 會決定分析器支援的語言。分析引擎將會略過不含此屬性的分析器類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="AddLanguageSupportToAnalyzerMessage">
        <source>Diagnostic analyzer '{0}' may be able to support both C# and Visual Basic. Consider adding an argument to DiagnosticAnalyzerAttribute for '{1}' language support.</source>
        <target state="translated">診斷分析器 '{0}' 可同時支援 C# 與 Visual Basic。請考慮將對 DiagnosticAnalyzerAttribute 新增一項引數，以取得 '{1}' 語言支援。</target>
        <note />
      </trans-unit>
      <trans-unit id="AddLanguageSupportToAnalyzerTitle">
        <source>Recommend adding language support to diagnostic analyzer.</source>
        <target state="translated">建議為診斷分析器新增語言支援。</target>
        <note />
      </trans-unit>
      <trans-unit id="AddLanguageSupportToAnalyzerDescription">
        <source>Diagnostic analyzer is marked as supporting only one language, but the analyzer assembly doesn't seem to refer to any language specific CodeAnalysis assemblies, and so is likely to work for more than one language. Consider adding an additional language argument to DiagnosticAnalyzerAttribute.</source>
        <target state="translated">診斷分析器標記為只支援一種語言，但分析器組件似乎未參考任何語言專屬的 CodeAnalysis 組件，因此可能適用於多種語言。請考慮對 DiagnosticAnalyzerAttribute 新增其他語言引數。</target>
        <note />
      </trans-unit>
      <trans-unit id="ApplyDiagnosticAnalyzerAttribute_1">
        <source>Apply DiagnosticAnalyzer attribute for '{0}'.</source>
        <target state="translated">為 '{0}' 套用 DiagnosticAnalyzer 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="ApplyDiagnosticAnalyzerAttribute_2">
        <source>Apply DiagnosticAnalyzer attribute for both '{0}' and '{1}'.</source>
        <target state="translated">同時為 '{0}' 與 '{1}' 套用 DiagnosticAnalyzer 屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingSymbolKindArgumentToRegisterActionMessage">
        <source>Specify at least one SymbolKind of interest when registering a symbol analyzer action.</source>
        <target state="translated">註冊符號分析器動作時，請至少指定一個關注的 SymbolKind。</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingSyntaxKindArgumentToRegisterActionMessage">
        <source>Specify at least one SyntaxKind of interest when registering a syntax node analyzer action.</source>
        <target state="translated">註冊語法節點分析器動作時，請至少指定一個關注的 SyntaxKind。</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingOperationKindArgumentToRegisterActionMessage">
        <source>Specify at least one OperationKind of interest when registering an operation analyzer action.</source>
        <target state="translated">註冊作業分析器動作時，請至少指定一個關注的 OperationKind。</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingKindArgumentToRegisterActionTitle">
        <source>Missing kind argument when registering an analyzer action.</source>
        <target state="translated">註冊分析器動作時，遺漏 kind 引數。</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingKindArgumentToRegisterActionDescription">
        <source>You must specify at least one syntax, symbol or operation kind when registering a syntax, symbol, or operation analyzer action respectively. Otherwise, the registered action will never be invoked during analysis.</source>
        <target state="translated">註冊語法、符號或作業分析器動作時，必須個別指定至少一個語法、符號或作業種類。否則，分析期間絕不會叫用註冊的動作。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedSymbolKindArgumentToRegisterActionMessage">
        <source>SymbolKind '{0}' is not supported for symbol analyzer actions.</source>
        <target state="translated">對符號分析器動作不支援 SymbolKind '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedSymbolKindArgumentToRegisterActionTitle">
        <source>Unsupported SymbolKind argument when registering a symbol analyzer action.</source>
        <target state="translated">註冊符號分析器動作時，SymbolKind 引數不受支援。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidReportDiagnosticMessage">
        <source>ReportDiagnostic invoked with an unsupported DiagnosticDescriptor '{0}'.</source>
        <target state="translated">叫用 ReportDiagnostic 時使用了不受支援的 DiagnosticDescriptor '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidReportDiagnosticTitle">
        <source>ReportDiagnostic invoked with an unsupported DiagnosticDescriptor.</source>
        <target state="translated">叫用 ReportDiagnostic 時使用了不受支援的 DiagnosticDescriptor。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidReportDiagnosticDescription">
        <source>ReportDiagnostic should only be invoked with supported DiagnosticDescriptors that are returned from DiagnosticAnalyzer.SupportedDiagnostics property. Otherwise, the reported diagnostic will be filtered out by the analysis engine.</source>
        <target state="translated">叫用 ReportDiagnostic 時，只可使用 DiagnosticAnalyzer.SupportedDiagnostics 屬性所傳回之受支援的 DiagnosticDescriptors。否則，分析引擎將會篩選掉回報的診斷。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidSyntaxKindTypeArgumentMessage">
        <source>Type argument '{0}' for type parameter '{1}' of method '{2}' is not a SyntaxKind enum.</source>
        <target state="translated">方法 '{2}' 之型別參數 '{1}' 的型別引數 '{0}' 並非 SyntaxKind 列舉。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidSyntaxKindTypeArgumentTitle">
        <source>Invalid type argument for DiagnosticAnalyzer's Register method.</source>
        <target state="translated">DiagnosticAnalyzer 之 Register 方法的型別引數無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidSyntaxKindTypeArgumentDescription">
        <source>DiagnosticAnalyzer's language-specific Register methods, such as RegisterSyntaxNodeAction, RegisterCodeBlockStartAction and RegisterCodeBlockEndAction, expect a language-specific 'SyntaxKind' type argument for it's '{0}' type parameter. Otherwise, the registered analyzer action can never be invoked during analysis.</source>
        <target state="translated">DiagnosticAnalyzer 語言專屬的 Register 方法 (例如 RegisterSyntaxNodeAction、RegisterCodeBlockStartAction 與 RegisterCodeBlockEndAction)，必須是其 '{0}' 型別參數的語言專屬 'SyntaxKind' 型別引數。否則，分析期間絕不會叫用註冊的分析器動作。</target>
        <note />
      </trans-unit>
      <trans-unit id="StartActionWithOnlyEndActionTitle">
        <source>Start action has no registered non-end actions.</source>
        <target state="translated">起始動作沒有任何註冊的非結束動作。</target>
        <note />
      </trans-unit>
      <trans-unit id="StartActionWithNoRegisteredActionsMessage">
        <source>'{0}' does not register any analyzer actions. Consider moving actions registered in '{1}' that depend on this start action to '{0}'.</source>
        <target state="translated">'{0}' 並未註冊任何分析器動作。請考慮將註冊於 '{1}' 中且與此起始動作相依的動作，移至 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="StartActionWithNoRegisteredActionsTitle">
        <source>Start action has no registered actions.</source>
        <target state="translated">起始動作沒有任何註冊的動作。</target>
        <note />
      </trans-unit>
      <trans-unit id="StartActionWithOnlyEndActionMessage">
        <source>'{0}' does not register any analyzer actions, except for a '{1}'. Consider replacing this start/end action pair with a '{2}' or moving actions registered in '{3}' that depend on this start action to '{0}'.</source>
        <target state="translated">除了 '{1}' 以外，'{0}' 並未註冊任何分析器動作。請考慮以 '{2}' 取代此成對的起始/結束動作，或將註冊於 '{3}' 中且與此起始動作相依的動作，移至 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulAnalyzerRegisterActionsDescription">
        <source>An analyzer start action enables performing stateful analysis over a given code unit, such as a code block, compilation, etc. Careful design is necessary to achieve efficient analyzer execution without memory leaks. Use the following guidelines for writing such analyzers:
1. Define a new scope for the registered start action, possibly with a private nested type for analyzing each code unit.
2. If required, define and initialize state in the start action.
3. Register at least one non-end action that refers to this state in the start action. If no such action is necessary, consider replacing the start action with a non-start action. For example, a CodeBlockStartAction with no registered actions or only a registered CodeBlockEndAction should be replaced with a CodeBlockAction.
4. If required, register an end action to report diagnostics based on the final state.
</source>
        <target state="translated">分析器起始動作會對指定的程式碼單位 (例如程式碼區塊、編譯等) 執行具狀態的分析。請仔細設計，以達到在沒有流失記憶體的情況下，有效率地執行分析器。使用下列方針撰寫這類分析器:
1.為註冊的起始動作定義新範圍，可能會有私用巢狀型別以分析每個程式碼單位。
2.如有必要，請定義並初始化起始動作中的狀態。
3.至少註冊一個非結束動作，其參考起始動作中的這個狀態。如果不需要這類動作，請考慮以非起始動作取代起始動作。例如，CodeBlockStartAction 沒有任何註冊動作或只有一個註冊的 CodeBlockEndAction 時，應以 CodeBlockAction 取代。
4.如有必要，請註冊結束動作，以根據最終狀態回報診斷。
</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLocalizableStringsInDescriptorMessage">
        <source>Consider providing localizable arguments of type '{0}' to diagnostic descriptor constructor to ensure the descriptor is localizable.</source>
        <target state="translated">請考慮將類型為 '{0}' 的可當地語系化引數，提供給診斷描述元建構函式，以確保該描述元可當地語系化。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLocalizableStringsInDescriptorTitle">
        <source>Provide localizable arguments to diagnostic descriptor constructor.</source>
        <target state="translated">為診斷描述元建構函式提供可當地語系化的引數。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLocalizableStringsInDescriptorDescription">
        <source>If your diagnostic analyzer and it's reported diagnostics need to be localizable, then the supported DiagnosticDescriptors used for constructing the diagnostics must also be localizable. If so, then localizable argument(s) must be provided for parameter 'title' (and optionally 'description') to the diagnostic descriptor constructor to ensure that the descriptor is localizable.</source>
        <target state="translated">如果診斷分析器及其回報的診斷必須可當地語系化，則用於建構診斷之受支援的 DiagnosticDescriptors，也必須可當地語系化。若是如此，則必須為診斷描述元建構函式，對參數 'title' (及選擇性 'description') 提供可當地語系化引數，以確保該描述元可當地語系化。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStorePerCompilationDataOntoFieldsMessage">
        <source>Avoid storing per-compilation data of type '{0}' into the fields of a diagnostic analyzer.</source>
        <target state="translated">避免將類型 '{0}' 的各個編譯資料，儲存至診斷分析器的欄位中。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStorePerCompilationDataOntoFieldsTitle">
        <source>Avoid storing per-compilation data into the fields of a diagnostic analyzer.</source>
        <target state="translated">避免將各個編譯的資料，儲存至診斷分析器的欄位中。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStorePerCompilationDataOntoFieldsDescription">
        <source>Instance of a diagnostic analyzer might outlive the lifetime of compilation. Hence, storing per-compilation data, such as symbols, into the fields of a diagnostic analyzer might cause stale compilations to stay alive and cause memory leaks.  Instead, you should store this data on a separate type instantiated in a compilation start action, registered using '{0}.{1}' API. An instance of this type will be created per-compilation and it won't outlive compilation's lifetime, hence avoiding memory leaks.</source>
        <target state="translated">診斷分析器的執行個體可能會超過編譯的存留期。因此，將各個編譯資料 (例如符號) 儲存至診斷分析器的欄位中，可能會造成過時的編譯仍繼續運作，而導致記憶體流失。而應改為將此資料儲存為另一種在編譯起始動作內具現化，且使用 '{0}.{1}' API 註冊的類型。每個編譯都會建立一個此類型的執行個體，且該執行個體不會超過編譯的存留期，因此可避免記憶體流失。</target>
        <note />
      </trans-unit>
      <trans-unit id="InternalImplementationOnlyDescription">
        <source>The author of this interface did not intend to have third party implementations of this interface and reserves the right to change it. Implementing this interface could therefore result in a source or binary compatibility issue with a future version of this interface.</source>
        <target state="translated">此介面的作者並不希望第三方實作此介面，並保留變更的權利。因此，實作此介面可能會導致與此介面的未來版本，發生原始碼或二進位碼相容性問題。</target>
        <note />
      </trans-unit>
      <trans-unit id="InternalImplementationOnlyMessage">
        <source>Type {0} cannot implement interface {1} because {1} is not available for public implementation.</source>
        <target state="translated">因為 {1} 無法供公用實作使用，所以類型 {0} 無法實作介面 {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="InternalImplementationOnlyTitle">
        <source>Only internal implementations of this interface are allowed.</source>
        <target state="translated">只允許內部實作此介面。</target>
        <note />
      </trans-unit>
      <trans-unit id="CodeActionNeedsEquivalenceKeyDescription">
        <source>A CodeFixProvider that intends to support fix all occurrences must classify the registered code actions into equivalence classes by assigning it an explicit, non-null equivalence key which is unique for each kind of code action created by this fixer. This enables the FixAllProvider to fix all diagnostics in the required scope by applying code actions from this fixer that are in the equivalence class of the trigger code action.</source>
        <target state="translated">CodeFixProvider 若想支援修正所有出現之處，必須將註冊的程式碼動作分類為相等類別，方法是為其指派明確且非 Null 的相等索引鍵，而其在此修正程式建立的每一種程式碼動作之間皆不重複。如此可讓 FixAllProvider 能藉由套用來自此修正程式中位於觸發程式碼動作之相等類別內的程式碼動作，來修正所需範圍內的所有診斷。</target>
        <note />
      </trans-unit>
      <trans-unit id="CreateCodeActionWithEquivalenceKeyMessage">
        <source>Provide an explicit argument for optional parameter '{0}', which is non-null and unique for each kind of code action created by this fixer.</source>
        <target state="translated">為選擇性參數 '{0}' 提供非 Null 的明確引數，而其在此修正程式所建立的每一種程式碼間皆不重複。</target>
        <note />
      </trans-unit>
      <trans-unit id="CreateCodeActionWithEquivalenceKeyTitle">
        <source>Create code actions should have a unique EquivalenceKey for FixAll occurrences support.</source>
        <target state="translated">建立的程式碼動作應要有唯一的 EquivalenceKey ，才可支援修正所有出現之處。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideCodeActionEquivalenceKeyMessage">
        <source>'{0}' has the default value of 'null' for property '{1}'. Either override this property on '{0}' to return a non-null and unique value across all code actions per-fixer or use such an existing code action.</source>
        <target state="translated">'{0}' 的屬性 '{1}' 為預設值 'null'。請在 '{0}' 上覆寫此屬性，以傳回在每個修正程式的所有程式碼動作之間唯一的非 Null 值，或使用這類現有的程式碼動作。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideCodeActionEquivalenceKeyTitle">
        <source>Use code actions that have a unique EquivalenceKey for FixAll occurrences support.</source>
        <target state="translated">使用具有唯一的 EquivalenceKey 之程式碼動作，支援修正所有出現之處。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreReturnValueOnImmutableObjectMethodInvocationDescription">
        <source>Many objects exposed by Roslyn are immutable. The return value from a method invocation on these objects should not be ignored.</source>
        <target state="translated">Roslyn 所公開的許多物件皆不可變。請勿略過來自這些物件上，方法引動過程的傳回值。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreReturnValueOnImmutableObjectMethodInvocationMessage">
        <source>'{0}' is immutable and '{1}' will not have any effect on it. Consider using the return value from '{1}'.</source>
        <target state="translated">'{0}' 不可變動，所以 '{1}' 對它沒有任何作用。請考慮使用來自 '{1}' 的傳回值。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreReturnValueOnImmutableObjectMethodInvocationTitle">
        <source>Do not ignore values returned by methods on immutable objects.</source>
        <target state="translated">請勿略過不可變物件上方法所傳回的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideGetFixAllProviderTitle">
        <source>Code fix providers should provide FixAll support.</source>
        <target state="translated">程式碼修正提供者應提供 FixAll 支援。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideGetFixAllProviderMessage">
        <source>'{0}' registers one or more code fixes, but does not override the method 'CodeFixProvider.GetFixAllProvider'. Override this method and provide a non-null FixAllProvider for FixAll support, potentially 'WellKnownFixAllProviders.BatchFixer', or 'null' to explicitly disable FixAll support.</source>
        <target state="translated">'{0}' 註冊了一個或多個程式碼修正，卻沒有覆寫 'CodeFixProvider.GetFixAllProvider' 方法。請覆寫此方法並提供 FixAll 支援、也許是 'WellKnownFixAllProviders.BatchFixer'，或是已明確停用 'null' 的非 null FixAllProvider。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideGetFixAllProviderDescription">
        <source>A CodeFixProvider should provide FixAll support to enable users to fix multiple instances of the underlying diagnostic with a single code fix. See documenation at https://github.com/dotnet/roslyn/blob/master/docs/analyzers/FixAllProvider.md for further details.</source>
        <target state="translated">CodeFixProvider 應提供 FixAll 支援，讓使用者能以單一程式碼修正來修正基礎診斷的多個執行個體。如需進一步的詳細資料，請參閱文件，位置在 https://github.com/dotnet/roslyn/blob/master/docs/analyzers/FixAllProvider.md。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideGetFixAllProviderCodeFixTitle">
        <source>Override GetFixAllProvider.</source>
        <target state="translated">覆寫 GetFixAllProvider。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideHelpUriInDescriptorMessage">
        <source>Consider providing a non-null 'helpLinkUri' to diagnostic descriptor constructor to show information when this diagnostic appears in the error list.</source>
        <target state="translated">請考慮提供非 null 的 'helpLinkUri' 到診斷描述項建構函式，使錯誤清單出現此診斷時顯示資訊。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideHelpUriInDescriptorTitle">
        <source>Provide non-null 'helpLinkUri' value to diagnostic descriptor constructor.</source>
        <target state="translated">請提供非 null 的 'helpLinkUri' 值到診斷描述項建構函式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideHelpUriInDescriptorDescription">
        <source>The 'helpLinkUri' value is used to show information when this diagnostic in the error list. Every analyzer should have a helpLinkUri specified which points to a help page that does not change over time.</source>
        <target state="translated">'helpLinkUri' 值可在錯誤清單中出現此診斷時用於顯示資訊。每個分析器都應指定指向說明頁面的 helpLinkUri，其不會隨時間變更。</target>
        <note />
      </trans-unit>
      <trans-unit id="DiagnosticIdMustBeInSpecifiedFormatTitle">
        <source>DiagnosticId for analyzers must be in specified format.</source>
        <target state="translated">分析器的診斷識別碼必須為指定格式。</target>
        <note />
      </trans-unit>
      <trans-unit id="DiagnosticIdMustBeInSpecifiedFormatMessage">
        <source>Diagnostic Id '{0}' belonging to category '{1}' is not in the required range and/or format '{2}' specified in the file '{3}'.</source>
        <target state="translated">屬於類別 '{1}' 的診斷識別碼 '{0}' 不在必要範圍內，而且/或不是檔案 '{3}' 中所指定的格式 '{2}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="DiagnosticIdMustBeInSpecifiedFormatDescription">
        <source>DiagnosticId for analyzers must be in specified format.</source>
        <target state="translated">分析器的診斷識別碼必須為指定格式。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseUniqueDiagnosticIdTitle">
        <source>DiagnosticId must be unique across analyzers.</source>
        <target state="translated">分析器的診斷識別碼必須是唯一的。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseUniqueDiagnosticIdMessage">
        <source>Diagnostic Id '{0}' is already used by analyzer '{1}'. Please use a different diagnostic ID.</source>
        <target state="translated">分析器 '{1}' 已使用診斷識別碼 '{0}'。請使用其他診斷識別碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseUniqueDiagnosticIdDescription">
        <source>DiagnosticId must be unique across analyzers.</source>
        <target state="translated">分析器的診斷識別碼必須是唯一的。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCategoriesFromSpecifiedRangeTitle">
        <source>Category for analyzers must be from the specified values.</source>
        <target state="translated">分析器的類別必須來自指定的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCategoriesFromSpecifiedRangeMessage">
        <source>Category '{0}' is not from the allowed categories specified in the file '{1}'.</source>
        <target state="translated">類別 '{0}' 並不是來自檔案 '{1}' 中指定的允許類別。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseCategoriesFromSpecifiedRangeDescription">
        <source>Category for analyzers must be from the specified values.</source>
        <target state="translated">分析器的類別必須來自指定的值。</target>
        <note />
      </trans-unit>
      <trans-unit id="AnalyzerCategoryAndIdRangeFileInvalidTitle">
        <source>Invalid entry in analyzer category and diagnostic ID range specification file.</source>
        <target state="translated">分析器類別中的項目與診斷識別碼規格檔案無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="AnalyzerCategoryAndIdRangeFileInvalidMessage">
        <source>Invalid entry '{0}' in analyzer category and diagnostic ID range specification file '{1}'.</source>
        <target state="translated">分析器類別中的項目 '{0}' 與診斷識別碼規格檔案 '{1}' 無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="AnalyzerCategoryAndIdRangeFileInvalidDescription">
        <source>Invalid entry in analyzer category and diagnostic ID range specification file.</source>
        <target state="translated">分析器類別中的項目與診斷識別碼規格檔案無效。</target>
        <note />
      </trans-unit>
      <trans-unit id="DiagnosticIdMustBeAConstantTitle">
        <source>DiagnosticId for analyzers must be a non-null constant.</source>
        <target state="translated">分析器的診斷識別碼必須是非 null 之常數。</target>
        <note />
      </trans-unit>
      <trans-unit id="DiagnosticIdMustBeAConstantMessage">
        <source>Diagnostic Id for rule '{0}' must be a non-null constant.</source>
        <target state="translated">規則 '{0}' 的診斷識別碼必須是非 null 之常數。</target>
        <note />
      </trans-unit>
      <trans-unit id="DiagnosticIdMustBeAConstantDescription">
        <source>DiagnosticId for analyzers must be a non-null constant.</source>
        <target state="translated">分析器的診斷識別碼必須是非 null 之常數。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseTypesFromAssemblyRuleDescription">
        <source>Diagnostic analyzer types should not use types from Workspaces assemblies. Workspaces assemblies are only available when the analyzer executes in Visual Studio IDE live analysis, but are not available during command line build. Referencing types from Workspaces assemblies will lead to runtime exception during analyzer execution in command line build.</source>
        <target state="translated">診斷分析器類型不應使用來自工作區組件的類型。工作區組件僅在分析器於 Visual Studio IDE 即時分析中執行時可用，而在命令列建置期間不可用。當分析器在命令列建置期間執行時，參考來自工作區組件的類型會導致執行階段例外狀況。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseTypesFromAssemblyRuleTitle">
        <source>Do not use types from Workspaces assembly in an analyzer</source>
        <target state="translated">不要使用分析器中來自工作區組件的類型</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseTypesFromAssemblyRuleIndirectMessage">
        <source>Change diagnostic analyzer type '{0}' to remove all direct and/or indirect accesses to type(s) '{1}', which access type(s) '{2}'</source>
        <target state="translated">變更診斷分析器類型 '{0}' 會移除存取類型 '{2}' 之類型 '{1}' 的所有直接及 (或) 間接存取</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseTypesFromAssemblyRuleDirectMessage">
        <source>Change diagnostic analyzer type '{0}' to remove all direct accesses to type(s) '{1}'</source>
        <target state="translated">變更診斷分析器類型 '{0}' 可移除類型 '{1}' 的所有直接存取</target>
        <note />
      </trans-unit>
      <trans-unit id="UpgradeMSBuildWorkspaceDescription">
        <source>MSBuildWorkspace has moved to the Microsoft.CodeAnalysis.Workspaces.MSBuild NuGet package and there are breaking API changes.</source>
        <target state="translated">MSBuildWorkspace 已移至 Microsoft.CodeAnalysis.Workspaces.MSBuild NuGet 套件，且目前有最新的 API 變更。</target>
        <note />
      </trans-unit>
      <trans-unit id="UpgradeMSBuildWorkspaceMessage">
        <source>Please upgrade MSBuildWorkspace by adding a package reference to the Microsoft.CodeAnalysis.Workspaces.MSBuild NuGet package. See https://go.microsoft.com/fwlink/?linkid=874285 for details on using MSBuildWorkspace successfully.</source>
        <target state="translated">請將套件參考新增至 Microsoft.CodeAnalysis.Workspaces.MSBuild NuGet 套件，來升級 MSBuildWorkspace。如需成功使用 MSBuildWorkspace 的詳細資料，請參閱 https://docs.microsoft.com/zh-tw/dotnet/csharp/roslyn-sdk/。</target>
        <note />
      </trans-unit>
      <trans-unit id="UpgradeMSBuildWorkspaceTitle">
        <source>Upgrade MSBuildWorkspace</source>
        <target state="translated">升級 MSBuildWorkspace</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
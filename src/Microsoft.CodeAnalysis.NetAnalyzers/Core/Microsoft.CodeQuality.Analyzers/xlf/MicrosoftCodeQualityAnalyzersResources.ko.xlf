<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ko" original="../MicrosoftCodeQualityAnalyzersResources.resx">
    <body>
      <trans-unit id="AbstractTypesShouldNotHaveConstructorsDescription">
        <source>Constructors on abstract types can be called only by derived types. Because public constructors create instances of a type, and you cannot create instances of an abstract type, an abstract type that has a public constructor is incorrectly designed.</source>
        <target state="new">Constructors on abstract types can be called only by derived types. Because public constructors create instances of a type, and you cannot create instances of an abstract type, an abstract type that has a public constructor is incorrectly designed.</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypesShouldNotHaveConstructorsMessage">
        <source>Abstract type {0} should not have constructors</source>
        <target state="new">Abstract type {0} should not have constructors</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypesShouldNotHaveConstructorsTitle">
        <source>Abstract types should not have constructors</source>
        <target state="new">Abstract types should not have constructors</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypesShouldNotHavePublicConstructorsCodeFix">
        <source>Change the accessibility of public constructors to protected.</source>
        <target state="new">Change the accessibility of public constructors to protected.</target>
        <note />
      </trans-unit>
      <trans-unit id="AddAssemblyLevelComVisibleFalse">
        <source>Because {0} exposes externally visible types, mark it with ComVisible(false) at the assembly level and then mark all types within the assembly that should be exposed to COM clients with ComVisible(true).</source>
        <target state="new">Because {0} exposes externally visible types, mark it with ComVisible(false) at the assembly level and then mark all types within the assembly that should be exposed to COM clients with ComVisible(true).</target>
        <note />
      </trans-unit>
      <trans-unit id="AppendConfigureAwaitFalse">
        <source>Append .ConfigureAwait(false)</source>
        <target state="new">Append .ConfigureAwait(false)</target>
        <note />
      </trans-unit>
      <trans-unit id="AppendConfigureAwaitTrue">
        <source>Append .ConfigureAwait(true)</source>
        <target state="new">Append .ConfigureAwait(true)</target>
        <note />
      </trans-unit>
      <trans-unit id="AssembliesShouldHaveValidStrongNamesDescription">
        <source>The strong name protects clients from unknowingly loading an assembly that has been tampered with. Assemblies without strong names should not be deployed outside very limited scenarios. If you share or distribute assemblies that are not correctly signed, the assembly can be tampered with, the common language runtime might not load the assembly, or the user might have to disable verification on his or her computer.</source>
        <target state="new">The strong name protects clients from unknowingly loading an assembly that has been tampered with. Assemblies without strong names should not be deployed outside very limited scenarios. If you share or distribute assemblies that are not correctly signed, the assembly can be tampered with, the common language runtime might not load the assembly, or the user might have to disable verification on his or her computer.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssembliesShouldHaveValidStrongNamesMessageNoStrongName">
        <source>Sign {0} with a strong name key.</source>
        <target state="new">Sign {0} with a strong name key.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssembliesShouldHaveValidStrongNamesMessageNotValid">
        <source>Verify that {0} has a valid strong name before deploying.</source>
        <target state="new">Verify that {0} has a valid strong name before deploying.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssembliesShouldHaveValidStrongNamesTitle">
        <source>Assemblies should have valid strong names</source>
        <target state="new">Assemblies should have valid strong names</target>
        <note />
      </trans-unit>
      <trans-unit id="AssigningSymbolAndItsMemberInSameStatementDescription">
        <source>Assigning to a symbol and its member (field/property) in the same statement is not recommended. It is not clear if the member access was intended to use symbol's old value prior to the assignment or new value from the assignment in this statement. For clarity, consider splitting the assignments into separate statements.</source>
        <target state="new">Assigning to a symbol and its member (field/property) in the same statement is not recommended. It is not clear if the member access was intended to use symbol's old value prior to the assignment or new value from the assignment in this statement. For clarity, consider splitting the assignments into separate statements.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssigningSymbolAndItsMemberInSameStatementMessage">
        <source>Symbol '{0}' and its member '{1}' are both assigned in the same statement. You are at risk of assigning the member of an unintended object.</source>
        <target state="new">Symbol '{0}' and its member '{1}' are both assigned in the same statement. You are at risk of assigning the member of an unintended object.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssigningSymbolAndItsMemberInSameStatementTitle">
        <source>Assigning symbol and its member in the same statement.</source>
        <target state="new">Assigning symbol and its member in the same statement.</target>
        <note />
      </trans-unit>
      <trans-unit id="AsyncMethodNamesShouldEndInAsyncDescription">
        <source>#N/A</source>
        <target state="new">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="AsyncMethodNamesShouldEndInAsyncMessage">
        <source>Async Method Names Should End in Async</source>
        <target state="new">Async Method Names Should End in Async</target>
        <note />
      </trans-unit>
      <trans-unit id="AsyncMethodNamesShouldEndInAsyncTitle">
        <source>Async Method Names Should End in Async</source>
        <target state="new">Async Method Names Should End in Async</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidAsyncVoidDescription">
        <source>#N/A</source>
        <target state="new">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidAsyncVoidMessage">
        <source>Avoid Async Void</source>
        <target state="new">Avoid Async Void</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidAsyncVoidTitle">
        <source>Avoid Async Void</source>
        <target state="new">Avoid Async Void</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsDescription">
        <source>A member calls a potentially dangerous or problematic method.</source>
        <target state="new">A member calls a potentially dangerous or problematic method.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageCoInitializeSecurity">
        <source>{0} is a P/Invoke declaration to an OLE32 API that cannot be reliably called after the runtime has been initialized. The workaround is to write an unmanaged shim that will call the routine and then activate and call into managed code. You can do this using an export from a mixed-mode C++ DLL, by registering a managed component for use by COM, or by using the runtime hosting API.</source>
        <target state="new">{0} is a P/Invoke declaration to an OLE32 API that cannot be reliably called after the runtime has been initialized. The workaround is to write an unmanaged shim that will call the routine and then activate and call into managed code. You can do this using an export from a mixed-mode C++ DLL, by registering a managed component for use by COM, or by using the runtime hosting API.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageCoSetProxyBlanket">
        <source>{0} is a P/Invoke declaration to an OLE32 API that cannot be reliably called against a runtime callable wrapper (a managed object wrapping a COM object). Runtime callable wrappers dynamically fetch interface pointers so the effect of the call might be arbitrarily lost. Runtime callable wrappers for a given COM object are also shared across an application domain so the call could possibly affect other users. Replace this call with a native wrapper COM object for the interface pointer that does the appropriate CoSetProxyBlanket calls.</source>
        <target state="new">{0} is a P/Invoke declaration to an OLE32 API that cannot be reliably called against a runtime callable wrapper (a managed object wrapping a COM object). Runtime callable wrappers dynamically fetch interface pointers so the effect of the call might be arbitrarily lost. Runtime callable wrappers for a given COM object are also shared across an application domain so the call could possibly affect other users. Replace this call with a native wrapper COM object for the interface pointer that does the appropriate CoSetProxyBlanket calls.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemGCCollect">
        <source>Remove the call to GC.Collect from {0}. It is usually unnecessary to force garbage collection, and doing so can severely degrade performance.</source>
        <target state="new">Remove the call to GC.Collect from {0}. It is usually unnecessary to force garbage collection, and doing so can severely degrade performance.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemReflectionAssemblyLoadFile">
        <source>Remove the call to Assembly.LoadFile from {0}.</source>
        <target state="new">Remove the call to Assembly.LoadFile from {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemReflectionAssemblyLoadFrom">
        <source>Remove the call to Assembly.LoadFrom from {0}.</source>
        <target state="new">Remove the call to Assembly.LoadFrom from {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemReflectionAssemblyLoadWithPartialName">
        <source>Remove the call to Assembly.LoadWithPartialName from {0}.</source>
        <target state="new">Remove the call to Assembly.LoadWithPartialName from {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemRuntimeInteropServicesSafeHandleDangerousGetHandle">
        <source>Remove the call to SafeHandle.DangerousGetHandle from {0}.</source>
        <target state="new">Remove the call to SafeHandle.DangerousGetHandle from {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemThreadingThreadResume">
        <source>Remove the call to Thread.Resume from {0}. Suspending and resuming threads can be dangerous if the system is in the middle of a critical operation such as executing a class constructor of an important system type or resolving security for a shared assembly.</source>
        <target state="new">Remove the call to Thread.Resume from {0}. Suspending and resuming threads can be dangerous if the system is in the middle of a critical operation such as executing a class constructor of an important system type or resolving security for a shared assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemThreadingThreadSuspend">
        <source>Remove the call to Thread.Suspend from {0}. Suspending and resuming threads can be dangerous if the system is in the middle of a critical operation such as executing a class constructor of an important system type or resolving security for a shared assembly.</source>
        <target state="new">Remove the call to Thread.Suspend from {0}. Suspending and resuming threads can be dangerous if the system is in the middle of a critical operation such as executing a class constructor of an important system type or resolving security for a shared assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemTypeInvokeMember">
        <source>Remove the call to System.Type.InvokeMember with BindingFlags.NonPublic from {0}. Taking a dependency on a private member increases the chance of a breaking change in the future.</source>
        <target state="new">Remove the call to System.Type.InvokeMember with BindingFlags.NonPublic from {0}. Taking a dependency on a private member increases the chance of a breaking change in the future.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsTitle">
        <source>Avoid calling problematic methods</source>
        <target state="new">Avoid calling problematic methods</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDeadConditionalCodeAlwaysTruFalseOrNullMessage">
        <source>'{0}' is always '{1}'. Remove or refactor the condition(s) to avoid dead code.</source>
        <target state="new">'{0}' is always '{1}'. Remove or refactor the condition(s) to avoid dead code.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDeadConditionalCodeNeverNullMessage">
        <source>'{0}' is never '{1}'. Remove or refactor the condition(s) to avoid dead code.</source>
        <target state="new">'{0}' is never '{1}'. Remove or refactor the condition(s) to avoid dead code.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDeadConditionalCodeTitle">
        <source>Avoid dead conditional code</source>
        <target state="new">Avoid dead conditional code</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationDescription">
        <source>Indexed elements in objects initializers must initialize unique elements. A duplicate index might overwrite a previous element initialization.</source>
        <target state="new">Indexed elements in objects initializers must initialize unique elements. A duplicate index might overwrite a previous element initialization.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationMessage">
        <source>The element at index [{0}] has already been initialized. Previous initializations of this element may be overwritten.</source>
        <target state="new">The element at index [{0}] has already been initialized. Previous initializations of this element may be overwritten.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationTitle">
        <source>Do not duplicate indexed element initializations</source>
        <target state="new">Do not duplicate indexed element initializations</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidEmptyInterfacesDescription">
        <source>Interfaces define members that provide a behavior or usage contract. The functionality that is described by the interface can be adopted by any type, regardless of where the type appears in the inheritance hierarchy. A type implements an interface by providing implementations for the members of the interface. An empty interface does not define any members; therefore, it does not define a contract that can be implemented.</source>
        <target state="new">Interfaces define members that provide a behavior or usage contract. The functionality that is described by the interface can be adopted by any type, regardless of where the type appears in the inheritance hierarchy. A type implements an interface by providing implementations for the members of the interface. An empty interface does not define any members; therefore, it does not define a contract that can be implemented.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidEmptyInterfacesMessage">
        <source>Avoid empty interfaces</source>
        <target state="new">Avoid empty interfaces</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidEmptyInterfacesTitle">
        <source>Avoid empty interfaces</source>
        <target state="new">Avoid empty interfaces</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingDescription">
        <source>This rule measures class coupling by counting the number of unique type references that a symbol contains. Symbols that have a high degree of class coupling can be difficult to maintain. It is a good practice to have types and methods that exhibit low coupling and high cohesion. To fix this violation, try to redesign the code to reduce the number of types to which it is coupled.</source>
        <target state="new">This rule measures class coupling by counting the number of unique type references that a symbol contains. Symbols that have a high degree of class coupling can be difficult to maintain. It is a good practice to have types and methods that exhibit low coupling and high cohesion. To fix this violation, try to redesign the code to reduce the number of types to which it is coupled.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingMessage">
        <source>'{0}' is coupled with '{1}' different types from '{2}' different namespaces. Rewrite or refactor the code to decrease its class coupling below '{3}'.</source>
        <target state="new">'{0}' is coupled with '{1}' different types from '{2}' different namespaces. Rewrite or refactor the code to decrease its class coupling below '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingTitle">
        <source>Avoid excessive class coupling</source>
        <target state="new">Avoid excessive class coupling</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityDescription">
        <source>Cyclomatic complexity measures the number of linearly independent paths through the method, which is determined by the number and complexity of conditional branches. A low cyclomatic complexity generally indicates a method that is easy to understand, test, and maintain. The cyclomatic complexity is calculated from a control flow graph of the method and is given as follows: `cyclomatic complexity = the number of edges - the number of nodes + 1`, where a node represents a logic branch point and an edge represents a line between nodes.</source>
        <target state="new">Cyclomatic complexity measures the number of linearly independent paths through the method, which is determined by the number and complexity of conditional branches. A low cyclomatic complexity generally indicates a method that is easy to understand, test, and maintain. The cyclomatic complexity is calculated from a control flow graph of the method and is given as follows: `cyclomatic complexity = the number of edges - the number of nodes + 1`, where a node represents a logic branch point and an edge represents a line between nodes.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityMessage">
        <source>'{0}' has a cyclomatic complexity of '{1}'. Rewrite or refactor the code to decrease its complexity below '{2}'.</source>
        <target state="new">'{0}' has a cyclomatic complexity of '{1}'. Rewrite or refactor the code to decrease its complexity below '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityTitle">
        <source>Avoid excessive complexity</source>
        <target state="new">Avoid excessive complexity</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceDescription">
        <source>Deeply nested type hierarchies can be difficult to follow, understand, and maintain. This rule limits analysis to hierarchies in the same module. To fix a violation of this rule, derive the type from a base type that is less deep in the inheritance hierarchy or eliminate some of the intermediate base types.</source>
        <target state="new">Deeply nested type hierarchies can be difficult to follow, understand, and maintain. This rule limits analysis to hierarchies in the same module. To fix a violation of this rule, derive the type from a base type that is less deep in the inheritance hierarchy or eliminate some of the intermediate base types.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceMessage">
        <source>'{0}' has an object hierarchy '{1}' levels deep within the defining module. If possible, eliminate base classes within the hierarchy to decrease its hierarchy level below '{2}': '{3}'</source>
        <target state="new">'{0}' has an object hierarchy '{1}' levels deep within the defining module. If possible, eliminate base classes within the hierarchy to decrease its hierarchy level below '{2}': '{3}'</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceTitle">
        <source>Avoid excessive inheritance</source>
        <target state="new">Avoid excessive inheritance</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidPropertySelfAssignmentMessage">
        <source>The property {0} should not be assigned to itself.</source>
        <target state="new">The property {0} should not be assigned to itself.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidPropertySelfAssignmentTitle">
        <source>Do not assign a property to itself.</source>
        <target state="new">Do not assign a property to itself.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesDescription">
        <source>An instance of an assembly-level type is not created by code in the assembly.</source>
        <target state="new">An instance of an assembly-level type is not created by code in the assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesMessage">
        <source>{0} is an internal class that is apparently never instantiated. If so, remove the code from the assembly. If this class is intended to contain only static members, make it static (Shared in Visual Basic).</source>
        <target state="new">{0} is an internal class that is apparently never instantiated. If so, remove the code from the assembly. If this class is intended to contain only static members, make it static (Shared in Visual Basic).</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesTitle">
        <source>Avoid uninstantiated internal classes</source>
        <target state="new">Avoid uninstantiated internal classes</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeDescription">
        <source>The maintainability index is calculated by using the following metrics: lines of code, program volume, and cyclomatic complexity. Program volume is a measure of the difficulty of understanding of a symbol that is based on the number of operators and operands in the code. Cyclomatic complexity is a measure of the structural complexity of the type or method. A low maintainability index indicates that code is probably difficult to maintain and would be a good candidate to redesign.</source>
        <target state="new">The maintainability index is calculated by using the following metrics: lines of code, program volume, and cyclomatic complexity. Program volume is a measure of the difficulty of understanding of a symbol that is based on the number of operators and operands in the code. Cyclomatic complexity is a measure of the structural complexity of the type or method. A low maintainability index indicates that code is probably difficult to maintain and would be a good candidate to redesign.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeMessage">
        <source>'{0}' has a maintainability index of '{1}'. Rewrite or refactor the code to increase its maintainability index (MI) above '{2}'.</source>
        <target state="new">'{0}' has a maintainability index of '{1}'. Rewrite or refactor the code to increase its maintainability index (MI) above '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeTitle">
        <source>Avoid unmaintainable code</source>
        <target state="new">Avoid unmaintainable code</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsDescription">
        <source>Private fields were detected that do not appear to be accessed in the assembly.</source>
        <target state="new">Private fields were detected that do not appear to be accessed in the assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsMessage">
        <source>Unused field '{0}'.</source>
        <target state="new">Unused field '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsTitle">
        <source>Avoid unused private fields</source>
        <target state="new">Avoid unused private fields</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUsingCrefTagsWithAPrefixDescription">
        <source>Use of cref tags with prefixes should be avoided, since it prevents the compiler from verifying references and the IDE from updating references during refactorings. It is permissible to suppress this error at a single documentation site if the cref must use a prefix because the type being mentioned is not findable by the compiler. For example, if a cref is mentioning a special attribute in the full framework but you're in a file that compiles against the portable framework, or if you want to reference a type at higher layer of Roslyn, you should suppress the error. You should not suppress the error just because you want to take a shortcut and avoid using the full syntax.</source>
        <target state="new">Use of cref tags with prefixes should be avoided, since it prevents the compiler from verifying references and the IDE from updating references during refactorings. It is permissible to suppress this error at a single documentation site if the cref must use a prefix because the type being mentioned is not findable by the compiler. For example, if a cref is mentioning a special attribute in the full framework but you're in a file that compiles against the portable framework, or if you want to reference a type at higher layer of Roslyn, you should suppress the error. You should not suppress the error just because you want to take a shortcut and avoid using the full syntax.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUsingCrefTagsWithAPrefixMessage">
        <source>Avoid using cref tags with a prefix</source>
        <target state="new">Avoid using cref tags with a prefix</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUsingCrefTagsWithAPrefixTitle">
        <source>Avoid using cref tags with a prefix</source>
        <target state="new">Avoid using cref tags with a prefix</target>
        <note />
      </trans-unit>
      <trans-unit id="CancellationTokenParametersMustComeLastMessage">
        <source>Method '{0}' should take CancellationToken as the last parameter</source>
        <target state="new">Method '{0}' should take CancellationToken as the last parameter</target>
        <note />
      </trans-unit>
      <trans-unit id="CancellationTokenParametersMustComeLastTitle">
        <source>CancellationToken parameters must come last</source>
        <target state="new">CancellationToken parameters must come last</target>
        <note />
      </trans-unit>
      <trans-unit id="CategoryReliability">
        <source>Reliability</source>
        <target state="new">Reliability</target>
        <note />
      </trans-unit>
      <trans-unit id="ChangeAssemblyLevelComVisibleToFalse">
        <source>Consider changing the ComVisible attribute on {0} to false, and opting in at the type level.</source>
        <target state="new">Consider changing the ComVisible attribute on {0} to false, and opting in at the type level.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionPropertiesShouldBeReadOnlyDescription">
        <source>A writable collection property allows a user to replace the collection with a different collection. A read-only property stops the collection from being replaced but still allows the individual members to be set.</source>
        <target state="new">A writable collection property allows a user to replace the collection with a different collection. A read-only property stops the collection from being replaced but still allows the individual members to be set.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionPropertiesShouldBeReadOnlyMessage">
        <source>Change '{0}' to be read-only by removing the property setter.</source>
        <target state="new">Change '{0}' to be read-only by removing the property setter.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionPropertiesShouldBeReadOnlyTitle">
        <source>Collection properties should be read only</source>
        <target state="new">Collection properties should be read only</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionsShouldImplementGenericInterfaceDescription">
        <source>To broaden the usability of a collection, implement one of the generic collection interfaces. Then the collection can be used to populate generic collection types.</source>
        <target state="new">To broaden the usability of a collection, implement one of the generic collection interfaces. Then the collection can be used to populate generic collection types.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionsShouldImplementGenericInterfaceMessage">
        <source>Collection '{0}' directly or indirectly inherits '{1}' without implementing '{2}'. Publicly-visible collections should implement the generic version to broaden usability.</source>
        <target state="new">Collection '{0}' directly or indirectly inherits '{1}' without implementing '{2}'. Publicly-visible collections should implement the generic version to broaden usability.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionsShouldImplementGenericInterfaceTitle">
        <source>Collections should implement generic interface</source>
        <target state="new">Collections should implement generic interface</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstructorMakeNoninheritableBaseClassInheritableDescription">
        <source>When a base class is noninheritable because its constructor is internal, a derived class should not make it inheritable by having a public or protected constructor.</source>
        <target state="new">When a base class is noninheritable because its constructor is internal, a derived class should not make it inheritable by having a public or protected constructor.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstructorMakeNoninheritableBaseClassInheritableMessage">
        <source>Constructor make noninheritable base class inheritable</source>
        <target state="new">Constructor make noninheritable base class inheritable</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstructorMakeNoninheritableBaseClassInheritableTitle">
        <source>Constructor make noninheritable base class inheritable</source>
        <target state="new">Constructor make noninheritable base class inheritable</target>
        <note />
      </trans-unit>
      <trans-unit id="CreatePropertyAccessorForParameter">
        <source>Create a property accessor.</source>
        <target state="new">Create a property accessor.</target>
        <note />
      </trans-unit>
      <trans-unit id="DeclareTypesInNamespacesDescription">
        <source>Types are declared in namespaces to prevent name collisions and as a way to organize related types in an object hierarchy.</source>
        <target state="new">Types are declared in namespaces to prevent name collisions and as a way to organize related types in an object hierarchy.</target>
        <note />
      </trans-unit>
      <trans-unit id="DeclareTypesInNamespacesMessage">
        <source>Declare types in namespaces</source>
        <target state="new">Declare types in namespaces</target>
        <note />
      </trans-unit>
      <trans-unit id="DeclareTypesInNamespacesTitle">
        <source>Declare types in namespaces</source>
        <target state="new">Declare types in namespaces</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineAccessorsForAttributeArgumentsDescription">
        <source>Attributes can define mandatory arguments that must be specified when you apply the attribute to a target. These are also known as positional arguments because they are supplied to attribute constructors as positional parameters. For every mandatory argument, the attribute should also provide a corresponding read-only property so that the value of the argument can be retrieved at execution time. Attributes can also define optional arguments, which are also known as named arguments. These arguments are supplied to attribute constructors by name and should have a corresponding read/write property.</source>
        <target state="new">Attributes can define mandatory arguments that must be specified when you apply the attribute to a target. These are also known as positional arguments because they are supplied to attribute constructors as positional parameters. For every mandatory argument, the attribute should also provide a corresponding read-only property so that the value of the argument can be retrieved at execution time. Attributes can also define optional arguments, which are also known as named arguments. These arguments are supplied to attribute constructors by name and should have a corresponding read/write property.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineAccessorsForAttributeArgumentsMessageDefault">
        <source>Add a public read-only property accessor for positional argument {0} of Attribute {1}.</source>
        <target state="new">Add a public read-only property accessor for positional argument {0} of Attribute {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineAccessorsForAttributeArgumentsMessageIncreaseVisibility">
        <source>If {0} is the property accessor for positional argument {1}, make it public.</source>
        <target state="new">If {0} is the property accessor for positional argument {1}, make it public.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineAccessorsForAttributeArgumentsMessageRemoveSetter">
        <source>Remove the property setter from {0} or reduce its accessibility because it corresponds to positional argument {1}.</source>
        <target state="new">Remove the property setter from {0} or reduce its accessibility because it corresponds to positional argument {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineAccessorsForAttributeArgumentsTitle">
        <source>Define accessors for attribute arguments</source>
        <target state="new">Define accessors for attribute arguments</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructors">
        <source>Do not call overridable methods in constructors</source>
        <target state="new">Do not call overridable methods in constructors</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructorsDescription">
        <source>Virtual methods defined on the class should not be called from constructors. If a derived class has overridden the method, the derived class version will be called (before the derived class constructor is called).</source>
        <target state="new">Virtual methods defined on the class should not be called from constructors. If a derived class has overridden the method, the derived class version will be called (before the derived class constructor is called).</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchGeneralExceptionTypesDescription">
        <source>A general exception such as System.Exception or System.SystemException or a disallowed exception type is caught in a catch statement, or a general catch clause is used. General and disallowed exceptions should not be caught.</source>
        <target state="new">A general exception such as System.Exception or System.SystemException or a disallowed exception type is caught in a catch statement, or a general catch clause is used. General and disallowed exceptions should not be caught.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchGeneralExceptionTypesMessage">
        <source>Modify '{0}' to catch a more specific allowed exception type, or rethrow the exception.</source>
        <target state="new">Modify '{0}' to catch a more specific allowed exception type, or rethrow the exception.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchGeneralExceptionTypesTitle">
        <source>Do not catch general exception types</source>
        <target state="new">Do not catch general exception types</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareStaticMembersOnGenericTypesDescription">
        <source>When a static member of a generic type is called, the type argument must be specified for the type. When a generic instance member that does not support inference is called, the type argument must be specified for the member. In these two cases, the syntax for specifying the type argument is different and easily confused.</source>
        <target state="new">When a static member of a generic type is called, the type argument must be specified for the type. When a generic instance member that does not support inference is called, the type argument must be specified for the member. In these two cases, the syntax for specifying the type argument is different and easily confused.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareStaticMembersOnGenericTypesMessage">
        <source>Do not declare static members on generic types</source>
        <target state="new">Do not declare static members on generic types</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareStaticMembersOnGenericTypesTitle">
        <source>Do not declare static members on generic types</source>
        <target state="new">Do not declare static members on generic types</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareVisibleInstanceFieldsDescription">
        <source>The primary use of a field should be as an implementation detail. Fields should be private or internal and should be exposed by using properties.</source>
        <target state="new">The primary use of a field should be as an implementation detail. Fields should be private or internal and should be exposed by using properties.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareVisibleInstanceFieldsMessage">
        <source>Do not declare visible instance fields</source>
        <target state="new">Do not declare visible instance fields</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareVisibleInstanceFieldsTitle">
        <source>Do not declare visible instance fields</source>
        <target state="new">Do not declare visible instance fields</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDirectlyAwaitATaskDescription">
        <source>When an asynchronous method awaits a Task directly, continuation occurs in the same thread that created the task. Consider calling Task.ConfigureAwait(Boolean) to signal your intention for continuation. Call ConfigureAwait(false) on the task to schedule continuations to the thread pool, thereby avoiding a deadlock on the UI thread. Passing false is a good option for app-independent libraries. Calling ConfigureAwait(true) on the task has the same behavior as not explicitly calling ConfigureAwait. By explicitly calling this method, you're letting readers know you intentionally want to perform the continuation on the original synchronization context.</source>
        <target state="new">When an asynchronous method awaits a Task directly, continuation occurs in the same thread that created the task. Consider calling Task.ConfigureAwait(Boolean) to signal your intention for continuation. Call ConfigureAwait(false) on the task to schedule continuations to the thread pool, thereby avoiding a deadlock on the UI thread. Passing false is a good option for app-independent libraries. Calling ConfigureAwait(true) on the task has the same behavior as not explicitly calling ConfigureAwait. By explicitly calling this method, you're letting readers know you intentionally want to perform the continuation on the original synchronization context.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDirectlyAwaitATaskMessage">
        <source>Consider calling ConfigureAwait on the awaited task</source>
        <target state="new">Consider calling ConfigureAwait on the awaited task</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDirectlyAwaitATaskTitle">
        <source>Consider calling ConfigureAwait on the awaited task</source>
        <target state="new">Consider calling ConfigureAwait on the awaited task</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHideBaseClassMethodsDescription">
        <source>A method in a base type is hidden by an identically named method in a derived type when the parameter signature of the derived method differs only by types that are more weakly derived than the corresponding types in the parameter signature of the base method.</source>
        <target state="new">A method in a base type is hidden by an identically named method in a derived type when the parameter signature of the derived method differs only by types that are more weakly derived than the corresponding types in the parameter signature of the base method.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHideBaseClassMethodsMessage">
        <source>Change or remove '{0}' because it hides a more specific base class method: '{1}'.</source>
        <target state="new">Change or remove '{0}' because it hides a more specific base class method: '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHideBaseClassMethodsTitle">
        <source>Do not hide base class methods</source>
        <target state="new">Do not hide base class methods</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsDescription">
        <source>A new object is created but never used; or a method that creates and returns a new string is called and the new string is never used; or a COM or P/Invoke method returns an HRESULT or error code that is never used.</source>
        <target state="new">A new object is created but never used; or a method that creates and returns a new string is called and the new string is never used; or a COM or P/Invoke method returns an HRESULT or error code that is never used.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageHResultOrErrorCode">
        <source>{0} calls {1} but does not use the HRESULT or error code that the method returns. This could lead to unexpected behavior in error conditions or low-resource situations. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</source>
        <target state="new">{0} calls {1} but does not use the HRESULT or error code that the method returns. This could lead to unexpected behavior in error conditions or low-resource situations. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageObjectCreation">
        <source>{0} creates a new instance of {1} which is never used. Pass the instance as an argument to another method, assign the instance to a variable, or remove the object creation if it is unnecessary.</source>
        <target state="new">{0} creates a new instance of {1} which is never used. Pass the instance as an argument to another method, assign the instance to a variable, or remove the object creation if it is unnecessary.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessagePureMethod">
        <source>{0} calls {1} but does not use the value the method returns. Because {1} is marked as a Pure method, it cannot have side effects. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</source>
        <target state="new">{0} calls {1} but does not use the value the method returns. Because {1} is marked as a Pure method, it cannot have side effects. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageStringCreation">
        <source>{0} calls {1} but does not use the new string instance that the method returns. Pass the instance as an argument to another method, assign the instance to a variable, or remove the call if it is unnecessary.</source>
        <target state="new">{0} calls {1} but does not use the new string instance that the method returns. Pass the instance as an argument to another method, assign the instance to a variable, or remove the call if it is unnecessary.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageTryParse">
        <source>{0} calls {1} but does not explicitly check whether the conversion succeeded. Either use the return value in a conditional statement or verify that the call site expects that the out argument will be set to the default value when the conversion fails.</source>
        <target state="new">{0} calls {1} but does not explicitly check whether the conversion succeeded. Either use the return value in a conditional statement or verify that the call site expects that the out argument will be set to the default value when the conversion fails.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsTitle">
        <source>Do not ignore method results</source>
        <target state="new">Do not ignore method results</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyDescription">
        <source>The common language runtime initializes all fields to their default values before running the constructor. In most cases, initializing a field to its default value in a constructor is redundant, which degrades performance and adds to maintenance costs. One case where it is not redundant occurs when the constructor calls another constructor of the same class or a base class constructor and that constructor initializes the field to a non-default value. In this case, changing the value of the field back to its default value can be appropriate.</source>
        <target state="new">The common language runtime initializes all fields to their default values before running the constructor. In most cases, initializing a field to its default value in a constructor is redundant, which degrades performance and adds to maintenance costs. One case where it is not redundant occurs when the constructor calls another constructor of the same class or a base class constructor and that constructor initializes the field to a non-default value. In this case, changing the value of the field back to its default value can be appropriate.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyMessage">
        <source>Do not initialize unnecessarily</source>
        <target state="new">Do not initialize unnecessarily</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyTitle">
        <source>Do not initialize unnecessarily</source>
        <target state="new">Do not initialize unnecessarily</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkEnumsWithFlagsCodeFix">
        <source>Remove FlagsAttribute from enum.</source>
        <target state="new">Remove FlagsAttribute from enum.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkEnumsWithFlagsDescription">
        <source>An externally visible enumeration is marked by using FlagsAttribute, and it has one or more values that are not powers of two or a combination of the other defined values on the enumeration.</source>
        <target state="new">An externally visible enumeration is marked by using FlagsAttribute, and it has one or more values that are not powers of two or a combination of the other defined values on the enumeration.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkEnumsWithFlagsMessage">
        <source>Do not mark enums with FlagsAttribute</source>
        <target state="new">Do not mark enums with FlagsAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkEnumsWithFlagsTitle">
        <source>Do not mark enums with FlagsAttribute</source>
        <target state="new">Do not mark enums with FlagsAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMixBlockingAndAsyncDescription">
        <source>#N/A</source>
        <target state="new">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMixBlockingAndAsyncMessage">
        <source>Don't Mix Blocking and Async</source>
        <target state="new">Don't Mix Blocking and Async</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMixBlockingAndAsyncTitle">
        <source>Don't Mix Blocking and Async</source>
        <target state="new">Don't Mix Blocking and Async</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassAsyncLambdasAsVoidReturningDelegateTypesDescription">
        <source>#N/A</source>
        <target state="new">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassAsyncLambdasAsVoidReturningDelegateTypesMessage">
        <source>Don't Pass Async Lambdas as Void Returning Delegate Types</source>
        <target state="new">Don't Pass Async Lambdas as Void Returning Delegate Types</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassAsyncLambdasAsVoidReturningDelegateTypesTitle">
        <source>Don't Pass Async Lambdas as Void Returning Delegate Types</source>
        <target state="new">Don't Pass Async Lambdas as Void Returning Delegate Types</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPrefixEnumValuesWithTypeNameDescription">
        <source>An enumeration's values should not start with the type name of the enumeration.</source>
        <target state="new">An enumeration's values should not start with the type name of the enumeration.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPrefixEnumValuesWithTypeNameMessage">
        <source>Do not prefix enum values with the name of the enum type '{0}'. </source>
        <target state="new">Do not prefix enum values with the name of the enum type '{0}'. </target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPrefixEnumValuesWithTypeNameTitle">
        <source>Do not prefix enum values with type name</source>
        <target state="new">Do not prefix enum values with type name</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesDescription">
        <source>When an exception is raised in a finally clause, the new exception hides the active exception. This makes the original error difficult to detect and debug.</source>
        <target state="new">When an exception is raised in a finally clause, the new exception hides the active exception. This makes the original error difficult to detect and debug.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesMessageFinally">
        <source>Do not raise an exception from within a finally clause. </source>
        <target state="new">Do not raise an exception from within a finally clause. </target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesTitle">
        <source>Do not raise exceptions in finally clauses</source>
        <target state="new">Do not raise exceptions in finally clauses</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsDescription">
        <source>A method that is not expected to throw exceptions throws an exception.</source>
        <target state="new">A method that is not expected to throw exceptions throws an exception.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsMessageHasAllowedExceptions">
        <source>{0} creates an exception of type {1}, an exception type that should not be raised in this type of method. If this exception instance might be raised, either use a different exception type or change this method's logic so that it no longer raises an exception.</source>
        <target state="new">{0} creates an exception of type {1}, an exception type that should not be raised in this type of method. If this exception instance might be raised, either use a different exception type or change this method's logic so that it no longer raises an exception.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsMessageNoAllowedExceptions">
        <source>{0} creates an exception of type {1}. Exceptions should not be raised in this type of method. If this exception instance might be raised, change this method's logic so it no longer raises an exception.</source>
        <target state="new">{0} creates an exception of type {1}. Exceptions should not be raised in this type of method. If this exception instance might be raised, change this method's logic so it no longer raises an exception.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsMessagePropertyGetter">
        <source>{0} creates an exception of type {1}, an exception type that should not be raised in a property. If this exception instance might be raised, use a different exception type, convert this property into a method, or change this property's logic so that it no longer raises an exception.</source>
        <target state="new">{0} creates an exception of type {1}, an exception type that should not be raised in a property. If this exception instance might be raised, use a different exception type, convert this property into a method, or change this property's logic so that it no longer raises an exception.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsTitle">
        <source>Do not raise exceptions in unexpected locations</source>
        <target state="new">Do not raise exceptions in unexpected locations</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStoreAsyncLambdasAsVoidReturningDelegateTypesDescription">
        <source>#N/A</source>
        <target state="new">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStoreAsyncLambdasAsVoidReturningDelegateTypesMessage">
        <source>Don't Store Async Lambdas as Void Returning Delegate Types</source>
        <target state="new">Don't Store Async Lambdas as Void Returning Delegate Types</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStoreAsyncLambdasAsVoidReturningDelegateTypesTitle">
        <source>Don't Store Async Lambdas as Void Returning Delegate Types</source>
        <target state="new">Don't Store Async Lambdas as Void Returning Delegate Types</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumStorageShouldBeInt32Description">
        <source>An enumeration is a value type that defines a set of related named constants. By default, the System.Int32 data type is used to store the constant value. Although you can change this underlying type, it is not required or recommended for most scenarios.</source>
        <target state="new">An enumeration is a value type that defines a set of related named constants. By default, the System.Int32 data type is used to store the constant value. Although you can change this underlying type, it is not required or recommended for most scenarios.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumStorageShouldBeInt32Message">
        <source>If possible, make the underlying type of {0} System.Int32 instead of {1}.</source>
        <target state="new">If possible, make the underlying type of {0} System.Int32 instead of {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumStorageShouldBeInt32Title">
        <source>Enum Storage should be Int32</source>
        <target state="new">Enum Storage should be Int32</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueDescription">
        <source>The default value of an uninitialized enumeration, just as other value types, is zero. A nonflags-attributed enumeration should define a member by using the value of zero so that the default value is a valid value of the enumeration. If an enumeration that has the FlagsAttribute attribute applied defines a zero-valued member, its name should be ""None"" to indicate that no values have been set in the enumeration.</source>
        <target state="new">The default value of an uninitialized enumeration, just as other value types, is zero. A nonflags-attributed enumeration should define a member by using the value of zero so that the default value is a valid value of the enumeration. If an enumeration that has the FlagsAttribute attribute applied defines a zero-valued member, its name should be ""None"" to indicate that no values have been set in the enumeration.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueMessageFlagsMultipleZeros">
        <source>Remove all members that have the value zero from {0} except for one member that is named 'None'.</source>
        <target state="new">Remove all members that have the value zero from {0} except for one member that is named 'None'.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueMessageFlagsRename">
        <source>In enum {0}, change the name of {1} to 'None'.</source>
        <target state="new">In enum {0}, change the name of {1} to 'None'.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueMessageNotFlagsNoZeroValue">
        <source>Add a member to {0} that has a value of zero with a suggested name of 'None'.</source>
        <target state="new">Add a member to {0} that has a value of zero with a suggested name of 'None'.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueTitle">
        <source>Enums should have zero value</source>
        <target state="new">Enums should have zero value</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldZeroValueFlagsMultipleZeroCodeFix">
        <source>Remove all members that have the value zero except for one member that is named 'None'.</source>
        <target state="new">Remove all members that have the value zero except for one member that is named 'None'.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldZeroValueFlagsRenameCodeFix">
        <source>Rename zero-valued enum field to 'None'.</source>
        <target state="new">Rename zero-valued enum field to 'None'.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldZeroValueNotFlagsNoZeroValueCodeFix">
        <source>Add a zero-valued member 'None' to enum.</source>
        <target state="new">Add a zero-valued member 'None' to enum.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionsShouldBePublicDescription">
        <source>An internal exception is visible only inside its own internal scope. After the exception falls outside the internal scope, only the base exception can be used to catch the exception. If the internal exception is inherited from T:System.Exception, T:System.SystemException, or T:System.ApplicationException, the external code will not have sufficient information to know what to do with the exception.</source>
        <target state="new">An internal exception is visible only inside its own internal scope. After the exception falls outside the internal scope, only the base exception can be used to catch the exception. If the internal exception is inherited from T:System.Exception, T:System.SystemException, or T:System.ApplicationException, the external code will not have sufficient information to know what to do with the exception.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionsShouldBePublicMessage">
        <source>Exceptions should be public</source>
        <target state="new">Exceptions should be public</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionsShouldBePublicTitle">
        <source>Exceptions should be public</source>
        <target state="new">Exceptions should be public</target>
        <note />
      </trans-unit>
      <trans-unit id="FlagsEnumsShouldHavePluralNamesDescription">
        <source>A public enumeration has the System.FlagsAttribute attribute, and its name does not end in ""s"". Types that are marked by using FlagsAttribute have names that are plural because the attribute indicates that more than one value can be specified.</source>
        <target state="new">A public enumeration has the System.FlagsAttribute attribute, and its name does not end in ""s"". Types that are marked by using FlagsAttribute have names that are plural because the attribute indicates that more than one value can be specified.</target>
        <note />
      </trans-unit>
      <trans-unit id="FlagsEnumsShouldHavePluralNamesMessage">
        <source>Flags enums should have plural names</source>
        <target state="new">Flags enums should have plural names</target>
        <note />
      </trans-unit>
      <trans-unit id="FlagsEnumsShouldHavePluralNamesTitle">
        <source>Flags enums should have plural names</source>
        <target state="new">Flags enums should have plural names</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_missing_operators">
        <source>Generate missing operators</source>
        <target state="new">Generate missing operators</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldDifferByMoreThanCaseDescription">
        <source>Identifiers for namespaces, types, members, and parameters cannot differ only by case because languages that target the common language runtime are not required to be case-sensitive.</source>
        <target state="new">Identifiers for namespaces, types, members, and parameters cannot differ only by case because languages that target the common language runtime are not required to be case-sensitive.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldDifferByMoreThanCaseMessage">
        <source>Names of '{0}' and '{1}' should differ by more than case.</source>
        <target state="new">Names of '{0}' and '{1}' should differ by more than case.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldDifferByMoreThanCaseTitle">
        <source>Identifiers should differ by more than case</source>
        <target state="new">Identifiers should differ by more than case</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectPrefixDescription">
        <source>The name of an externally visible interface does not start with an uppercase ""I"". The name of a generic type parameter on an externally visible type or method does not start with an uppercase ""T"".</source>
        <target state="new">The name of an externally visible interface does not start with an uppercase ""I"". The name of a generic type parameter on an externally visible type or method does not start with an uppercase ""T"".</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectPrefixMessageInterface">
        <source>Prefix interface name {0} with 'I'.</source>
        <target state="new">Prefix interface name {0} with 'I'.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectPrefixMessageTypeParameter">
        <source>Prefix generic type parameter name {0} with 'T'.</source>
        <target state="new">Prefix generic type parameter name {0} with 'T'.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectPrefixTitle">
        <source>Identifiers should have correct prefix</source>
        <target state="new">Identifiers should have correct prefix</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectSuffixDescription">
        <source>By convention, the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, have a suffix that is associated with the base type or interface.</source>
        <target state="new">By convention, the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, have a suffix that is associated with the base type or interface.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectSuffixMessageDefault">
        <source>Rename {0} to end in '{1}'.</source>
        <target state="new">Rename {0} to end in '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectSuffixMessageSpecialCollection">
        <source>Rename {0} to end in either 'Collection' or '{1}'.</source>
        <target state="new">Rename {0} to end in either 'Collection' or '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectSuffixTitle">
        <source>Identifiers should have correct suffix</source>
        <target state="new">Identifiers should have correct suffix</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainTypeNamesDescription">
        <source>Names of parameters and members are better used to communicate their meaning than to describe their type, which is expected to be provided by development tools. For names of members, if a data type name must be used, use a language-independent name instead of a language-specific one.</source>
        <target state="new">Names of parameters and members are better used to communicate their meaning than to describe their type, which is expected to be provided by development tools. For names of members, if a data type name must be used, use a language-independent name instead of a language-specific one.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainTypeNamesMessage">
        <source>Identifier '{0}' contains type name</source>
        <target state="new">Identifier '{0}' contains type name</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainTypeNamesTitle">
        <source>Identifier contains type name</source>
        <target state="new">Identifier contains type name</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresDescription">
        <source>By convention, identifier names do not contain the underscore (_) character. This rule checks namespaces, types, members, and parameters.</source>
        <target state="new">By convention, identifier names do not contain the underscore (_) character. This rule checks namespaces, types, members, and parameters.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageAssembly">
        <source>Remove the underscores from assembly name {0}.</source>
        <target state="new">Remove the underscores from assembly name {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageDelegateParameter">
        <source>In delegate {0}, remove the underscores from parameter name {1}.</source>
        <target state="new">In delegate {0}, remove the underscores from parameter name {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageMember">
        <source>Remove the underscores from member name {0}.</source>
        <target state="new">Remove the underscores from member name {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageMemberParameter">
        <source>In member {0}, remove the underscores from parameter name {1}.</source>
        <target state="new">In member {0}, remove the underscores from parameter name {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageMethodTypeParameter">
        <source>On method {0}, remove the underscores from generic type parameter name {1}.</source>
        <target state="new">On method {0}, remove the underscores from generic type parameter name {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageNamespace">
        <source>Remove the underscores from namespace name '{0}'.</source>
        <target state="new">Remove the underscores from namespace name '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageType">
        <source>Remove the underscores from type name {0}.</source>
        <target state="new">Remove the underscores from type name {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageTypeTypeParameter">
        <source>On type {0}, remove the underscores from generic type parameter name {1}.</source>
        <target state="new">On type {0}, remove the underscores from generic type parameter name {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresTitle">
        <source>Identifiers should not contain underscores</source>
        <target state="new">Identifiers should not contain underscores</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixDescription">
        <source>By convention, only the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, should end with specific reserved suffixes. Other type names should not use these reserved suffixes.</source>
        <target state="new">By convention, only the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, should end with specific reserved suffixes. Other type names should not use these reserved suffixes.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixMessageMemberNewerVersion">
        <source>Either replace the suffix '{0}' in member name {1} with the suggested numeric alternate '2' or provide a more meaningful suffix that distinguishes it from the member it replaces.</source>
        <target state="new">Either replace the suffix '{0}' in member name {1} with the suggested numeric alternate '2' or provide a more meaningful suffix that distinguishes it from the member it replaces.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixMessageMemberWithAlternate">
        <source>Either replace the suffix '{0}' in member name '{1}' with the suggested alternate '{2}' or remove the suffix completely.</source>
        <target state="new">Either replace the suffix '{0}' in member name '{1}' with the suggested alternate '{2}' or remove the suffix completely.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixMessageTypeNewerVersion">
        <source>Either replace the suffix '{0}' in type name {1} with the suggested numeric alternate '2' or provide a more meaningful suffix that distinguishes it from the type it replaces.</source>
        <target state="new">Either replace the suffix '{0}' in type name {1} with the suggested numeric alternate '2' or provide a more meaningful suffix that distinguishes it from the type it replaces.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixMessageTypeNoAlternate">
        <source>Rename type name {0} so that it does not end in '{1}'.</source>
        <target state="new">Rename type name {0} so that it does not end in '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixTitle">
        <source>Identifiers should not have incorrect suffix</source>
        <target state="new">Identifiers should not have incorrect suffix</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsDescription">
        <source>A namespace name or a type name matches a reserved keyword in a programming language. Identifiers for namespaces and types should not match keywords that are defined by languages that target the common language runtime.</source>
        <target state="new">A namespace name or a type name matches a reserved keyword in a programming language. Identifiers for namespaces and types should not match keywords that are defined by languages that target the common language runtime.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsMessageMember">
        <source>Rename virtual/interface member {0} so that it no longer conflicts with the reserved language keyword '{1}'. Using a reserved keyword as the name of a virtual/interface member makes it harder for consumers in other languages to override/implement the member.</source>
        <target state="new">Rename virtual/interface member {0} so that it no longer conflicts with the reserved language keyword '{1}'. Using a reserved keyword as the name of a virtual/interface member makes it harder for consumers in other languages to override/implement the member.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsMessageMemberParameter">
        <source>In virtual/interface member {0}, rename parameter {1} so that it no longer conflicts with the reserved language keyword '{2}'. Using a reserved keyword as the name of a parameter on a virtual/interface member makes it harder for consumers in other languages to override/implement the member.</source>
        <target state="new">In virtual/interface member {0}, rename parameter {1} so that it no longer conflicts with the reserved language keyword '{2}'. Using a reserved keyword as the name of a parameter on a virtual/interface member makes it harder for consumers in other languages to override/implement the member.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsMessageNamespace">
        <source>Rename namespace {0} so that it no longer conflicts with the reserved language keyword '{1}'. Using a reserved keyword as the name of a namespace makes it harder for consumers in other languages to use the namespace.</source>
        <target state="new">Rename namespace {0} so that it no longer conflicts with the reserved language keyword '{1}'. Using a reserved keyword as the name of a namespace makes it harder for consumers in other languages to use the namespace.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsMessageType">
        <source>Rename type {0} so that it no longer conflicts with the reserved language keyword '{1}'. Using a reserved keyword as the name of a type makes it harder for consumers in other languages to use the type.</source>
        <target state="new">Rename type {0} so that it no longer conflicts with the reserved language keyword '{1}'. Using a reserved keyword as the name of a type makes it harder for consumers in other languages to use the type.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsTitle">
        <source>Identifiers should not match keywords</source>
        <target state="new">Identifiers should not match keywords</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementComparable">
        <source>Implement Equality and Comparison methods and operators</source>
        <target state="new">Implement Equality and Comparison methods and operators</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementEquatable">
        <source>Implement IEquatable</source>
        <target state="new">Implement IEquatable</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyDescription">
        <source>All IDisposable types should implement the Dispose pattern correctly.</source>
        <target state="new">All IDisposable types should implement the Dispose pattern correctly.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageDisposeBoolSignature">
        <source>Ensure that '{0}' is declared as protected, virtual, and unsealed.</source>
        <target state="new">Ensure that '{0}' is declared as protected, virtual, and unsealed.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageDisposeImplementation">
        <source>Modify '{0}' so that it calls Dispose(true), then calls GC.SuppressFinalize on the current object instance ('this' or 'Me' in Visual Basic), and then returns.</source>
        <target state="new">Modify '{0}' so that it calls Dispose(true), then calls GC.SuppressFinalize on the current object instance ('this' or 'Me' in Visual Basic), and then returns.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageDisposeOverride">
        <source>Remove '{0}', override Dispose(bool disposing), and put the dispose logic in the code path where 'disposing' is true.</source>
        <target state="new">Remove '{0}', override Dispose(bool disposing), and put the dispose logic in the code path where 'disposing' is true.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageDisposeSignature">
        <source>Ensure that '{0}' is declared as public and sealed.</source>
        <target state="new">Ensure that '{0}' is declared as public and sealed.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageFinalizeImplementation">
        <source>Modify '{0}' so that it calls Dispose(false) and then returns.</source>
        <target state="new">Modify '{0}' so that it calls Dispose(false) and then returns.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageFinalizeOverride">
        <source>Remove the finalizer from type '{0}', override Dispose(bool disposing), and put the finalization logic in the code path where 'disposing' is false. Otherwise, it might lead to duplicate Dispose invocations as the Base type '{1}' also provides a finalizer.</source>
        <target state="new">Remove the finalizer from type '{0}', override Dispose(bool disposing), and put the finalization logic in the code path where 'disposing' is false. Otherwise, it might lead to duplicate Dispose invocations as the Base type '{1}' also provides a finalizer.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageIDisposableReimplementation">
        <source>Remove IDisposable from the list of interfaces implemented by '{0}' as it is already implemented by base type '{1}'.</source>
        <target state="new">Remove IDisposable from the list of interfaces implemented by '{0}' as it is already implemented by base type '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageProvideDisposeBool">
        <source>Provide an overridable implementation of Dispose(bool) on '{0}' or mark the type as sealed. A call to Dispose(false) should only clean up native resources. A call to Dispose(true) should clean up both managed and native resources.</source>
        <target state="new">Provide an overridable implementation of Dispose(bool) on '{0}' or mark the type as sealed. A call to Dispose(false) should only clean up native resources. A call to Dispose(true) should clean up both managed and native resources.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageRenameDispose">
        <source>Rename '{0}' to 'Dispose' and ensure that it is declared as public and sealed.</source>
        <target state="new">Rename '{0}' to 'Dispose' and ensure that it is declared as public and sealed.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyTitle">
        <source>Implement IDisposable Correctly</source>
        <target state="new">Implement IDisposable Correctly</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableInterface">
        <source>Implement IDisposable Interface</source>
        <target state="new">Implement IDisposable Interface</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIEquatableWhenOverridingObjectEqualsDescription">
        <source>When a type T overrides Object.Equals(object), the implementation must cast the object argument to the correct type T before performing the comparison. If the type implements IEquatable&lt;T&gt;, and therefore offers the method T.Equals(T), and if the argument is known at compile time to be of type T, then the compiler can call IEquatable&lt;T&gt;.Equals(T) instead of Object.Equals(object), and no cast is necessary, improving performance.</source>
        <target state="new">When a type T overrides Object.Equals(object), the implementation must cast the object argument to the correct type T before performing the comparison. If the type implements IEquatable&lt;T&gt;, and therefore offers the method T.Equals(T), and if the argument is known at compile time to be of type T, then the compiler can call IEquatable&lt;T&gt;.Equals(T) instead of Object.Equals(object), and no cast is necessary, improving performance.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIEquatableWhenOverridingObjectEqualsMessage">
        <source>Implement IEquatable when overriding Object.Equals</source>
        <target state="new">Implement IEquatable when overriding Object.Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIEquatableWhenOverridingObjectEqualsTitle">
        <source>Type {0} should implement IEquatable&lt;T&gt; because it overrides Equals</source>
        <target state="new">Type {0} should implement IEquatable&lt;T&gt; because it overrides Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementStandardExceptionConstructorsDescription">
        <source>Failure to provide the full set of constructors can make it difficult to correctly handle exceptions.</source>
        <target state="new">Failure to provide the full set of constructors can make it difficult to correctly handle exceptions.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementStandardExceptionConstructorsMessageAccessibility">
        <source>Change the accessibility of {0} to {1}.</source>
        <target state="new">Change the accessibility of {0} to {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementStandardExceptionConstructorsMessageMissingConstructor">
        <source>Add the following constructor to {0}: {1}.</source>
        <target state="new">Add the following constructor to {0}: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementStandardExceptionConstructorsTitle">
        <source>Implement standard exception constructors</source>
        <target state="new">Implement standard exception constructors</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesDescription">
        <source>An unsealed externally visible type provides an explicit method implementation of a public interface and does not provide an alternative externally visible method that has the same name.</source>
        <target state="new">An unsealed externally visible type provides an explicit method implementation of a public interface and does not provide an alternative externally visible method that has the same name.</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesFix1">
        <source>Make '{0}' protected.</source>
        <target state="new">Make '{0}' protected.</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesFix2">
        <source>Change '{0}' to a public interface implementation.</source>
        <target state="new">Change '{0}' to a public interface implementation.</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesFix3">
        <source>Make the containing type '{0}' sealed.</source>
        <target state="new">Make the containing type '{0}' sealed.</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesMessage">
        <source>Make '{0}' sealed (a breaking change if this class has previously shipped), implement the method non-explicitly, or implement a new method that exposes the functionality of '{1}' and is visible to derived classes.</source>
        <target state="new">Make '{0}' sealed (a breaking change if this class has previously shipped), implement the method non-explicitly, or implement a new method that exposes the functionality of '{1}' and is visible to derived classes.</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesTitle">
        <source>Interface methods should be callable by child types</source>
        <target state="new">Interface methods should be callable by child types</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileDescription">
        <source>Invalid entry in code metrics rule specification file</source>
        <target state="new">Invalid entry in code metrics rule specification file</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileMessage">
        <source>Invalid entry '{0}' in code metrics rule specification file '{1}'</source>
        <target state="new">Invalid entry '{0}' in code metrics rule specification file '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileTitle">
        <source>Invalid entry in code metrics rule specification file</source>
        <target state="new">Invalid entry in code metrics rule specification file</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeClassStatic">
        <source>Make Class Static</source>
        <target state="new">Make Class Static</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeDeclaringTypeInternal">
        <source>Make declaring type internal.</source>
        <target state="new">Make declaring type internal.</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeDeclaringTypeSealed">
        <source>Make declaring type sealed.</source>
        <target state="new">Make declaring type sealed.</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeExceptionPublic">
        <source>Make exception public</source>
        <target state="new">Make exception public</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeGetterPublic">
        <source>Make the getter of the property public</source>
        <target state="new">Make the getter of the property public</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeMemberNotOverridable">
        <source>Make member not overridable.</source>
        <target state="new">Make member not overridable.</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeSetterNonPublic">
        <source>Make the setter of the property non-public</source>
        <target state="new">Make the setter of the property non-public</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithAssemblyVersionDescription">
        <source>The .NET Framework uses the version number to uniquely identify an assembly, and to bind to types in strongly named assemblies. The version number is used together with version and publisher policy. By default, applications run only with the assembly version with which they were built.</source>
        <target state="new">The .NET Framework uses the version number to uniquely identify an assembly, and to bind to types in strongly named assemblies. The version number is used together with version and publisher policy. By default, applications run only with the assembly version with which they were built.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithAssemblyVersionMessage">
        <source>Mark assemblies with assembly version</source>
        <target state="new">Mark assemblies with assembly version</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithAssemblyVersionTitle">
        <source>Mark assemblies with assembly version</source>
        <target state="new">Mark assemblies with assembly version</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithClsCompliantDescription">
        <source>The Common Language Specification (CLS) defines naming restrictions, data types, and rules to which assemblies must conform if they will be used across programming languages. Good design dictates that all assemblies explicitly indicate CLS compliance by using CLSCompliantAttribute . If this attribute is not present on an assembly, the assembly is not compliant.</source>
        <target state="new">The Common Language Specification (CLS) defines naming restrictions, data types, and rules to which assemblies must conform if they will be used across programming languages. Good design dictates that all assemblies explicitly indicate CLS compliance by using CLSCompliantAttribute . If this attribute is not present on an assembly, the assembly is not compliant.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithClsCompliantMessage">
        <source>Mark assemblies with CLSCompliant</source>
        <target state="new">Mark assemblies with CLSCompliant</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithClsCompliantTitle">
        <source>Mark assemblies with CLSCompliant</source>
        <target state="new">Mark assemblies with CLSCompliant</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithComVisibleDescription">
        <source>ComVisibleAttribute determines how COM clients access managed code. Good design dictates that assemblies explicitly indicate COM visibility. COM visibility can be set for the whole assembly and then overridden for individual types and type members. If this attribute is not present, the contents of the assembly are visible to COM clients.</source>
        <target state="new">ComVisibleAttribute determines how COM clients access managed code. Good design dictates that assemblies explicitly indicate COM visibility. COM visibility can be set for the whole assembly and then overridden for individual types and type members. If this attribute is not present, the contents of the assembly are visible to COM clients.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithComVisibleMessageAttributeTrue">
        <source>Consider changing the ComVisible attribute on {0} to false, and opting in at the type level.</source>
        <target state="new">Consider changing the ComVisible attribute on {0} to false, and opting in at the type level.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithComVisibleMessageNoAttribute">
        <source>Because {0} exposes externally visible types, mark it with ComVisible(false) at the assembly level and then mark all types within the assembly that should be exposed to COM clients with ComVisible(true).</source>
        <target state="new">Because {0} exposes externally visible types, mark it with ComVisible(false) at the assembly level and then mark all types within the assembly that should be exposed to COM clients with ComVisible(true).</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithComVisibleTitle">
        <source>Mark assemblies with ComVisible</source>
        <target state="new">Mark assemblies with ComVisible</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAttributesWithAttributeUsageDescription">
        <source>When you define a custom attribute, mark it by using AttributeUsageAttribute to indicate where in the source code the custom attribute can be applied. The meaning and intended usage of an attribute will determine its valid locations in code.</source>
        <target state="new">When you define a custom attribute, mark it by using AttributeUsageAttribute to indicate where in the source code the custom attribute can be applied. The meaning and intended usage of an attribute will determine its valid locations in code.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAttributesWithAttributeUsageMessageDefault">
        <source>Specify AttributeUsage on {0}.</source>
        <target state="new">Specify AttributeUsage on {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAttributesWithAttributeUsageMessageInherited">
        <source>Even though attribute {0} inherits AttributeUsage from its base type, you should consider explicitly specifying AttributeUsage on the type to improve code readability and documentation.</source>
        <target state="new">Even though attribute {0} inherits AttributeUsage from its base type, you should consider explicitly specifying AttributeUsage on the type to improve code readability and documentation.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAttributesWithAttributeUsageTitle">
        <source>Mark attributes with AttributeUsageAttribute</source>
        <target state="new">Mark attributes with AttributeUsageAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkEnumsWithFlagsCodeFix">
        <source>Apply FlagsAttribute to enum.</source>
        <target state="new">Apply FlagsAttribute to enum.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkEnumsWithFlagsDescription">
        <source>An enumeration is a value type that defines a set of related named constants. Apply FlagsAttribute to an enumeration when its named constants can be meaningfully combined.</source>
        <target state="new">An enumeration is a value type that defines a set of related named constants. Apply FlagsAttribute to an enumeration when its named constants can be meaningfully combined.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkEnumsWithFlagsMessage">
        <source>Mark enums with FlagsAttribute</source>
        <target state="new">Mark enums with FlagsAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkEnumsWithFlagsTitle">
        <source>Mark enums with FlagsAttribute</source>
        <target state="new">Mark enums with FlagsAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticCodeFix">
        <source>Make static</source>
        <target state="new">Make static</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticCodeFix_WarningAnnotation">
        <source>Some references to '{0}' could not be fixed, they should be fixed manually.</source>
        <target state="new">Some references to '{0}' could not be fixed, they should be fixed manually.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticDescription">
        <source>Members that do not access instance data or call instance methods can be marked as static (Shared in Visual Basic). After you mark the methods as static, the compiler will emit nonvirtual call sites to these members. This can give you a measurable performance gain for performance-sensitive code.</source>
        <target state="new">Members that do not access instance data or call instance methods can be marked as static (Shared in Visual Basic). After you mark the methods as static, the compiler will emit nonvirtual call sites to these members. This can give you a measurable performance gain for performance-sensitive code.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticMessage">
        <source>Member {0} does not access instance data and can be marked as static (Shared in VisualBasic)</source>
        <target state="new">Member {0} does not access instance data and can be marked as static (Shared in VisualBasic)</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticTitle">
        <source>Mark members as static</source>
        <target state="new">Mark members as static</target>
        <note />
      </trans-unit>
      <trans-unit id="MovePInvokesToNativeMethodsClassDescription">
        <source>Platform Invocation methods, such as those that are marked by using the System.Runtime.InteropServices.DllImportAttribute attribute, or methods that are defined by using the Declare keyword in Visual Basic, access unmanaged code. These methods should be of the NativeMethods, SafeNativeMethods, or UnsafeNativeMethods class.</source>
        <target state="new">Platform Invocation methods, such as those that are marked by using the System.Runtime.InteropServices.DllImportAttribute attribute, or methods that are defined by using the Declare keyword in Visual Basic, access unmanaged code. These methods should be of the NativeMethods, SafeNativeMethods, or UnsafeNativeMethods class.</target>
        <note />
      </trans-unit>
      <trans-unit id="MovePInvokesToNativeMethodsClassMessage">
        <source>Move pinvokes to native methods class</source>
        <target state="new">Move pinvokes to native methods class</target>
        <note />
      </trans-unit>
      <trans-unit id="MovePInvokesToNativeMethodsClassTitle">
        <source>Move pinvokes to native methods class</source>
        <target state="new">Move pinvokes to native methods class</target>
        <note />
      </trans-unit>
      <trans-unit id="NestedTypesShouldNotBeVisibleDescription">
        <source>A nested type is a type that is declared in the scope of another type. Nested types are useful to encapsulate private implementation details of the containing type. Used for this purpose, nested types should not be externally visible.</source>
        <target state="new">A nested type is a type that is declared in the scope of another type. Nested types are useful to encapsulate private implementation details of the containing type. Used for this purpose, nested types should not be externally visible.</target>
        <note />
      </trans-unit>
      <trans-unit id="NestedTypesShouldNotBeVisibleMessageDefault">
        <source>Do not nest type {0}. Alternatively, change its accessibility so that it is not externally visible.</source>
        <target state="new">Do not nest type {0}. Alternatively, change its accessibility so that it is not externally visible.</target>
        <note />
      </trans-unit>
      <trans-unit id="NestedTypesShouldNotBeVisibleMessageVisualBasicModule">
        <source>Do not nest type {0}. Alternatively, change its accessibility so that it is not externally visible. If this type is defined in a Visual Basic Module, it will be considered a nested type to other .NET languages. In that case, consider moving the type outside of the Module.</source>
        <target state="new">Do not nest type {0}. Alternatively, change its accessibility so that it is not externally visible. If this type is defined in a Visual Basic Module, it will be considered a nested type to other .NET languages. In that case, consider moving the type outside of the Module.</target>
        <note />
      </trans-unit>
      <trans-unit id="NestedTypesShouldNotBeVisibleTitle">
        <source>Nested types should not be visible</source>
        <target state="new">Nested types should not be visible</target>
        <note />
      </trans-unit>
      <trans-unit id="NonConstantFieldsShouldNotBeVisibleDescription">
        <source>Static fields that are neither constants nor read-only are not thread-safe. Access to such a field must be carefully controlled and requires advanced programming techniques to synchronize access to the class object.</source>
        <target state="new">Static fields that are neither constants nor read-only are not thread-safe. Access to such a field must be carefully controlled and requires advanced programming techniques to synchronize access to the class object.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonConstantFieldsShouldNotBeVisibleMessage">
        <source>Non-constant fields should not be visible</source>
        <target state="new">Non-constant fields should not be visible</target>
        <note />
      </trans-unit>
      <trans-unit id="NonConstantFieldsShouldNotBeVisibleTitle">
        <source>Non-constant fields should not be visible</source>
        <target state="new">Non-constant fields should not be visible</target>
        <note />
      </trans-unit>
      <trans-unit id="OnlyFlagsEnumsShouldHavePluralNamesDescription">
        <source>Naming conventions dictate that a plural name for an enumeration indicates that more than one value of the enumeration can be specified at the same time.</source>
        <target state="new">Naming conventions dictate that a plural name for an enumeration indicates that more than one value of the enumeration can be specified at the same time.</target>
        <note />
      </trans-unit>
      <trans-unit id="OnlyFlagsEnumsShouldHavePluralNamesMessage">
        <source>Only FlagsAttribute enums should have plural names</source>
        <target state="new">Only FlagsAttribute enums should have plural names</target>
        <note />
      </trans-unit>
      <trans-unit id="OnlyFlagsEnumsShouldHavePluralNamesTitle">
        <source>Only FlagsAttribute enums should have plural names</source>
        <target state="new">Only FlagsAttribute enums should have plural names</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesDescription">
        <source>An operator overload was detected, and the expected named alternative method was not found. The named alternative member provides access to the same functionality as the operator and is provided for developers who program in languages that do not support overloaded operators.</source>
        <target state="new">An operator overload was detected, and the expected named alternative method was not found. The named alternative member provides access to the same functionality as the operator and is provided for developers who program in languages that do not support overloaded operators.</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesMessageDefault">
        <source>Provide a method named '{0}' as a friendly alternate for operator {1}.</source>
        <target state="new">Provide a method named '{0}' as a friendly alternate for operator {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesMessageMultiple">
        <source>Provide a method named '{0}' or '{1}' as an alternate for operator {2}.</source>
        <target state="new">Provide a method named '{0}' or '{1}' as an alternate for operator {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesMessageProperty">
        <source>Provide a property named '{0}' as a friendly alternate for operator {1}.</source>
        <target state="new">Provide a property named '{0}' as a friendly alternate for operator {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesMessageVisibility">
        <source>Mark {0} as public because it is a friendly alternate for operator {1}.</source>
        <target state="new">Mark {0} as public because it is a friendly alternate for operator {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesTitle">
        <source>Operator overloads have named alternates</source>
        <target state="new">Operator overloads have named alternates</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorsShouldHaveSymmetricalOverloadsDescription">
        <source>A type implements the equality or inequality operator and does not implement the opposite operator.</source>
        <target state="new">A type implements the equality or inequality operator and does not implement the opposite operator.</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorsShouldHaveSymmetricalOverloadsMessage">
        <source>Operators should have symmetrical overloads</source>
        <target state="new">Operators should have symmetrical overloads</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorsShouldHaveSymmetricalOverloadsTitle">
        <source>Operators should have symmetrical overloads</source>
        <target state="new">Operators should have symmetrical overloads</target>
        <note />
      </trans-unit>
      <trans-unit id="OverloadOperatorEqualsOnOverridingValueTypeEqualsDescription">
        <source>In most programming languages there is no default implementation of the equality operator (==) for value types. If your programming language supports operator overloads, you should consider implementing the equality operator. Its behavior should be identical to that of Equals</source>
        <target state="new">In most programming languages there is no default implementation of the equality operator (==) for value types. If your programming language supports operator overloads, you should consider implementing the equality operator. Its behavior should be identical to that of Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="OverloadOperatorEqualsOnOverridingValueTypeEqualsMessage">
        <source>Overload operator equals on overriding value type Equals</source>
        <target state="new">Overload operator equals on overriding value type Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="OverloadOperatorEqualsOnOverridingValueTypeEqualsTitle">
        <source>Overload operator equals on overriding value type Equals</source>
        <target state="new">Overload operator equals on overriding value type Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsAndOperatorEqualsOnValueTypesDescription">
        <source>For value types, the inherited implementation of Equals uses the Reflection library and compares the contents of all fields. Reflection is computationally expensive, and comparing every field for equality might be unnecessary. If you expect users to compare or sort instances, or to use instances as hash table keys, your value type should implement Equals.</source>
        <target state="new">For value types, the inherited implementation of Equals uses the Reflection library and compares the contents of all fields. Reflection is computationally expensive, and comparing every field for equality might be unnecessary. If you expect users to compare or sort instances, or to use instances as hash table keys, your value type should implement Equals.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsAndOperatorEqualsOnValueTypesMessageEquals">
        <source>{0} should override Equals.</source>
        <target state="new">{0} should override Equals.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsAndOperatorEqualsOnValueTypesMessageOpEquality">
        <source>{0} should override the equality (==) and inequality (!=) operators.</source>
        <target state="new">{0} should override the equality (==) and inequality (!=) operators.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsAndOperatorEqualsOnValueTypesTitle">
        <source>Override equals and operator equals on value types</source>
        <target state="new">Override equals and operator equals on value types</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnImplementingIEquatableCodeActionTitle">
        <source>Override object.Equals</source>
        <target state="new">Override object.Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnOverloadingOperatorEqualsCodeActionTitle">
        <source>Override object.Equals</source>
        <target state="new">Override object.Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnOverloadingOperatorEqualsDescription">
        <source>A public type implements the equality operator but does not override Object.Equals.</source>
        <target state="new">A public type implements the equality operator but does not override Object.Equals.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnOverloadingOperatorEqualsMessage">
        <source>Override Equals on overloading operator equals</source>
        <target state="new">Override Equals on overloading operator equals</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnOverloadingOperatorEqualsTitle">
        <source>Override Equals on overloading operator equals</source>
        <target state="new">Override Equals on overloading operator equals</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideGetHashCodeOnOverridingEqualsCodeActionTitle">
        <source>Override object.GetHashCode</source>
        <target state="new">Override object.GetHashCode</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideGetHashCodeOnOverridingEqualsDescription">
        <source>GetHashCode returns a value, based on the current instance, that is suited for hashing algorithms and data structures such as a hash table. Two objects that are the same type and are equal must return the same hash code.</source>
        <target state="new">GetHashCode returns a value, based on the current instance, that is suited for hashing algorithms and data structures such as a hash table. Two objects that are the same type and are equal must return the same hash code.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideGetHashCodeOnOverridingEqualsMessage">
        <source>Override GetHashCode on overriding Equals</source>
        <target state="new">Override GetHashCode on overriding Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideGetHashCodeOnOverridingEqualsTitle">
        <source>Override GetHashCode on overriding Equals</source>
        <target state="new">Override GetHashCode on overriding Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesDescription">
        <source>A public or protected type implements the System.IComparable interface. It does not override Object.Equals nor does it overload the language-specific operator for equality, inequality, less than, less than or equal, greater than or greater than or equal.</source>
        <target state="new">A public or protected type implements the System.IComparable interface. It does not override Object.Equals nor does it overload the language-specific operator for equality, inequality, less than, less than or equal, greater than or greater than or equal.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesMessageBoth">
        <source>{0} should define operator(s) '{1}' and Equals since it implements IComparable.</source>
        <target state="new">{0} should define operator(s) '{1}' and Equals since it implements IComparable.</target>
        <note>1 is a comma-separated list</note>
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesMessageEquals">
        <source>{0} should override Equals since it implements IComparable.</source>
        <target state="new">{0} should override Equals since it implements IComparable.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesMessageOperator">
        <source>{0} should define operator(s) '{1}' since it implements IComparable.</source>
        <target state="new">{0} should define operator(s) '{1}' since it implements IComparable.</target>
        <note>1 is a comma-separated list</note>
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesTitle">
        <source>Override methods on comparable types</source>
        <target state="new">Override methods on comparable types</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsDescription">
        <source>When a type T implements the interface IEquatable&lt;T&gt;, it suggests to a user who sees a call to the Equals method in source code that an instance of the type can be equated with an instance of any other type. The user might be confused if their attempt to equate the type with an instance of another type fails to compile. This violates the "principle of least surprise".</source>
        <target state="new">When a type T implements the interface IEquatable&lt;T&gt;, it suggests to a user who sees a call to the Equals method in source code that an instance of the type can be equated with an instance of any other type. The user might be confused if their attempt to equate the type with an instance of another type fails to compile. This violates the "principle of least surprise".</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsMessage">
        <source>Type {0} should override Equals because it implements IEquatable&lt;T&gt;</source>
        <target state="new">Type {0} should override Equals because it implements IEquatable&lt;T&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsTitle">
        <source>Override Object.Equals(object) when implementing IEquatable&lt;T&gt;</source>
        <target state="new">Override Object.Equals(object) when implementing IEquatable&lt;T&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="ParameterNamesShouldMatchBaseDeclarationDescription">
        <source>Consistent naming of parameters in an override hierarchy increases the usability of the method overrides. A parameter name in a derived method that differs from the name in the base declaration can cause confusion about whether the method is an override of the base method or a new overload of the method.</source>
        <target state="new">Consistent naming of parameters in an override hierarchy increases the usability of the method overrides. A parameter name in a derived method that differs from the name in the base declaration can cause confusion about whether the method is an override of the base method or a new overload of the method.</target>
        <note />
      </trans-unit>
      <trans-unit id="ParameterNamesShouldMatchBaseDeclarationMessage">
        <source>In member {0}, change parameter name {1} to {2} in order to match the identifier as it has been declared in {3}.</source>
        <target state="new">In member {0}, change parameter name {1} to {2} in order to match the identifier as it has been declared in {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ParameterNamesShouldMatchBaseDeclarationTitle">
        <source>Parameter names should match base declaration</source>
        <target state="new">Parameter names should match base declaration</target>
        <note />
      </trans-unit>
      <trans-unit id="PassSystemUriObjectsInsteadOfStringsDescription">
        <source>A call is made to a method that has a string parameter whose name contains "uri", "URI", "urn", "URN", "url", or "URL". The declaring type of the method contains a corresponding method overload that has a System.Uri parameter.</source>
        <target state="new">A call is made to a method that has a string parameter whose name contains "uri", "URI", "urn", "URN", "url", or "URL". The declaring type of the method contains a corresponding method overload that has a System.Uri parameter.</target>
        <note />
      </trans-unit>
      <trans-unit id="PassSystemUriObjectsInsteadOfStringsMessage">
        <source>Modify '{0}' to call '{1}' instead of '{2}'.</source>
        <target state="new">Modify '{0}' to call '{1}' instead of '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="PassSystemUriObjectsInsteadOfStringsTitle">
        <source>Pass system uri objects instead of strings</source>
        <target state="new">Pass system uri objects instead of strings</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalDescription">
        <source>A jagged array is an array whose elements are arrays. The arrays that make up the elements can be of different sizes, leading to less wasted space for some sets of data.</source>
        <target state="new">A jagged array is an array whose elements are arrays. The arrays that make up the elements can be of different sizes, leading to less wasted space for some sets of data.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageBody">
        <source>{0} uses a multidimensional array of {1}. Replace it with a jagged array if possible.</source>
        <target state="new">{0} uses a multidimensional array of {1}. Replace it with a jagged array if possible.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageDefault">
        <source>{0} is a multidimensional array. Replace it with a jagged array if possible.</source>
        <target state="new">{0} is a multidimensional array. Replace it with a jagged array if possible.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageReturn">
        <source>{0} returns a multidimensional array of {1}. Replace it with a jagged array if possible.</source>
        <target state="new">{0} returns a multidimensional array of {1}. Replace it with a jagged array if possible.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalTitle">
        <source>Prefer jagged arrays over multidimensional</source>
        <target state="new">Prefer jagged arrays over multidimensional</target>
        <note />
      </trans-unit>
      <trans-unit id="PropagateCancellationTokensWhenPossibleDescription">
        <source>#N/A</source>
        <target state="new">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="PropagateCancellationTokensWhenPossibleMessage">
        <source>Propagate CancellationTokens When Possible</source>
        <target state="new">Propagate CancellationTokens When Possible</target>
        <note />
      </trans-unit>
      <trans-unit id="PropagateCancellationTokensWhenPossibleTitle">
        <source>Propagate CancellationTokens When Possible</source>
        <target state="new">Propagate CancellationTokens When Possible</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotBeWriteOnlyDescription">
        <source>Although it is acceptable and often necessary to have a read-only property, the design guidelines prohibit the use of write-only properties. This is because letting a user set a value, and then preventing the user from viewing that value, does not provide any security. Also, without read access, the state of shared objects cannot be viewed, which limits their usefulness.</source>
        <target state="new">Although it is acceptable and often necessary to have a read-only property, the design guidelines prohibit the use of write-only properties. This is because letting a user set a value, and then preventing the user from viewing that value, does not provide any security. Also, without read access, the state of shared objects cannot be viewed, which limits their usefulness.</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotBeWriteOnlyMessageAddGetter">
        <source>Because property {0} is write-only, either add a property getter with an accessibility that is greater than or equal to its setter or convert this property into a method.</source>
        <target state="new">Because property {0} is write-only, either add a property getter with an accessibility that is greater than or equal to its setter or convert this property into a method.</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotBeWriteOnlyMessageMakeMoreAccessible">
        <source>Because the property getter for {0} is less visible than its setter, either increase the accessibility of its getter or decrease the accessibility of its setter.</source>
        <target state="new">Because the property getter for {0} is less visible than its setter, either increase the accessibility of its getter or decrease the accessibility of its setter.</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotBeWriteOnlyTitle">
        <source>Properties should not be write only</source>
        <target state="new">Properties should not be write only</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotReturnArraysDescription">
        <source>Arrays that are returned by properties are not write-protected, even when the property is read-only. To keep the array tamper-proof, the property must return a copy of the array. Typically, users will not understand the adverse performance implications of calling such a property.</source>
        <target state="new">Arrays that are returned by properties are not write-protected, even when the property is read-only. To keep the array tamper-proof, the property must return a copy of the array. Typically, users will not understand the adverse performance implications of calling such a property.</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotReturnArraysMessage">
        <source>Properties should not return arrays</source>
        <target state="new">Properties should not return arrays</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotReturnArraysTitle">
        <source>Properties should not return arrays</source>
        <target state="new">Properties should not return arrays</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertyNamesShouldNotMatchGetMethodsDescription">
        <source>The name of a public or protected member starts with ""Get"" and otherwise matches the name of a public or protected property. ""Get"" methods and properties should have names that clearly distinguish their function.</source>
        <target state="new">The name of a public or protected member starts with ""Get"" and otherwise matches the name of a public or protected property. ""Get"" methods and properties should have names that clearly distinguish their function.</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertyNamesShouldNotMatchGetMethodsMessage">
        <source>The property name '{0}' is confusing given the existence of method '{1}'. Rename or remove one of these members.</source>
        <target state="new">The property name '{0}' is confusing given the existence of method '{1}'. Rename or remove one of these members.</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertyNamesShouldNotMatchGetMethodsTitle">
        <source>Property names should not match get methods</source>
        <target state="new">Property names should not match get methods</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideObsoleteAttributeMessageDescription">
        <source>A type or member is marked by using a System.ObsoleteAttribute attribute that does not have its ObsoleteAttribute.Message property specified. When a type or member that is marked by using ObsoleteAttribute is compiled, the Message property of the attribute is displayed. This gives the user information about the obsolete type or member.</source>
        <target state="new">A type or member is marked by using a System.ObsoleteAttribute attribute that does not have its ObsoleteAttribute.Message property specified. When a type or member that is marked by using ObsoleteAttribute is compiled, the Message property of the attribute is displayed. This gives the user information about the obsolete type or member.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideObsoleteAttributeMessageMessage">
        <source>Provide a message for the ObsoleteAttribute that marks {0} as Obsolete</source>
        <target state="new">Provide a message for the ObsoleteAttribute that marks {0} as Obsolete</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideObsoleteAttributeMessageTitle">
        <source>Provide ObsoleteAttribute message</source>
        <target state="new">Provide ObsoleteAttribute message</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveEmptyFinalizers">
        <source>Remove empty Finalizers</source>
        <target state="new">Remove empty Finalizers</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveEmptyFinalizersDescription">
        <source>Finalizers should be avoided where possible, to avoid the additional performance overhead involved in tracking object lifetime.</source>
        <target state="new">Finalizers should be avoided where possible, to avoid the additional performance overhead involved in tracking object lifetime.</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveUnusedParameterMessage">
        <source>Remove unused parameter</source>
        <target state="new">Remove unused parameter</target>
        <note />
      </trans-unit>
      <trans-unit id="RenameToTitle">
        <source>Rename to '{0}'</source>
        <target state="new">Rename to '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsMessage">
        <source>Re-throwing caught exception changes stack information.</source>
        <target state="new">Re-throwing caught exception changes stack information.</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsTitle">
        <source>Rethrow to preserve stack details.</source>
        <target state="new">Rethrow to preserve stack details.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewUnusedParametersDescription">
        <source>Avoid unused paramereters in your code. If the parameter cannot be removed, then change its name so it starts with an underscore and is optionally followed by an integer, such as '_', '_1', '_2', etc. These are treated as special discard symbol names.</source>
        <target state="new">Avoid unused paramereters in your code. If the parameter cannot be removed, then change its name so it starts with an underscore and is optionally followed by an integer, such as '_', '_1', '_2', etc. These are treated as special discard symbol names.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewUnusedParametersMessage">
        <source>Parameter {0} of method {1} is never used. Remove the parameter or use it in the method body.</source>
        <target state="new">Parameter {0} of method {1} is never used. Remove the parameter or use it in the method body.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewUnusedParametersTitle">
        <source>Review unused parameters</source>
        <target state="new">Review unused parameters</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersDescription">
        <source>A public or protected event-handling method was detected. Event-handling methods should not be exposed unless absolutely necessary.</source>
        <target state="new">A public or protected event-handling method was detected. Event-handling methods should not be exposed unless absolutely necessary.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersMessageDefault">
        <source>Consider making {0} not externally visible.</source>
        <target state="new">Consider making {0} not externally visible.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersMessageSecurity">
        <source>Consider making {0} not externally visible or ensure that it is benign code.</source>
        <target state="new">Consider making {0} not externally visible or ensure that it is benign code.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersTitle">
        <source>Review visible event handlers</source>
        <target state="new">Review visible event handlers</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesDescription">
        <source>An inheritable public type provides an overridable method implementation of an internal (Friend in Visual Basic) interface. To fix a violation of this rule, prevent the method from being overridden outside the assembly.</source>
        <target state="new">An inheritable public type provides an overridable method implementation of an internal (Friend in Visual Basic) interface. To fix a violation of this rule, prevent the method from being overridden outside the assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesMessage">
        <source>Seal methods that satisfy private interfaces</source>
        <target state="new">Seal methods that satisfy private interfaces</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesTitle">
        <source>Seal methods that satisfy private interfaces</source>
        <target state="new">Seal methods that satisfy private interfaces</target>
        <note />
      </trans-unit>
      <trans-unit id="Since_0_redefines_operator_1_it_should_also_redefine_operator_2">
        <source>Since '{0}' redefines operator '{1}', it should also redefine operator '{2}'</source>
        <target state="new">Since '{0}' redefines operator '{1}', it should also redefine operator '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="StaticHolderTypeIsNotStatic">
        <source>Type '{0}' is a static holder type but is neither static nor NotInheritable</source>
        <target state="new">Type '{0}' is a static holder type but is neither static nor NotInheritable</target>
        <note />
      </trans-unit>
      <trans-unit id="StaticHolderTypesShouldBeStaticOrNotInheritable">
        <source>Static holder types should be Static or NotInheritable</source>
        <target state="new">Static holder types should be Static or NotInheritable</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNamesShouldNotMatchNamespacesDescription">
        <source>Type names should not match the names of namespaces that are defined in the .NET Framework class library. Violating this rule can reduce the usability of the library.</source>
        <target state="new">Type names should not match the names of namespaces that are defined in the .NET Framework class library. Violating this rule can reduce the usability of the library.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNamesShouldNotMatchNamespacesMessageDefault">
        <source>The type name {0} conflicts in whole or in part with the namespace name '{1}'. Change either name to eliminate the conflict.</source>
        <target state="new">The type name {0} conflicts in whole or in part with the namespace name '{1}'. Change either name to eliminate the conflict.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNamesShouldNotMatchNamespacesMessageSystem">
        <source>The type name {0} conflicts in whole or in part with the namespace name '{1}' defined in the .NET Framework. Rename the type to eliminate the conflict.</source>
        <target state="new">The type name {0} conflicts in whole or in part with the namespace name '{1}' defined in the .NET Framework. Rename the type to eliminate the conflict.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNamesShouldNotMatchNamespacesTitle">
        <source>Type names should not match namespaces</source>
        <target state="new">Type names should not match namespaces</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesThatOwnDisposableFieldsShouldBeDisposableDescription">
        <source>A class declares and implements an instance field that is a System.IDisposable type, and the class does not implement IDisposable. A class that declares an IDisposable field indirectly owns an unmanaged resource and should implement the IDisposable interface.</source>
        <target state="new">A class declares and implements an instance field that is a System.IDisposable type, and the class does not implement IDisposable. A class that declares an IDisposable field indirectly owns an unmanaged resource and should implement the IDisposable interface.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesThatOwnDisposableFieldsShouldBeDisposableMessageNonBreaking">
        <source>Type '{0}' owns disposable field(s) '{1}' but is not disposable</source>
        <target state="new">Type '{0}' owns disposable field(s) '{1}' but is not disposable</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesThatOwnDisposableFieldsShouldBeDisposableTitle">
        <source>Types that own disposable fields should be disposable</source>
        <target state="new">Types that own disposable fields should be disposable</target>
        <note />
      </trans-unit>
      <trans-unit id="UriParametersShouldNotBeStringsDescription">
        <source>If a method takes a string representation of a URI, a corresponding overload should be provided that takes an instance of the URI class, which provides these services in a safe and secure manner.</source>
        <target state="new">If a method takes a string representation of a URI, a corresponding overload should be provided that takes an instance of the URI class, which provides these services in a safe and secure manner.</target>
        <note />
      </trans-unit>
      <trans-unit id="UriParametersShouldNotBeStringsMessage">
        <source>Change the type of parameter {0} of method {1} from string to System.Uri, or provide an overload to {1} that allows {0} to be passed as a System.Uri object.</source>
        <target state="new">Change the type of parameter {0} of method {1} from string to System.Uri, or provide an overload to {1} that allows {0} to be passed as a System.Uri object.</target>
        <note />
      </trans-unit>
      <trans-unit id="UriParametersShouldNotBeStringsTitle">
        <source>Uri parameters should not be strings</source>
        <target state="new">Uri parameters should not be strings</target>
        <note />
      </trans-unit>
      <trans-unit id="UriPropertiesShouldNotBeStringsDescription">
        <source>This rule assumes that the property represents a Uniform Resource Identifier (URI). A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner.</source>
        <target state="new">This rule assumes that the property represents a Uniform Resource Identifier (URI). A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner.</target>
        <note />
      </trans-unit>
      <trans-unit id="UriPropertiesShouldNotBeStringsMessage">
        <source>Change the type of property {0} from string to System.Uri.</source>
        <target state="new">Change the type of property {0} from string to System.Uri.</target>
        <note />
      </trans-unit>
      <trans-unit id="UriPropertiesShouldNotBeStringsTitle">
        <source>Uri properties should not be strings</source>
        <target state="new">Uri properties should not be strings</target>
        <note />
      </trans-unit>
      <trans-unit id="UriReturnValuesShouldNotBeStringsDescription">
        <source>This rule assumes that the method returns a URI. A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner.</source>
        <target state="new">This rule assumes that the method returns a URI. A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner.</target>
        <note />
      </trans-unit>
      <trans-unit id="UriReturnValuesShouldNotBeStringsMessage">
        <source>Change the return type of method {0} from string to System.Uri.</source>
        <target state="new">Change the return type of method {0} from string to System.Uri.</target>
        <note />
      </trans-unit>
      <trans-unit id="UriReturnValuesShouldNotBeStringsTitle">
        <source>Uri return values should not be strings</source>
        <target state="new">Uri return values should not be strings</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEventsWhereAppropriateDescription">
        <source>This rule detects methods that have names that ordinarily would be used for events. If a method is called in response to a clearly defined state change, the method should be invoked by an event handler. Objects that call the method should raise events instead of calling the method directly.</source>
        <target state="new">This rule detects methods that have names that ordinarily would be used for events. If a method is called in response to a clearly defined state change, the method should be invoked by an event handler. Objects that call the method should raise events instead of calling the method directly.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEventsWhereAppropriateMessage">
        <source>Consider making '{0}' an event.</source>
        <target state="new">Consider making '{0}' an event.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEventsWhereAppropriateTitle">
        <source>Use events where appropriate</source>
        <target state="new">Use events where appropriate</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForDelegateDescription">
        <source>A type contains a delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets Microsoft .NET Framework?2.0.</source>
        <target state="new">A type contains a delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets Microsoft .NET Framework?2.0.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForDelegateMessage">
        <source>Remove '{0}' and replace its usage with a generic EventHandler, for e.g. EventHandler&lt;T&gt;, where T is a valid EventArgs</source>
        <target state="new">Remove '{0}' and replace its usage with a generic EventHandler, for e.g. EventHandler&lt;T&gt;, where T is a valid EventArgs</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForEvent2Description">
        <source>A type contains an event that declares an EventHandler delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets Microsoft .NET Framework?2.0.</source>
        <target state="new">A type contains an event that declares an EventHandler delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets Microsoft .NET Framework?2.0.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForEvent2Message">
        <source>Change the event '{0}' to use a generic EventHandler by defining the event type explicitly, for e.g. Event MyEvent As EventHandler(Of MyEventArgs).</source>
        <target state="new">Change the event '{0}' to use a generic EventHandler by defining the event type explicitly, for e.g. Event MyEvent As EventHandler(Of MyEventArgs).</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForEventDescription">
        <source>A delegate that handles a public or protected event does not have the correct signature, return type, or parameter names.</source>
        <target state="new">A delegate that handles a public or protected event does not have the correct signature, return type, or parameter names.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForEventMessage">
        <source>Change the event '{0}' to replace the type '{1}' with a generic EventHandler, for e.g. EventHandler&lt;T&gt;, where T is a valid EventArgs</source>
        <target state="new">Change the event '{0}' to replace the type '{1}' with a generic EventHandler, for e.g. EventHandler&lt;T&gt;, where T is a valid EventArgs</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesTitle">
        <source>Use generic event handler instances</source>
        <target state="new">Use generic event handler instances</target>
        <note />
      </trans-unit>
      <trans-unit id="UseIntegralOrStringArgumentForIndexersDescription">
        <source>Indexers, that is, indexed properties, should use integer or string types for the index. These types are typically used for indexing data structures and increase the usability of the library. Use of the Object type should be restricted to those cases where the specific integer or string type cannot be specified at design time. If the design requires other types for the index, reconsider whether the type represents a logical data store. If it does not represent a logical data store, use a method.</source>
        <target state="new">Indexers, that is, indexed properties, should use integer or string types for the index. These types are typically used for indexing data structures and increase the usability of the library. Use of the Object type should be restricted to those cases where the specific integer or string type cannot be specified at design time. If the design requires other types for the index, reconsider whether the type represents a logical data store. If it does not represent a logical data store, use a method.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseIntegralOrStringArgumentForIndexersMessage">
        <source>Use Integral Or String Argument For Indexers</source>
        <target state="new">Use Integral Or String Argument For Indexers</target>
        <note />
      </trans-unit>
      <trans-unit id="UseIntegralOrStringArgumentForIndexersTitle">
        <source>Use Integral Or String Argument For Indexers</source>
        <target state="new">Use Integral Or String Argument For Indexers</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateCodeActionTitle">
        <source>Change to constant</source>
        <target state="new">Change to constant</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateDescription">
        <source>A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized by using a value that is computable at compile time. Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic) field so that the value is computed at compile time instead of at run?time.</source>
        <target state="new">A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized by using a value that is computable at compile time. Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic) field so that the value is computed at compile time instead of at run?time.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateMessageDefault">
        <source>Field '{0}' is declared as 'readonly' but is initialized with a constant value. Mark this field as 'const' instead.</source>
        <target state="new">Field '{0}' is declared as 'readonly' but is initialized with a constant value. Mark this field as 'const' instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateMessageEmptyString">
        <source>Field '{0}' is declared as 'readonly' but is initialized with an empty string (""). Mark this field as 'const' instead.</source>
        <target state="new">Field '{0}' is declared as 'readonly' but is initialized with an empty string (""). Mark this field as 'const' instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateTitle">
        <source>Use literals where appropriate</source>
        <target state="new">Use literals where appropriate</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringDescription">
        <source>Using nameof helps keep your code valid when refactoring.</source>
        <target state="new">Using nameof helps keep your code valid when refactoring.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringMessage">
        <source>Use nameof in place of string literal '{0}'</source>
        <target state="new">Use nameof in place of string literal '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringTitle">
        <source>Use nameof to express symbol names</source>
        <target state="new">Use nameof to express symbol names</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsDescription">
        <source>The name of an externally visible identifier includes a term for which an alternative, preferred term exists. Alternatively, the name includes the term ""Flag"" or ""Flags"".</source>
        <target state="new">The name of an externally visible identifier includes a term for which an alternative, preferred term exists. Alternatively, the name includes the term ""Flag"" or ""Flags"".</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageAssembly">
        <source>Replace the term '{0}' in assembly name {1} with the preferred alternate '{2}'.</source>
        <target state="new">Replace the term '{0}' in assembly name {1} with the preferred alternate '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageAssemblyNoAlternate">
        <source>Replace the term '{0}' in assembly name {1} with an appropriate alternate or remove it entirely.</source>
        <target state="new">Replace the term '{0}' in assembly name {1} with an appropriate alternate or remove it entirely.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageDelegateParameter">
        <source>In delegate {0}, replace the term '{1}' in parameter name {2} with the preferred alternate '{3}'.</source>
        <target state="new">In delegate {0}, replace the term '{1}' in parameter name {2} with the preferred alternate '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageDelegateParameterNoAlternate">
        <source>In delegate {0}, replace the term '{1}' in parameter name {2} with an appropriate alternate or remove it entirely.</source>
        <target state="new">In delegate {0}, replace the term '{1}' in parameter name {2} with an appropriate alternate or remove it entirely.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageMember">
        <source>Replace the term '{0}' in member name {1} with the preferred alternate '{2}'.</source>
        <target state="new">Replace the term '{0}' in member name {1} with the preferred alternate '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageMemberNoAlternate">
        <source>Replace the term '{0}' in member name {1} with an appropriate alternate or remove it entirely.</source>
        <target state="new">Replace the term '{0}' in member name {1} with an appropriate alternate or remove it entirely.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageMemberParameter">
        <source>In member {0}, replace the term '{1}' in parameter name {2} with the preferred alternate '{3}'.</source>
        <target state="new">In member {0}, replace the term '{1}' in parameter name {2} with the preferred alternate '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageMemberParameterNoAlternate">
        <source>In member {0}, replace the term '{1}' in parameter name {2} with an appropriate alternate or remove it entirely.</source>
        <target state="new">In member {0}, replace the term '{1}' in parameter name {2} with an appropriate alternate or remove it entirely.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageMethodTypeParameter">
        <source>On method {0}, replace the term '{1}' in generic type parameter name {2} with the preferred alternate '{3}'.</source>
        <target state="new">On method {0}, replace the term '{1}' in generic type parameter name {2} with the preferred alternate '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageMethodTypeParameterNoAlternate">
        <source>On method {0}, replace the term '{1}' in generic type parameter name {2} with an appropriate alternate or remove it entirely.</source>
        <target state="new">On method {0}, replace the term '{1}' in generic type parameter name {2} with an appropriate alternate or remove it entirely.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageNamespace">
        <source>Replace the term '{0}' in namespace name '{1}' with the preferred alternate '{2}'.</source>
        <target state="new">Replace the term '{0}' in namespace name '{1}' with the preferred alternate '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageNamespaceNoAlternate">
        <source>Replace the term '{0}' in namespace name '{1}' with an appropriate alternate or remove it entirely.</source>
        <target state="new">Replace the term '{0}' in namespace name '{1}' with an appropriate alternate or remove it entirely.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageType">
        <source>Replace the term '{0}' in type name {1} with the preferred alternate '{2}'.</source>
        <target state="new">Replace the term '{0}' in type name {1} with the preferred alternate '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageTypeNoAlternate">
        <source>Replace the term '{0}' in type name {1} with an appropriate alternate or remove it entirely.</source>
        <target state="new">Replace the term '{0}' in type name {1} with an appropriate alternate or remove it entirely.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageTypeTypeParameter">
        <source>On type {0}, replace the term '{1}' in generic type parameter name {2} with the preferred alternate '{3}'.</source>
        <target state="new">On type {0}, replace the term '{1}' in generic type parameter name {2} with the preferred alternate '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageTypeTypeParameterNoAlternate">
        <source>On type {0}, replace the term '{1}' in generic type parameter name {2} with an appropriate alternate or remove it entirely.</source>
        <target state="new">On type {0}, replace the term '{1}' in generic type parameter name {2} with an appropriate alternate or remove it entirely.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsTitle">
        <source>Use preferred terms</source>
        <target state="new">Use preferred terms</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertiesWhereAppropriateDescription">
        <source>A public or protected method has a name that starts with ""Get"", takes no parameters, and returns a value that is not an array. The method might be a good candidate to become a property.</source>
        <target state="new">A public or protected method has a name that starts with ""Get"", takes no parameters, and returns a value that is not an array. The method might be a good candidate to become a property.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertiesWhereAppropriateMessage">
        <source>Use properties where appropriate</source>
        <target state="new">Use properties where appropriate</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertiesWhereAppropriateTitle">
        <source>Use properties where appropriate</source>
        <target state="new">Use properties where appropriate</target>
        <note />
      </trans-unit>
      <trans-unit id="ValidateArgumentsOfPublicMethodsDescription">
        <source>An externally visible method dereferences one of its reference arguments without verifying whether that argument is null (Nothing in Visual Basic). All reference arguments that are passed to externally visible methods should be checked against null. If appropriate, throw an ArgumentNullException when the argument is null or add a Code Contract precondition asserting non-null argument. If the method is designed to be called only by known assemblies, you should make the method internal.</source>
        <target state="new">An externally visible method dereferences one of its reference arguments without verifying whether that argument is null (Nothing in Visual Basic). All reference arguments that are passed to externally visible methods should be checked against null. If appropriate, throw an ArgumentNullException when the argument is null or add a Code Contract precondition asserting non-null argument. If the method is designed to be called only by known assemblies, you should make the method internal.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValidateArgumentsOfPublicMethodsMessage">
        <source>In externally visible method '{0}', validate parameter '{1}' is non-null before using it. If appropriate, throw an ArgumentNullException when the argument is null or add a Code Contract precondition asserting non-null argument.</source>
        <target state="new">In externally visible method '{0}', validate parameter '{1}' is non-null before using it. If appropriate, throw an ArgumentNullException when the argument is null or add a Code Contract precondition asserting non-null argument.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValidateArgumentsOfPublicMethodsTitle">
        <source>Validate arguments of public methods</source>
        <target state="new">Validate arguments of public methods</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesDescription">
        <source>An instance method declares a parameter or a local variable whose name matches an instance field of the declaring type, leading to errors.</source>
        <target state="new">An instance method declares a parameter or a local variable whose name matches an instance field of the declaring type, leading to errors.</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesMessageLocal">
        <source>{0}, a variable declared in {1}, has the same name as an instance field on the type. Change the name of one of these items.</source>
        <target state="new">{0}, a variable declared in {1}, has the same name as an instance field on the type. Change the name of one of these items.</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesMessageParameter">
        <source>{0}, a parameter declared in {1}, has the same name as an instance field on the type. Change the name of one of these items.</source>
        <target state="new">{0}, a parameter declared in {1}, has the same name as an instance field on the type. Change the name of one of these items.</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesTitle">
        <source>Variable names should not match field names</source>
        <target state="new">Variable names should not match field names</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
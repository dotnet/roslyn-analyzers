<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ja" original="../MicrosoftApiDesignGuidelinesAnalyzersResources.resx">
    <body>
      <trans-unit id="AppendConfigureAwaitTrue">
        <source>Append .ConfigureAwait(true)</source>
        <target state="translated">.ConfigureAwait(true) を追加します</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidAsyncVoidTitle">
        <source>Avoid Async Void</source>
        <target state="translated">Async Void を使用しないでください</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidAsyncVoidDescription">
        <source>#N/A</source>
        <target state="translated">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidAsyncVoidMessage">
        <source>Avoid Async Void</source>
        <target state="translated">Async Void を使用しないでください</target>
        <note />
      </trans-unit>
      <trans-unit id="AsyncMethodNamesShouldEndInAsyncTitle">
        <source>Async Method Names Should End in Async</source>
        <target state="translated">非同期メソッド名は Async で終わる必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="AsyncMethodNamesShouldEndInAsyncDescription">
        <source>#N/A</source>
        <target state="translated">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="AsyncMethodNamesShouldEndInAsyncMessage">
        <source>Async Method Names Should End in Async</source>
        <target state="translated">非同期メソッド名は Async で終わる必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchGeneralExceptionTypesDescription">
        <source>A general exception such as System.Exception or System.SystemException is caught in a catch statement, or a general catch clause is used. General exceptions should not be caught.</source>
        <target state="translated">System.Exception または System.SystemException などの一般的な例外は catch ステートメントでキャッチされます。または一般的な catch 句を使用します。一般的な例外をキャッチしないでください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchGeneralExceptionTypesMessage">
        <source>Modify '{0}' to catch a more specific exception type, or rethrow the exception.</source>
        <target state="translated">'{0}' を変更して特定の例外の種類をさらにキャッチするか、例外を再スローします。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchGeneralExceptionTypesTitle">
        <source>Do not catch general exception types</source>
        <target state="translated">一般的な例外の種類はキャッチしません</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassAsyncLambdasAsVoidReturningDelegateTypesTitle">
        <source>Don't Pass Async Lambdas as Void Returning Delegate Types</source>
        <target state="translated">デリゲート型を返す Void として非同期ラムダを渡さないでください</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassAsyncLambdasAsVoidReturningDelegateTypesDescription">
        <source>#N/A</source>
        <target state="translated">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassAsyncLambdasAsVoidReturningDelegateTypesMessage">
        <source>Don't Pass Async Lambdas as Void Returning Delegate Types</source>
        <target state="translated">デリゲート型を返す Void として非同期ラムダを渡さないでください</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPrefixEnumValuesWithTypeNameDescription">
        <source>An enumeration's values should not start with the type name of the enumeration.</source>
        <target state="translated">列挙値は、列挙型名で始まらないようにします。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPrefixEnumValuesWithTypeNameMessage">
        <source>Do not prefix enum values with the name of the enum type '{0}'. </source>
        <target state="translated">列挙値の前に列挙型 '{0}' の名前を付けないでください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPrefixEnumValuesWithTypeNameTitle">
        <source>Do not prefix enum values with type name</source>
        <target state="translated">列挙値の前に型名を付けないでください</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStoreAsyncLambdasAsVoidReturningDelegateTypesTitle">
        <source>Don't Store Async Lambdas as Void Returning Delegate Types</source>
        <target state="translated">デリゲート型を返す Void として非同期ラムダを格納しないでください</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStoreAsyncLambdasAsVoidReturningDelegateTypesDescription">
        <source>#N/A</source>
        <target state="translated">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStoreAsyncLambdasAsVoidReturningDelegateTypesMessage">
        <source>Don't Store Async Lambdas as Void Returning Delegate Types</source>
        <target state="translated">デリゲート型を返す Void として非同期ラムダを格納しないでください</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageFinalizeOverride">
        <source>Remove the finalizer from type '{0}', override Dispose(bool disposing), and put the finalization logic in the code path where 'disposing' is false. Otherwise, it might lead to duplicate Dispose invocations as the Base type '{1}' also provides a finalizer.</source>
        <target state="translated">型 '{0}' からファイナライザーを削除し、Dispose(bool disposing) をオーバーライドします。その後、'disposing' が false のコード パスに finalization 論理を配置します。その他の場合、基本型 '{1}' でもファイナライザーが提供されるため、Dispose 呼び出しが重複する可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="PropagateCancellationTokensWhenPossibleTitle">
        <source>Propagate CancellationTokens When Possible</source>
        <target state="translated">可能な場合は CancellationToken を伝達してください</target>
        <note />
      </trans-unit>
      <trans-unit id="PropagateCancellationTokensWhenPossibleDescription">
        <source>#N/A</source>
        <target state="translated">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="PropagateCancellationTokensWhenPossibleMessage">
        <source>Propagate CancellationTokens When Possible</source>
        <target state="translated">可能な場合は CancellationToken を伝達してください</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMixBlockingAndAsyncTitle">
        <source>Don't Mix Blocking and Async</source>
        <target state="translated">ブロッキングと非同期を組み合わせないでください</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMixBlockingAndAsyncDescription">
        <source>#N/A</source>
        <target state="translated">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMixBlockingAndAsyncMessage">
        <source>Don't Mix Blocking and Async</source>
        <target state="translated">ブロッキングと非同期を組み合わせないでください</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesThatOwnDisposableFieldsShouldBeDisposableTitle">
        <source>Types that own disposable fields should be disposable</source>
        <target state="translated">破棄可能なフィールドを所有する型は、破棄可能でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesThatOwnDisposableFieldsShouldBeDisposableDescription">
        <source>A class declares and implements an instance field that is a System.IDisposable type, and the class does not implement IDisposable. A class that declares an IDisposable field indirectly owns an unmanaged resource and should implement the IDisposable interface.</source>
        <target state="translated">クラスが System.IDisposable 型であるインスタンス フィールドを宣言および実装していますが、IDisposable を実装していません。IDisposable フィールドを宣言するクラスは間接的にアンマネージ リソースを所有しているため、IDisposable インターフェイスを実装する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesThatOwnDisposableFieldsShouldBeDisposableMessageNonBreaking">
        <source>Type '{0}' owns disposable field(s) '{1}' but is not disposable</source>
        <target state="translated">型 '{0}' は破棄可能なフィールド '{1}' を所有しますが、破棄可能ではありません</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesTitle">
        <source>Use generic event handler instances</source>
        <target state="translated">汎用イベント ハンドラーのインスタンスを使用します</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueTitle">
        <source>Enums should have zero value</source>
        <target state="translated">列挙型は 0 値を含んでいなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueDescription">
        <source>The default value of an uninitialized enumeration, just as other value types, is zero. A nonflags-attributed enumeration should define a member by using the value of zero so that the default value is a valid value of the enumeration. If an enumeration that has the FlagsAttribute attribute applied defines a zero-valued member, its name should be ""None"" to indicate that no values have been set in the enumeration.</source>
        <target state="translated">初期化されていない列挙型の既定値は、他の値型と同様に、ゼロです。Flags 属性以外が指定された列挙型では、既定値が有効な列挙値になるように、値 0 を使用してメンバーを定義する必要があります。FlagsAttribute 属性が適用されている列挙型で 0 値のメンバーを定義する場合は、その名前を ""None"" にして、列挙型に値が設定されていないことを示す必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueMessageFlagsRename">
        <source>In enum {0}, change the name of {1} to 'None'.</source>
        <target state="translated">列挙型 {0} では、{1} の名前を 'None' に変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueMessageFlagsMultipleZeros">
        <source>Remove all members that have the value zero from {0} except for one member that is named 'None'.</source>
        <target state="translated">'None' という名前の 1 つのメンバーを除き、値 0 を含むすべてのメンバーを {0} から削除します。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueMessageNotFlagsNoZeroValue">
        <source>Add a member to {0} that has a value of zero with a suggested name of 'None'.</source>
        <target state="translated">提案された名前 'None' を伴う、値 0 を含む {0} にメンバーを追加します。</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypesShouldNotHaveConstructorsTitle">
        <source>Abstract types should not have constructors</source>
        <target state="translated">抽象型はコンストラクターを含むことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypesShouldNotHaveConstructorsDescription">
        <source>Constructors on abstract types can be called only by derived types. Because public constructors create instances of a type, and you cannot create instances of an abstract type, an abstract type that has a public constructor is incorrectly designed.</source>
        <target state="translated">抽象型のコンストラクターは、派生型からのみ呼び出すことができます。パブリック コンストラクターによって型のインスタンスが作成され、抽象型のインスタンスを自分で作成できないため、パブリック コンストラクターを含む抽象型は正しく設計されません。</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypesShouldNotHaveConstructorsMessage">
        <source>Abstract type {0} should not have constructors</source>
        <target state="translated">抽象型 {0} はコンストラクターを含むことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithClsCompliantTitle">
        <source>Mark assemblies with CLSCompliant</source>
        <target state="translated">アセンブリに CLSCompliant を設定します</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithClsCompliantDescription">
        <source>The Common Language Specification (CLS) defines naming restrictions, data types, and rules to which assemblies must conform if they will be used across programming languages. Good design dictates that all assemblies explicitly indicate CLS compliance by using CLSCompliantAttribute . If this attribute is not present on an assembly, the assembly is not compliant.</source>
        <target state="translated">共通言語仕様 (CLS) では、名前付け制限、データ型、規則が定義されています。アセンブリは、複数のプログラミング言語で使用する場合、これらに準拠する必要があります。すべてのアセンブリに CLSCompliantAttribute を使用して CLS への準拠を明示することをお勧めします。この属性がアセンブリに存在しない場合、そのアセンブリは CLS に準拠しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithClsCompliantMessage">
        <source>Mark assemblies with CLSCompliant</source>
        <target state="translated">アセンブリに CLSCompliant を設定します</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithAssemblyVersionTitle">
        <source>Mark assemblies with assembly version</source>
        <target state="translated">アセンブリにアセンブリ バージョンを設定します</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithAssemblyVersionDescription">
        <source>The .NET Framework uses the version number to uniquely identify an assembly, and to bind to types in strongly named assemblies. The version number is used together with version and publisher policy. By default, applications run only with the assembly version with which they were built.</source>
        <target state="translated">.NET Framework では、バージョン番号を使用してアセンブリを一意に識別し、厳密な名前が指定されたアセンブリの型にバインドします。バージョン番号は、バージョンと発行者ポリシーと共に使用されます。既定で、アプリケーションは、ビルドに使用されたアセンブリ バージョンでのみ実行されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithAssemblyVersionMessage">
        <source>Mark assemblies with assembly version</source>
        <target state="translated">アセンブリにアセンブリ バージョンを設定します</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithComVisibleTitle">
        <source>Mark assemblies with ComVisible</source>
        <target state="translated">アセンブリに ComVisible を設定します</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithComVisibleDescription">
        <source>ComVisibleAttribute determines how COM clients access managed code. Good design dictates that assemblies explicitly indicate COM visibility. COM visibility can be set for the whole assembly and then overridden for individual types and type members. If this attribute is not present, the contents of the assembly are visible to COM clients.</source>
        <target state="translated">ComVisibleAttribute によって、COM クライアントからマネージ コードにアクセスする方法を決定します。この場合、アセンブリが COM の参照可能性を明示的に示すことが推奨されます。COM の参照可能性は、アセンブリ全体で設定した後、個々の型と型メンバーに対してオーバーライドできます。この属性が存在しない場合、アセンブリのコンテンツは COM クライアントから参照できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithComVisibleMessageNoAttribute">
        <source>Because {0} exposes externally visible types, mark it with ComVisible(false) at the assembly level and then mark all types within the assembly that should be exposed to COM clients with ComVisible(true).</source>
        <target state="translated">{0} は外部から参照可能な型を公開するため、アセンブリ レベルで ComVisible(false) に設定し、COM クライアントに公開する必要があるアセンブリ内のすべての型を ComVisible(true) に設定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithComVisibleMessageAttributeTrue">
        <source>Consider changing the ComVisible attribute on {0} to false, and opting in at the type level.</source>
        <target state="translated">{0} の ComVisible 属性を false に変更してから、各型レベルで調節することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAttributesWithAttributeUsageTitle">
        <source>Mark attributes with AttributeUsageAttribute</source>
        <target state="translated">属性を AttributeUsageAttribute に設定します</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAttributesWithAttributeUsageDescription">
        <source>When you define a custom attribute, mark it by using AttributeUsageAttribute to indicate where in the source code the custom attribute can be applied. The meaning and intended usage of an attribute will determine its valid locations in code.</source>
        <target state="translated">カスタム属性を定義する場合、AttributeUsageAttribute を使用して、ソース コード内でカスタム属性を適用できる位置を示すように設定します。属性の意味と用途により、コード内での有効な位置が決まります。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAttributesWithAttributeUsageMessageDefault">
        <source>Specify AttributeUsage on {0}.</source>
        <target state="translated">AttributeUsage を {0} で指定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAttributesWithAttributeUsageMessageInherited">
        <source>Even though attribute {0} inherits AttributeUsage from its base type, you should consider explicitly specifying AttributeUsage on the type to improve code readability and documentation.</source>
        <target state="translated">属性 {0} がその基本データ型から AttributeUsage を継承した場合でも、コードの読みやすさ、ドキュメントを改善するために、AttributeUsage をその型で明示的に指定することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineAccessorsForAttributeArgumentsTitle">
        <source>Define accessors for attribute arguments</source>
        <target state="translated">属性引数にアクセサーを定義します</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineAccessorsForAttributeArgumentsDescription">
        <source>Attributes can define mandatory arguments that must be specified when you apply the attribute to a target. These are also known as positional arguments because they are supplied to attribute constructors as positional parameters. For every mandatory argument, the attribute should also provide a corresponding read-only property so that the value of the argument can be retrieved at execution time. Attributes can also define optional arguments, which are also known as named arguments. These arguments are supplied to attribute constructors by name and should have a corresponding read/write property.</source>
        <target state="translated">属性は、対象に適用するときに指定する必要のある必須の引数を定義できます。これらは、属性コンストラクターに位置指定パラメーターとして指定されるため、位置指定引数とも呼ばれます。必須の属性ごとに、属性は、引数の値を実行時に取得できるように、対応する読み取り専用プロパティも提供する必要があります。また、属性は省略可能な引数も定義できます。これは名前付き引数とも呼ばれます。これらの引数は、名前で属性コンストラクターに指定され、対応する読み取り/書き込みプロパティが必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineAccessorsForAttributeArgumentsMessageDefault">
        <source>Add a public read-only property accessor for positional argument {0} of Attribute {1}.</source>
        <target state="translated">属性 {1} の位置引数 {0} 用にパブリックな読み取り専用プロパティ アクセサーを追加します。</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineAccessorsForAttributeArgumentsMessageRemoveSetter">
        <source>Remove the property setter from {0} or reduce its accessibility because it corresponds to positional argument {1}.</source>
        <target state="translated">プロパティ set アクセス操作子が位置引数 {1} に対応しているため、これを {0} から削除するか、アクセシビリティを下げてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineAccessorsForAttributeArgumentsMessageIncreaseVisibility">
        <source>If {0} is the property accessor for positional argument {1}, make it public.</source>
        <target state="translated">{0} が位置引数 {1} のプロパティ アクセサーである場合は、パブリックにしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertiesWhereAppropriateTitle">
        <source>Use properties where appropriate</source>
        <target state="translated">適切な場所にプロパティを使用します</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertiesWhereAppropriateDescription">
        <source>A public or protected method has a name that starts with ""Get"", takes no parameters, and returns a value that is not an array. The method might be a good candidate to become a property.</source>
        <target state="translated">パブリック メソッドまたは保護されたメソッドは、""Get"" で始まる名前を持ち、パラメーターを受け取らず、配列ではない値を返します。このメソッドは、プロパティに変更できる可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertiesWhereAppropriateMessage">
        <source>Use properties where appropriate</source>
        <target state="translated">適切な場所にプロパティを使用します</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkEnumsWithFlagsTitle">
        <source>Mark enums with FlagsAttribute</source>
        <target state="translated">列挙型を FlagsAttribute に設定します</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkEnumsWithFlagsDescription">
        <source>An enumeration is a value type that defines a set of related named constants. Apply FlagsAttribute to an enumeration when its named constants can be meaningfully combined.</source>
        <target state="translated">列挙型は、関連する一連の名前付き定数を定義する値型です。名前付き定数を意味を持つように組み合わせることができる場合は、列挙型に FlagsAttribute を適用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkEnumsWithFlagsMessage">
        <source>Mark enums with FlagsAttribute</source>
        <target state="translated">列挙型を FlagsAttribute に設定します</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesTitle">
        <source>Interface methods should be callable by child types</source>
        <target state="translated">インターフェイス メソッドは、子型によって呼び出し可能でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesDescription">
        <source>An unsealed externally visible type provides an explicit method implementation of a public interface and does not provide an alternative externally visible method that has the same name.</source>
        <target state="translated">外部から参照可能なアンシールド型により、メソッドによるパブリック インターフェイスの明示的な実装が提供されます。また、同じ名前が付いた外部から参照可能な代替のメソッドは提供されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesMessage">
        <source>Make '{0}' sealed (a breaking change if this class has previously shipped), implement the method non-explicitly, or implement a new method that exposes the functionality of '{1}' and is visible to derived classes.</source>
        <target state="translated">'{0}' をシールドにするか (このクラスが以前に出荷されている場合は重大な変更)、メソッドを非明示的に実装するか、'{1}' の機能を公開して派生クラスに表示される新しいメソッドを実装します。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesTitle">
        <source>Override methods on comparable types</source>
        <target state="translated">比較可能な型でメソッドをオーバーライドします</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesDescription">
        <source>A public or protected type implements the System.IComparable interface. It does not override Object.Equals nor does it overload the language-specific operator for equality, inequality, less than, less than or equal, greater than or greater than or equal.</source>
        <target state="translated">パブリック型または保護された型で System.IComparable インターフェイスを実装します。これにより、Object.Equals はオーバーライドされません。また、"等しい"、"等しくない"、"未満"、"以下"、"より大きい"、または "以上" を示す言語固有の演算子はオーバーロードされません。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesMessageEquals">
        <source>{0} should override Equals since it implements IComparable.</source>
        <target state="translated">{0} は、IComparable を実装しているため、Equals をオーバーライドしなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesMessageOperator">
        <source>{0} should define operator(s) '{1}' since it implements IComparable.</source>
        <target state="translated">{0} は、IComparable を実装しているため、演算子 '{1}' を定義しなければなりません。</target>
        <note>1 is a comma-separated list</note>
      </trans-unit>
      <trans-unit id="MovePInvokesToNativeMethodsClassTitle">
        <source>Move pinvokes to native methods class</source>
        <target state="translated">pinvoke をネイティブ メソッド クラスに移動します</target>
        <note />
      </trans-unit>
      <trans-unit id="MovePInvokesToNativeMethodsClassDescription">
        <source>Platform Invocation methods, such as those that are marked by using the System.Runtime.InteropServices.DllImportAttribute attribute, or methods that are defined by using the Declare keyword in Visual Basic, access unmanaged code. These methods should be of the NativeMethods, SafeNativeMethods, or UnsafeNativeMethods class.</source>
        <target state="translated">プラットフォーム呼び出しメソッド (System.Runtime.InteropServices.DllImportAttribute 属性を使用してマークされているメソッドなど) または Visual Basic で Declare キーワードを使用して定義されているメソッドが、アンマネージ コードにアクセスしています。これらのメソッドは、NativeMethods、SafeNativeMethods、または UnsafeNativeMethods クラスに属している必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="MovePInvokesToNativeMethodsClassMessage">
        <source>Move pinvokes to native methods class</source>
        <target state="translated">pinvoke をネイティブ メソッド クラスに移動します</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldDifferByMoreThanCaseTitle">
        <source>Identifiers should differ by more than case</source>
        <target state="translated">識別子は、大文字と小文字の区別以外にも相違していなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldDifferByMoreThanCaseDescription">
        <source>Identifiers for namespaces, types, members, and parameters cannot differ only by case because languages that target the common language runtime are not required to be case-sensitive.</source>
        <target state="translated">名前空間、型、メンバー、およびパラメーターの識別子は、大文字/小文字だけを変更しても区別できません。共通言語ランタイムを対象とする言語は、大文字と小文字を区別する必要がないためです。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldDifferByMoreThanCaseMessage">
        <source>Names of '{0}' and '{1}' should differ by more than case.</source>
        <target state="translated">名前 '{0}' および '{1}' は、大文字と小文字の区別以外にも相違させる必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectPrefixTitle">
        <source>Identifiers should have correct prefix</source>
        <target state="translated">識別子は正しいプレフィックスを含んでいなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectPrefixDescription">
        <source>The name of an externally visible interface does not start with an uppercase ""I"". The name of a generic type parameter on an externally visible type or method does not start with an uppercase ""T"".</source>
        <target state="translated">外部から参照可能なインターフェイスの名前は大文字の ""I"" で始まりません。外部から参照可能な型またはメソッドのジェネリック型パラメーターの名前は大文字の ""T"" で始まりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectPrefixMessageInterface">
        <source>Prefix interface name {0} with 'I'.</source>
        <target state="translated">インターフェイス名 {0} にプレフィックスとして 'I' を指定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectPrefixMessageTypeParameter">
        <source>Prefix generic type parameter name {0} with 'T'.</source>
        <target state="translated">ジェネリック型パラメーター名 {0} にプレフィックスとして 'T' を指定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="NonConstantFieldsShouldNotBeVisibleTitle">
        <source>Non-constant fields should not be visible</source>
        <target state="translated">非定数フィールドは表示されません</target>
        <note />
      </trans-unit>
      <trans-unit id="NonConstantFieldsShouldNotBeVisibleDescription">
        <source>Static fields that are neither constants nor read-only are not thread-safe. Access to such a field must be carefully controlled and requires advanced programming techniques to synchronize access to the class object.</source>
        <target state="translated">定数でも読み取り専用でもない静的フィールドは、スレッドセーフではありません。このようなフィールドへのアクセスは慎重に制御する必要があります。また、クラス オブジェクトへのアクセスを同期するには、高度なプログラミング技術が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="NonConstantFieldsShouldNotBeVisibleMessage">
        <source>Non-constant fields should not be visible</source>
        <target state="translated">非定数フィールドは表示されません</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkEnumsWithFlagsTitle">
        <source>Do not mark enums with FlagsAttribute</source>
        <target state="translated">列挙型を FlagsAttribute に設定しません</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkEnumsWithFlagsDescription">
        <source>An externally visible enumeration is marked by using FlagsAttribute, and it has one or more values that are not powers of two or a combination of the other defined values on the enumeration.</source>
        <target state="translated">外部から参照可能な列挙型が FlagsAttribute を使用してマークされ、その列挙型に、2 の累乗でもその列挙型で定義されている他の値の組み合わせでもない値が 1 つ以上含まれています。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkEnumsWithFlagsMessage">
        <source>Do not mark enums with FlagsAttribute</source>
        <target state="translated">列挙型を FlagsAttribute に設定しません</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesTitle">
        <source>Operator overloads have named alternates</source>
        <target state="translated">演算子オーバーロードには名前付けされた代替が存在します</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesDescription">
        <source>An operator overload was detected, and the expected named alternative method was not found. The named alternative member provides access to the same functionality as the operator and is provided for developers who program in languages that do not support overloaded operators.</source>
        <target state="translated">演算子オーバーロードが検出され、予想される名前の代替メソッドが検出されませんでした。名前付きの代替メンバーは、演算子と同じ機能へアクセスを提供し、オーバーロードされた演算子をサポートしていない言語でプログラミングを行う開発者にも提供されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesMessageDefault">
        <source>Provide a method named '{0}' as a friendly alternate for operator {1}.</source>
        <target state="translated">'{0}' という名前のメソッドを演算子 {1} の代替として指定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesMessageProperty">
        <source>Provide a property named '{0}' as a friendly alternate for operator {1}.</source>
        <target state="translated">'{0}' という名前のプロパティを演算子 {1} の代替として指定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesMessageMultiple">
        <source>Provide a method named '{0}' or '{1}' as an alternate for operator {2}.</source>
        <target state="translated">'{0}' または '{1}' という名前のメソッドを演算子 {2} の代替として指定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesMessageVisibility">
        <source>Mark {0} as public because it is a friendly alternate for operator {1}.</source>
        <target state="translated">演算子 {1} の代替であるため {0} をパブリックに設定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorsShouldHaveSymmetricalOverloadsTitle">
        <source>Operators should have symmetrical overloads</source>
        <target state="translated">演算子は対称型オーバーロードを含まなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorsShouldHaveSymmetricalOverloadsDescription">
        <source>A type implements the equality or inequality operator and does not implement the opposite operator.</source>
        <target state="translated">型で等値演算子または非等値演算子を実装し、逆の働きをする演算子を実装しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorsShouldHaveSymmetricalOverloadsMessage">
        <source>Operators should have symmetrical overloads</source>
        <target state="translated">演算子は対称型オーバーロードを含まなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionPropertiesShouldBeReadOnlyTitle">
        <source>Collection properties should be read only</source>
        <target state="translated">コレクション プロパティは読み取り専用でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionPropertiesShouldBeReadOnlyDescription">
        <source>A writable collection property allows a user to replace the collection with a different collection. A read-only property stops the collection from being replaced but still allows the individual members to be set.</source>
        <target state="translated">書き込み可能なコレクション プロパティにより、ユーザーはコレクションを別のコレクションに置き換えることができます。読み取り専用のプロパティでは、コレクションを置き換えることはできませんが、引き続き個々のメンバーは設定できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionPropertiesShouldBeReadOnlyMessage">
        <source>Change '{0}' to be read-only by removing the property setter.</source>
        <target state="translated">プロパティ set アクセス操作子を削除して '{0}' を読み取り専用に変更します。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverloadOperatorEqualsOnOverridingValueTypeEqualsTitle">
        <source>Overload operator equals on overriding value type Equals</source>
        <target state="translated">値型 Equals のオーバーライドで、演算子 equals をオーバーロードします</target>
        <note />
      </trans-unit>
      <trans-unit id="OverloadOperatorEqualsOnOverridingValueTypeEqualsDescription">
        <source>In most programming languages there is no default implementation of the equality operator (==) for value types. If your programming language supports operator overloads, you should consider implementing the equality operator. Its behavior should be identical to that of Equals</source>
        <target state="translated">ほとんどのプログラミング言語では、値型に対する等値演算子 (==) の既定の実装がありません。プログラミング言語で演算子のオーバーロードがサポートされている場合は、等値演算子の実装を検討してください。その動作は、Equals の動作と同じである必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="OverloadOperatorEqualsOnOverridingValueTypeEqualsMessage">
        <source>Overload operator equals on overriding value type Equals</source>
        <target state="translated">値型 Equals のオーバーライドで、演算子 equals をオーバーロードします</target>
        <note />
      </trans-unit>
      <trans-unit id="PassSystemUriObjectsInsteadOfStringsTitle">
        <source>Pass system uri objects instead of strings</source>
        <target state="translated">文字列ではなくシステム uri オブジェクトを渡します</target>
        <note />
      </trans-unit>
      <trans-unit id="PassSystemUriObjectsInsteadOfStringsDescription">
        <source>A call is made to a method that has a string parameter whose name contains "uri", "URI", "urn", "URN", "url", or "URL". The declaring type of the method contains a corresponding method overload that has a System.Uri parameter.</source>
        <target state="translated">名前に "uri"、"URI"、"urn"、"URN"、"url"、または "URL" が含まれている文字列パラメーターが指定されたメソッドが呼び出されます。そのメソッドの宣言する型には、System.Uri パラメーターが指定されている対応するメソッド オーバーロードが含まれています。</target>
        <note />
      </trans-unit>
      <trans-unit id="PassSystemUriObjectsInsteadOfStringsMessage">
        <source>Modify '{0}' to call '{1}' instead of '{2}'.</source>
        <target state="translated">'{2}' ではなく '{1}' を呼び出すように '{0}' を変更します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIEquatableWhenOverridingObjectEqualsTitle">
        <source>Type {0} should implement IEquatable&lt;T&gt; because it overrides Equals</source>
        <target state="translated">型 {0} は Equals をオーバーライドするため、IEquatable&lt;T&gt; を実装する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIEquatableWhenOverridingObjectEqualsMessage">
        <source>Implement IEquatable when overriding Object.Equals</source>
        <target state="translated">Object.Equals をオーバーライドする際に IEquatable を実装します</target>
        <note />
      </trans-unit>
      <trans-unit id="CancellationTokenParametersMustComeLastTitle">
        <source>CancellationToken parameters must come last</source>
        <target state="translated">CancellationToken パラメーターは最後に指定する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="CancellationTokenParametersMustComeLastMessage">
        <source>Method '{0}' should take CancellationToken as the last parameter</source>
        <target state="translated">メソッド '{0}' は、CancellationToken を最後のパラメーターとして受け取る必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstructorMakeNoninheritableBaseClassInheritableTitle">
        <source>Constructor make noninheritable base class inheritable</source>
        <target state="translated">コンストラクターにより、継承不可能な基底クラスが継承可能になります</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstructorMakeNoninheritableBaseClassInheritableDescription">
        <source>When a base class is noninheritable because its constructor is internal, a derived class should not make it inheritable by having a public or protected constructor.</source>
        <target state="translated">コンストラクターが内部であるために基底クラスが継承不可能な場合は、派生クラスは、パブリック コンストラクターまたは保護されたコンストラクターを設定して基底クラスを継承可能にしないでください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstructorMakeNoninheritableBaseClassInheritableMessage">
        <source>Constructor make noninheritable base class inheritable</source>
        <target state="translated">コンストラクターにより、継承不可能な基底クラスが継承可能になります</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainTypeNamesTitle">
        <source>Identifier contains type name</source>
        <target state="translated">識別子に型名が含まれます</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainTypeNamesDescription">
        <source>Names of parameters and members are better used to communicate their meaning than to describe their type, which is expected to be provided by development tools. For names of members, if a data type name must be used, use a language-independent name instead of a language-specific one.</source>
        <target state="translated">パラメーターとメンバーの名前では、パラメーターとメンバーの型ではなく意味を伝えるようにします。パラメーターとメンバーの型は、開発ツールで表示されるためです。メンバー名では、データ型名を使用する必要がある場合、言語固有の名前ではなく、言語に依存しない名前を使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainTypeNamesMessage">
        <source>Identifier '{0}' contains type name</source>
        <target state="translated">識別子 '{0}' に型名が含まれます</target>
        <note />
      </trans-unit>
      <trans-unit id="CreatePropertyAccessorForParameter">
        <source>Create a property accessor.</source>
        <target state="translated">プロパティ アクセサーを作成します。</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeGetterPublic">
        <source>Make the getter of the property public</source>
        <target state="translated">プロパティのゲッターをパブリックにします</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeSetterNonPublic">
        <source>Make the setter of the property non-public</source>
        <target state="translated">プロパティのセッターを非パブリックにします</target>
        <note />
      </trans-unit>
      <trans-unit id="AddAssemblyLevelComVisibleFalse">
        <source>Because {0} exposes externally visible types, mark it with ComVisible(false) at the assembly level and then mark all types within the assembly that should be exposed to COM clients with ComVisible(true).</source>
        <target state="translated">{0} は外部から参照可能な型を公開するため、アセンブリ レベルで ComVisible(false) に設定し、COM クライアントに公開する必要があるアセンブリ内のすべての型を ComVisible(true) に設定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ChangeAssemblyLevelComVisibleToFalse">
        <source>Consider changing the ComVisible attribute on {0} to false, and opting in at the type level.</source>
        <target state="translated">{0} の ComVisible 属性を false に変更してから、各型レベルで調節することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementComparable">
        <source>Implement Equality and Comparison methods and operators</source>
        <target state="translated">等値および比較メソッドおよび演算子を実装します</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementEquatable">
        <source>Implement IEquatable</source>
        <target state="translated">IEquatable を実装します</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableInterface">
        <source>Implement IDisposable Interface</source>
        <target state="translated">IDisposable インターフェイスを実装します</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkEnumsWithFlagsCodeFix">
        <source>Remove FlagsAttribute from enum.</source>
        <target state="translated">FlagsAttribute を列挙型から削除します。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkEnumsWithFlagsCodeFix">
        <source>Apply FlagsAttribute to enum.</source>
        <target state="translated">FlagsAttribute を列挙型に適用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldZeroValueFlagsMultipleZeroCodeFix">
        <source>Remove all members that have the value zero except for one member that is named 'None'.</source>
        <target state="translated">'None' という名前の 1 つのメンバー以外の、値 0 を含むすべてのメンバーを削除します。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldZeroValueFlagsRenameCodeFix">
        <source>Rename zero-valued enum field to 'None'.</source>
        <target state="translated">0 値の列挙型フィールドの名前を 'None' に変更します。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldZeroValueNotFlagsNoZeroValueCodeFix">
        <source>Add a zero-valued member 'None' to enum.</source>
        <target state="translated">0 値のメンバー 'None' を列挙型に追加します。</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypesShouldNotHavePublicConstructorsCodeFix">
        <source>Change the accessibility of public constructors to protected.</source>
        <target state="translated">パブリック コンストラクターのアクセシビリティを protected に変更します。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareStaticMembersOnGenericTypesTitle">
        <source>Do not declare static members on generic types</source>
        <target state="translated">ジェネリック型の静的メンバーを宣言しません</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareStaticMembersOnGenericTypesDescription">
        <source>When a static member of a generic type is called, the type argument must be specified for the type. When a generic instance member that does not support inference is called, the type argument must be specified for the member. In these two cases, the syntax for specifying the type argument is different and easily confused.</source>
        <target state="translated">ジェネリック型の静的メンバーを呼び出すときには、その型の型引数も指定する必要があります。推論をサポートしない汎用インスタンス メンバーが呼び出されるときに、そのメンバーに型引数を指定する必要があります。この 2 つのケースでは、型引数を指定するための構文は異なりますが、混同されることがあります。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareStaticMembersOnGenericTypesMessage">
        <source>Do not declare static members on generic types</source>
        <target state="translated">ジェネリック型の静的メンバーを宣言しません</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionsShouldImplementGenericInterfaceTitle">
        <source>Collections should implement generic interface</source>
        <target state="translated">コレクションは、ジェネリック インターフェイスを実装しなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionsShouldImplementGenericInterfaceDescription">
        <source>To broaden the usability of a collection, implement one of the generic collection interfaces. Then the collection can be used to populate generic collection types.</source>
        <target state="translated">コレクションの操作性を拡充するために、ジェネリック コレクション インターフェイスの 1 つを実装します。次に、コレクションを使用して、ジェネリック コレクション型を設定できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionsShouldImplementGenericInterfaceMessage">
        <source>Collection '{0}' directly or indirectly inherits '{1}' without implementing '{2}'. Publicly-visible collections should implement the generic version to broaden usability.</source>
        <target state="translated">コレクション '{0}' は、'{2}' を実装することなく '{1}' を直接または間接的に継承します。公開されているコレクションは、操作性の拡充のためジェネリック バージョンを実装する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumStorageShouldBeInt32Title">
        <source>Enum Storage should be Int32</source>
        <target state="translated">列挙ストレージは Int32 でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumStorageShouldBeInt32Description">
        <source>An enumeration is a value type that defines a set of related named constants. By default, the System.Int32 data type is used to store the constant value. Although you can change this underlying type, it is not required or recommended for most scenarios.</source>
        <target state="translated">列挙型は、関連する一連の名前付き定数を定義する値型です。既定では、System.Int32 データ型は、定数値の格納に使用されます。この基になる型を変更することはできますが、ほとんどの場合、変更する必要はなく、また推奨もされません。</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumStorageShouldBeInt32Message">
        <source>If possible, make the underlying type of {0} System.Int32 instead of {1}.</source>
        <target state="translated">可能な場合は、基になる型 {0} を {1} ではなく System.Int32 にしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEventsWhereAppropriateTitle">
        <source>Use events where appropriate</source>
        <target state="translated">適切な場所にイベントを使用します</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEventsWhereAppropriateDescription">
        <source>This rule detects methods that have names that ordinarily would be used for events. If a method is called in response to a clearly defined state change, the method should be invoked by an event handler. Objects that call the method should raise events instead of calling the method directly.</source>
        <target state="translated">この規則では、通常はイベントに使用される名前の付いたメソッドを検出します。明示的に定義された状態変化に応答してメソッドが呼び出される場合、メソッドはイベント ハンドラーから呼び出す必要があります。メソッドを呼び出すオブジェクトは、メソッドを直接呼び出すのではなく、イベントを発生させる必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEventsWhereAppropriateMessage">
        <source>Consider making '{0}' an event.</source>
        <target state="translated">'{0}' をイベントにすることを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementStandardExceptionConstructorsTitle">
        <source>Implement standard exception constructors</source>
        <target state="translated">標準例外コンストラクターを実装します</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementStandardExceptionConstructorsDescription">
        <source>Failure to provide the full set of constructors can make it difficult to correctly handle exceptions.</source>
        <target state="translated">すべてのコンストラクターを指定できなかった場合、例外を正しく処理することが困難になる可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementStandardExceptionConstructorsMessageMissingConstructor">
        <source>Add the following constructor to {0}: {1}.</source>
        <target state="translated">次のコンストラクターを {0} に追加します: {1}。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementStandardExceptionConstructorsMessageAccessibility">
        <source>Change the accessibility of {0} to {1}.</source>
        <target state="translated">{0} のアクセシビリティを {1} に変更します。</target>
        <note />
      </trans-unit>
      <trans-unit id="NestedTypesShouldNotBeVisibleTitle">
        <source>Nested types should not be visible</source>
        <target state="translated">入れ子にされた型を参照可能にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="NestedTypesShouldNotBeVisibleDescription">
        <source>A nested type is a type that is declared in the scope of another type. Nested types are useful to encapsulate private implementation details of the containing type. Used for this purpose, nested types should not be externally visible.</source>
        <target state="translated">入れ子にされた型とは、別の型のスコープ内で宣言された型のことです。入れ子にされた型は、それを含む型のプライベート実装の詳細をカプセル化するときに便利です。このような用途のため、入れ子にされた型は外部から参照できないようにします。</target>
        <note />
      </trans-unit>
      <trans-unit id="NestedTypesShouldNotBeVisibleMessageDefault">
        <source>Do not nest type {0}. Alternatively, change its accessibility so that it is not externally visible.</source>
        <target state="translated">型 {0} を入れ子にしないでください。外部から参照できなくするために、そのアクセシビリティを変更することもできます。</target>
        <note />
      </trans-unit>
      <trans-unit id="NestedTypesShouldNotBeVisibleMessageVisualBasicModule">
        <source>Do not nest type {0}. Alternatively, change its accessibility so that it is not externally visible. If this type is defined in a Visual Basic Module, it will be considered a nested type to other .NET languages. In that case, consider moving the type outside of the Module.</source>
        <target state="translated">型 {0} を入れ子にしないでください。外部から参照できなくするために、そのアクセシビリティを変更することもできます。この型は、Visual Basic モジュールで定義されている場合、他の .NET 言語への入れ子にされた型と見なされます。その場合、その型をモジュールの外部へ移動することを検討してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidEmptyInterfacesTitle">
        <source>Avoid empty interfaces</source>
        <target state="translated">空のインターフェイスは使用しません</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidEmptyInterfacesDescription">
        <source>Interfaces define members that provide a behavior or usage contract. The functionality that is described by the interface can be adopted by any type, regardless of where the type appears in the inheritance hierarchy. A type implements an interface by providing implementations for the members of the interface. An empty interface does not define any members; therefore, it does not define a contract that can be implemented.</source>
        <target state="translated">インターフェイスは、動作や使用のコントラクトを提供するメンバーを定義します。インターフェイスで示される機能は、継承階層内に型が存在するかどうかにかかわらず、どの型からも適用できます。型ではインターフェイスのメンバーに実装を提供することで、インターフェイスが実装されます。空のインターフェイスではメンバーが定義されません。そのため、実装できるコントラクトも定義されません。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidEmptyInterfacesMessage">
        <source>Avoid empty interfaces</source>
        <target state="translated">空のインターフェイスは使用しません</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideObsoleteAttributeMessageTitle">
        <source>Provide ObsoleteAttribute message</source>
        <target state="translated">ObsoleteAttribute メッセージを指定します</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideObsoleteAttributeMessageDescription">
        <source>A type or member is marked by using a System.ObsoleteAttribute attribute that does not have its ObsoleteAttribute.Message property specified. When a type or member that is marked by using ObsoleteAttribute is compiled, the Message property of the attribute is displayed. This gives the user information about the obsolete type or member.</source>
        <target state="translated">型またはメンバーが System.ObsoleteAttribute 属性でマークされていますが、この属性では ObsoleteAttribute.Message プロパティが指定されていません。ObsoleteAttribute でマークされている型またはメンバーをコンパイルすると、属性の Message プロパティが表示されます。これにより、古いの型またはメンバーに関する情報がユーザーに表示されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideObsoleteAttributeMessageMessage">
        <source>Provide a message for the ObsoleteAttribute that marks {0} as Obsolete</source>
        <target state="translated">{0} を Obsolete に設定する ObsoleteAttribute のメッセージを指定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotBeWriteOnlyTitle">
        <source>Properties should not be write only</source>
        <target state="translated">プロパティを書き込み専用にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotBeWriteOnlyDescription">
        <source>Although it is acceptable and often necessary to have a read-only property, the design guidelines prohibit the use of write-only properties. This is because letting a user set a value, and then preventing the user from viewing that value, does not provide any security. Also, without read access, the state of shared objects cannot be viewed, which limits their usefulness.</source>
        <target state="translated">これは許容されており、読み取り専用プロパティが必要になる場合もよくありますが、デザイン ガイドラインでは、書き込み専用プロパティの使用が禁止されています。これは、ユーザーが値を設定した後にその値を参照できないようにすると、セキュリティが確保されないためです。また、読み取りアクセスがないと、共有オブジェクトのステータスを参照できないため、実用性が制限されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotBeWriteOnlyMessageAddGetter">
        <source>Because property {0} is write-only, either add a property getter with an accessibility that is greater than or equal to its setter or convert this property into a method.</source>
        <target state="translated">プロパティ {0} は書き込み専用であるため、アクセシビリティがプロパティ セッター以上のプロパティ ゲッターを追加するか、このプロパティをメソッドに変換してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotBeWriteOnlyMessageMakeMoreAccessible">
        <source>Because the property getter for {0} is less visible than its setter, either increase the accessibility of its getter or decrease the accessibility of its setter.</source>
        <target state="translated">{0} のプロパティ ゲッターがプロパティ セッターよりも参照範囲が小さいため、ゲッターのアクセシビリティを上げるか、セッターのアクセシビリティを下げてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DeclareTypesInNamespacesTitle">
        <source>Declare types in namespaces</source>
        <target state="translated">名前空間で型を宣言します</target>
        <note />
      </trans-unit>
      <trans-unit id="DeclareTypesInNamespacesDescription">
        <source>Types are declared in namespaces to prevent name collisions and as a way to organize related types in an object hierarchy.</source>
        <target state="translated">型を名前空間内で宣言するのは、名前の競合を防ぎ、関連する型をオブジェクト階層で編成するためです。</target>
        <note />
      </trans-unit>
      <trans-unit id="DeclareTypesInNamespacesMessage">
        <source>Declare types in namespaces</source>
        <target state="translated">名前空間で型を宣言します</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareVisibleInstanceFieldsTitle">
        <source>Do not declare visible instance fields</source>
        <target state="translated">参照可能なインスタンス フィールドを宣言しません</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareVisibleInstanceFieldsDescription">
        <source>The primary use of a field should be as an implementation detail. Fields should be private or internal and should be exposed by using properties.</source>
        <target state="translated">フィールドの主な用途は、実装の詳細を示すことです。フィールドは private または internal に設定し、プロパティを使用して公開する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareVisibleInstanceFieldsMessage">
        <source>Do not declare visible instance fields</source>
        <target state="translated">参照可能なインスタンス フィールドを宣言しません</target>
        <note />
      </trans-unit>
      <trans-unit id="UriParametersShouldNotBeStringsTitle">
        <source>Uri parameters should not be strings</source>
        <target state="translated">URI パラメーターを文字列にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="UriParametersShouldNotBeStringsDescription">
        <source>If a method takes a string representation of a URI, a corresponding overload should be provided that takes an instance of the URI class, which provides these services in a safe and secure manner.</source>
        <target state="translated">メソッドで URI の文字列表現を使用する場合、URI クラスのインスタンスを取得する、対応するオーバーロードを指定する必要があります。これにより、安全な方法でこれらのサービスが提供されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="UriParametersShouldNotBeStringsMessage">
        <source>Change the type of parameter {0} of method {1} from string to System.Uri, or provide an overload to {1} that allows {0} to be passed as a System.Uri object.</source>
        <target state="translated">メソッド {1} のパラメーター {0} の型を文字列から System.Uri に変更するか、または {1} のオーバーロードを指定してください。そうすると、{0} を System.Uri オブジェクトとして渡すことができます。</target>
        <note />
      </trans-unit>
      <trans-unit id="UriReturnValuesShouldNotBeStringsTitle">
        <source>Uri return values should not be strings</source>
        <target state="translated">URI 戻り値を文字列にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="UriReturnValuesShouldNotBeStringsDescription">
        <source>This rule assumes that the method returns a URI. A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner.</source>
        <target state="translated">この規則では、メソッドから URI が返されることを前提としています。URI の文字列表現は解析エラーやエンコーディング エラーが発生しやすく、セキュリティ上の脆弱性の原因となる場合があります。System.Uri クラスを使用すると、安全な方法でこれらのサービスが提供されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="UriReturnValuesShouldNotBeStringsMessage">
        <source>Change the return type of method {0} from string to System.Uri.</source>
        <target state="translated">メソッド {0} の戻り値の型を文字列から System.Uri に変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="UriPropertiesShouldNotBeStringsTitle">
        <source>Uri properties should not be strings</source>
        <target state="translated">URI プロパティを文字列にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="UriPropertiesShouldNotBeStringsDescription">
        <source>This rule assumes that the property represents a Uniform Resource Identifier (URI). A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner.</source>
        <target state="translated">この規則では、プロパティが Uniform Resource Identifier (URI) を表すことを前提としています。URI の文字列表現は解析エラーやエンコーディング エラーが発生しやすく、セキュリティ上の脆弱性の原因となる場合があります。System.Uri クラスを使用すると、安全な方法でこれらのサービスが提供されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="UriPropertiesShouldNotBeStringsMessage">
        <source>Change the type of property {0} from string to System.Uri.</source>
        <target state="translated">プロパティ {0} の型を文字列から System.Uri に変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyTitle">
        <source>Implement IDisposable Correctly</source>
        <target state="translated">IDisposable を正しく実装します</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyDescription">
        <source>All IDisposable types should implement the Dispose pattern correctly.</source>
        <target state="translated">すべての IDisposable 型は、Dispose パターンを正しく実装しなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageIDisposableReimplementation">
        <source>Remove IDisposable from the list of interfaces implemented by '{0}' as it is already implemented by base type '{1}'.</source>
        <target state="translated">'{0}' によって実行されたインターフェイスの一覧から IDisposable を削除します。基本型 '{1}' によって既に実装されているためです。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageDisposeOverride">
        <source>Remove '{0}', override Dispose(bool disposing), and put the dispose logic in the code path where 'disposing' is true.</source>
        <target state="translated">'{0}' を削除し、Dispose(bool disposing) をオーバーライドします。その後、'disposing' が true のコード パスで dispose 論理を配置します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageDisposeSignature">
        <source>Ensure that '{0}' is declared as public and sealed.</source>
        <target state="translated">'{0}' が public および sealed.として宣言されていることを確認します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageRenameDispose">
        <source>Rename '{0}' to 'Dispose' and ensure that it is declared as public and sealed.</source>
        <target state="translated">名前を '{0}' から 'Dispose' に変更し、public および sealed として宣言されていることを確認します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageDisposeBoolSignature">
        <source>Ensure that '{0}' is declared as protected, virtual, and unsealed.</source>
        <target state="translated">'{0}' が protected、virtual、unsealed として宣言されていることを確認します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageDisposeImplementation">
        <source>Modify '{0}' so that it calls Dispose(true), then calls GC.SuppressFinalize on the current object instance ('this' or 'Me' in Visual Basic), and then returns.</source>
        <target state="translated">'{0}' を変更し、Dispose(true) を呼び出したのちに現在のオブジェクト インスタンスで GC.SuppressFinalize (Visual Basic の 'this' または 'Me') を呼び出して、結果を戻すようにします。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageFinalizeImplementation">
        <source>Modify '{0}' so that it calls Dispose(false) and then returns.</source>
        <target state="translated">'{0}' を変更し、Dispose(false) を呼び出して結果を返すようにします。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageProvideDisposeBool">
        <source>Provide an overridable implementation of Dispose(bool) on '{0}' or mark the type as sealed. A call to Dispose(false) should only clean up native resources. A call to Dispose(true) should clean up both managed and native resources.</source>
        <target state="translated">'{0}' で Dispose(bool) のオーバーライド可能な実装を提供するか、型を sealed としてマークします。Dispose(false) を呼び出す場合は、ネイティブ リソースのみがクリーンアップされます。Dispose(true) を呼び出す場合には、マネージド リソースとネイティブ リソースの両方がクリーンアップされます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionsShouldBePublicTitle">
        <source>Exceptions should be public</source>
        <target state="translated">例外は public として設定する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionsShouldBePublicDescription">
        <source>An internal exception is visible only inside its own internal scope. After the exception falls outside the internal scope, only the base exception can be used to catch the exception. If the internal exception is inherited from T:System.Exception, T:System.SystemException, or T:System.ApplicationException, the external code will not have sufficient information to know what to do with the exception.</source>
        <target state="translated">内部例外を参照できるのは、それ独自の内部スコープ内でのみです。例外が内部スコープ外にあると、基本例外を使用しなければキャッチできません。内部例外が System.Exception、System.SystemException、または System.ApplicationException から継承されている場合、外部コードはその例外の処理に関する十分な情報を取得できません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionsShouldBePublicMessage">
        <source>Exceptions should be public</source>
        <target state="translated">例外は public として設定する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsTitle">
        <source>Do not raise exceptions in unexpected locations</source>
        <target state="translated">予期しない場所に例外を発生させません</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsDescription">
        <source>A method that is not expected to throw exceptions throws an exception.</source>
        <target state="translated">例外をスローすることが想定されていないメソッドが例外をスローします。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsMessagePropertyGetter">
        <source>{0} creates an exception of type {1}, an exception type that should not be raised in a property. If this exception instance might be raised, use a different exception type, convert this property into a method, or change this property's logic so that it no longer raises an exception.</source>
        <target state="translated">{0} は型 {1} の例外を作成します。これは、プロパティで発生させることができない例外の種類です。この例外インスタンスが発生する可能性がある場合は、別の例外の種類を使用するか、このプロパティをメソッドに変換するか、例外が発生しないようにこのプロパティのロジックを変更します。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsMessageHasAllowedExceptions">
        <source>{0} creates an exception of type {1}, an exception type that should not be raised in this type of method. If this exception instance might be raised, either use a different exception type or change this method's logic so that it no longer raises an exception.</source>
        <target state="translated">{0} は型 {1} の例外を作成します。これは、この型のメソッドで発生させることができない例外の種類です。この例外インスタンスが発生する可能性がある場合は、別の例外の種類を使用するか、例外が発生しないようにこのメソッドのロジックを変更します。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsMessageNoAllowedExceptions">
        <source>{0} creates an exception of type {1}. Exceptions should not be raised in this type of method. If this exception instance might be raised, change this method's logic so it no longer raises an exception.</source>
        <target state="translated">{0} は型 {1} の例外を作成します。この型のメソッドでは例外を発生させることはできません。この例外インスタンスが発生する可能性がある場合は、例外が発生しないようにこのメソッドのロジックを変更します。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresTitle">
        <source>Identifiers should not contain underscores</source>
        <target state="translated">識別子はアンダースコアを含むことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresDescription">
        <source>By convention, identifier names do not contain the underscore (_) character. This rule checks namespaces, types, members, and parameters.</source>
        <target state="translated">規則により、識別子名にアンダースコア (_) 文字を含めることができません。この規則では名前空間、型、メンバー、およびパラメーターをチェックします。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageAssembly">
        <source>Remove the underscores from assembly name {0}.</source>
        <target state="translated">アンダースコアをアセンブリ名 {0} から削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageNamespace">
        <source>Remove the underscores from namespace name '{0}'.</source>
        <target state="translated">アンダースコアを名前空間 '{0}' から削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageType">
        <source>Remove the underscores from type name {0}.</source>
        <target state="translated">アンダースコアを型名 {0} から削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageMember">
        <source>Remove the underscores from member name {0}.</source>
        <target state="translated">アンダースコアをメンバー名 {0} から削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageTypeTypeParameter">
        <source>On type {0}, remove the underscores from generic type parameter name {1}.</source>
        <target state="translated">型 {0} で、アンダースコアをジェネリック型パラメーター名 {1} から削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageMethodTypeParameter">
        <source>On method {0}, remove the underscores from generic type parameter name {1}.</source>
        <target state="translated">メソッド {0} で、アンダースコアをジェネリック型パラメーター名 {1} から削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageMemberParameter">
        <source>In member {0}, remove the underscores from parameter name {1}.</source>
        <target state="translated">メンバー {0} で、アンダースコアをパラメーター名 {1} から削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageDelegateParameter">
        <source>In delegate {0}, remove the underscores from parameter name {1}.</source>
        <target state="translated">デリゲート {0} で、アンダースコアをパラメーター名 {1} から削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectSuffixTitle">
        <source>Identifiers should have correct suffix</source>
        <target state="translated">識別子は、正しいサフィックスを含んでいなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectSuffixDescription">
        <source>By convention, the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, have a suffix that is associated with the base type or interface.</source>
        <target state="translated">規則によると、特定の基本型を拡張する型、特定のインターフェイスを実装する型、またはそのような型から派生した型の名前には、基本型またはインターフェイスに関連付けられているサフィックスが付きます。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectSuffixMessageDefault">
        <source>Rename {0} to end in '{1}'.</source>
        <target state="translated">{0} の名前が '{1}' で終わるように変更します。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectSuffixMessageSpecialCollection">
        <source>Rename {0} to end in either 'Collection' or '{1}'.</source>
        <target state="translated">{0} の名前が 'Collection' または '{1}' で終わるように変更します。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixTitle">
        <source>Identifiers should not have incorrect suffix</source>
        <target state="translated">識別子は、不適切なサフィックスを含むことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixDescription">
        <source>By convention, only the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, should end with specific reserved suffixes. Other type names should not use these reserved suffixes.</source>
        <target state="translated">規則によると、特定の基本型を拡張する型、特定のインターフェイスを実装する型、またはそのような型から派生した型の名前のみ、末尾に特定の予約済みサフィックスが付きます。その他の型名では、これらの予約済みサフィックスを使用しないでください。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixMessageTypeNoAlternate">
        <source>Rename type name {0} so that it does not end in '{1}'.</source>
        <target state="translated">型名 '{0}' が '{1}' で終わらないように変更します。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixMessageMemberNewerVersion">
        <source>Either replace the suffix '{0}' in member name {1} with the suggested numeric alternate '2' or provide a more meaningful suffix that distinguishes it from the member it replaces.</source>
        <target state="translated">メンバー名 '{1}' のサフィックス '{0}' を推奨される数値 '2' で置き換えるか、意味のあるサフィックスを指定して置き換えるメンバーと区別してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixMessageTypeNewerVersion">
        <source>Either replace the suffix '{0}' in type name {1} with the suggested numeric alternate '2' or provide a more meaningful suffix that distinguishes it from the type it replaces.</source>
        <target state="translated">型名 '{1}' のサフィックス '{0}' を推奨される数値 '2' で置き換えるか、意味のあるサフィックスを指定して置き換える型と区別してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixMessageMemberWithAlternate">
        <source>Either replace the suffix '{0}' in member name '{1}' with the suggested alternate '{2}' or remove the suffix completely.</source>
        <target state="translated">メンバー名 '{1}' のサフィックス '{0}' を推奨される '{2}' で置き換えるか、サフィックスをすべて削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="FlagsEnumsShouldHavePluralNamesTitle">
        <source>Flags enums should have plural names</source>
        <target state="translated">フラグ列挙型は、複数形の名前を含んでいなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="FlagsEnumsShouldHavePluralNamesDescription">
        <source>A public enumeration has the System.FlagsAttribute attribute, and its name does not end in ""s"". Types that are marked by using FlagsAttribute have names that are plural because the attribute indicates that more than one value can be specified.</source>
        <target state="translated">パブリック列挙型に System.FlagsAttribute 属性があり、その名前の末尾に ""s"" がありません。FlagsAttribute を使用してマークされた型には複数形の名前が付きます。これは、この属性に複数の値を指定できることを示すためです。</target>
        <note />
      </trans-unit>
      <trans-unit id="FlagsEnumsShouldHavePluralNamesMessage">
        <source>Flags enums should have plural names</source>
        <target state="translated">フラグ列挙型は、複数形の名前を含んでいなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsTitle">
        <source>Identifiers should not match keywords</source>
        <target state="translated">識別子はキーワードと同一にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsDescription">
        <source>A namespace name or a type name matches a reserved keyword in a programming language. Identifiers for namespaces and types should not match keywords that are defined by languages that target the common language runtime.</source>
        <target state="translated">名前空間名または型名が、プログラミング言語の予約済みのキーワードと一致します。名前空間と型の識別子は、共通言語ランタイムを対象とする言語で定義されているキーワードと一致しないようにする必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsMessageMemberParameter">
        <source>In virtual/interface member {0}, rename parameter {1} so that it no longer conflicts with the reserved language keyword '{2}'. Using a reserved keyword as the name of a parameter on a virtual/interface member makes it harder for consumers in other languages to override/implement the member.</source>
        <target state="translated">仮想メンバーまたはインターフェイス メンバー {0} のパラメーター {1} の名前を変更して、予約されている言語キーワード '{2}' と競合しないようにしてください。仮想メンバーまたはインターフェイス メンバーのパラメーター名として、予約されているキーワードを使用すると、他の言語を使用するユーザーがそのメンバーをオーバーライドまたは実装することが困難になります。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsMessageMember">
        <source>Rename virtual/interface member {0} so that it no longer conflicts with the reserved language keyword '{1}'. Using a reserved keyword as the name of a virtual/interface member makes it harder for consumers in other languages to override/implement the member.</source>
        <target state="translated">仮想メンバーまたはインターフェイス メンバー {0} の名前を変更して、予約されている言語キーワード '{1}' と競合しないようにしてください。仮想メンバーまたはインターフェイス メンバーの名前として、予約されているキーワードを使用すると、他の言語を使用するユーザーがそのメンバーをオーバーライドまたは実装することが困難になります。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsMessageType">
        <source>Rename type {0} so that it no longer conflicts with the reserved language keyword '{1}'. Using a reserved keyword as the name of a type makes it harder for consumers in other languages to use the type.</source>
        <target state="translated">型 {0} の名前を変更して、予約されている言語キーワード '{1}' と競合しないようにしてください。型の名前として、予約されているキーワードを使用すると、他の言語を使用するユーザーがその型を使用することが困難になります。</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsMessageNamespace">
        <source>Rename namespace {0} so that it no longer conflicts with the reserved language keyword '{1}'. Using a reserved keyword as the name of a namespace makes it harder for consumers in other languages to use the namespace.</source>
        <target state="translated">名前空間 {0} の名前を変更して、予約されている言語キーワード '{1}' と競合しないようにしてください。名前空間の名前として、予約されているキーワードを使用すると、他の言語を使用するユーザーがその名前空間を使用することが困難になります。</target>
        <note />
      </trans-unit>
      <trans-unit id="OnlyFlagsEnumsShouldHavePluralNamesTitle">
        <source>Only FlagsAttribute enums should have plural names</source>
        <target state="translated">FlagsAttribute 列挙型のみが複数形の名前を含んでいなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="OnlyFlagsEnumsShouldHavePluralNamesDescription">
        <source>Naming conventions dictate that a plural name for an enumeration indicates that more than one value of the enumeration can be specified at the same time.</source>
        <target state="translated">名前付け規則では、列挙型の複数形の名前は同時に複数の列挙型を指定できることを意味します。</target>
        <note />
      </trans-unit>
      <trans-unit id="OnlyFlagsEnumsShouldHavePluralNamesMessage">
        <source>Only FlagsAttribute enums should have plural names</source>
        <target state="translated">FlagsAttribute 列挙型のみが複数形の名前を含んでいなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertyNamesShouldNotMatchGetMethodsTitle">
        <source>Property names should not match get methods</source>
        <target state="translated">プロパティ名は get メソッドと同一にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertyNamesShouldNotMatchGetMethodsDescription">
        <source>The name of a public or protected member starts with ""Get"" and otherwise matches the name of a public or protected property. ""Get"" methods and properties should have names that clearly distinguish their function.</source>
        <target state="translated">パブリック メンバーまたは保護されたメンバーの名前が、""Get"" から始まっているか、パブリック プロパティまたは保護されたプロパティの名前と一致します。""Get"" メソッドおよびプロパティには、その機能を明確に区別する名前が必要です。</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertyNamesShouldNotMatchGetMethodsMessage">
        <source>The property name '{0}' is confusing given the existence of method '{1}'. Rename or remove one of these members.</source>
        <target state="translated">メソッド '{1}' の存在が指定されているため、プロパティ名 '{0}' は混乱を招きます。これらのメンバーの 1 つの名前を変更するか、削除してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNamesShouldNotMatchNamespacesTitle">
        <source>Type names should not match namespaces</source>
        <target state="translated">型名は名前空間と同一にすることはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNamesShouldNotMatchNamespacesDescription">
        <source>Type names should not match the names of namespaces that are defined in the .NET Framework class library. Violating this rule can reduce the usability of the library.</source>
        <target state="translated">型名は、.NET Framework クラス ライブラリで定義されている名前空間の名前と一致しないようにする必要があります。この規則に違反すると、ライブラリが使いにくくなります。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNamesShouldNotMatchNamespacesMessageDefault">
        <source>The type name {0} conflicts in whole or in part with the namespace name '{1}'. Change either name to eliminate the conflict.</source>
        <target state="translated">型名 {0} は、名前空間の名前 '{1}' と全体または部分的に競合します。競合を解消するには、どちらかの名前を変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNamesShouldNotMatchNamespacesMessageSystem">
        <source>The type name {0} conflicts in whole or in part with the namespace name '{1}' defined in the .NET Framework. Rename the type to eliminate the conflict.</source>
        <target state="translated">型名 {0} は、.NET Framework で定義されている名前空間の名前 '{1}' と全体または部分的に競合します。競合を解消するには、型名を変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ParameterNamesShouldMatchBaseDeclarationTitle">
        <source>Parameter names should match base declaration</source>
        <target state="translated">パラメーター名は基本宣言と同一でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ParameterNamesShouldMatchBaseDeclarationDescription">
        <source>Consistent naming of parameters in an override hierarchy increases the usability of the method overrides. A parameter name in a derived method that differs from the name in the base declaration can cause confusion about whether the method is an override of the base method or a new overload of the method.</source>
        <target state="translated">オーバーライド階層でのパラメーターに対する一貫した名前付けにより、メソッド オーバーライドの使いやすさが向上します。派生メソッドのパラメーター名が基本宣言のパラメーター名と異なると、メソッドが基本メソッドのオーバーライドかメソッドの新しいオーバーロードかに関して混乱が生じる可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="ParameterNamesShouldMatchBaseDeclarationMessage">
        <source>In member {0}, change parameter name {1} to {2} in order to match the identifier as it has been declared in {3}.</source>
        <target state="translated">{3} で宣言されている識別子と一致するように、メンバー {0} のパラメーター名 {1} を {2} に変更します。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsTitle">
        <source>Use preferred terms</source>
        <target state="translated">適切な用語を使用します</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsDescription">
        <source>The name of an externally visible identifier includes a term for which an alternative, preferred term exists. Alternatively, the name includes the term ""Flag"" or ""Flags"".</source>
        <target state="translated">外部から参照可能な識別子の名前には、代わりとなる適切な用語が存在する用語が含まれています。または、名前に ""Flag"" または ""Flags"" という語が含まれています。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageAssembly">
        <source>Replace the term '{0}' in assembly name {1} with the preferred alternate '{2}'.</source>
        <target state="translated">アセンブリ名 {1} の用語 '{0}' を適切な用語 '{2}' に置き換えます。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageNamespace">
        <source>Replace the term '{0}' in namespace name '{1}' with the preferred alternate '{2}'.</source>
        <target state="translated">名前空間の名前 '{1}' の用語 '{0}' を適切な用語 '{2}' に置き換えます。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageMemberParameter">
        <source>In member {0}, replace the term '{1}' in parameter name {2} with the preferred alternate '{3}'.</source>
        <target state="translated">メンバー {0} で、パラメーター名 {2} の用語 '{1}' を適切な用語 '{3}' に置き換えます。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageDelegateParameter">
        <source>In delegate {0}, replace the term '{1}' in parameter name {2} with the preferred alternate '{3}'.</source>
        <target state="translated">デリゲート {0} で、パラメーター名 {2} の用語 '{1}' を適切な用語 '{3}' に置き換えます。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageTypeTypeParameter">
        <source>On type {0}, replace the term '{1}' in generic type parameter name {2} with the preferred alternate '{3}'.</source>
        <target state="translated">型 {0} で、ジェネリック型パラメーター名 {2} の用語 '{1}' を適切な用語 '{3}' に置き換えます。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageMethodTypeParameter">
        <source>On method {0}, replace the term '{1}' in generic type parameter name {2} with the preferred alternate '{3}'.</source>
        <target state="translated">メソッド {0} で、ジェネリック型パラメーター名 {2} の用語 '{1}' を適切な用語 '{3}' に置き換えます。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageType">
        <source>Replace the term '{0}' in type name {1} with the preferred alternate '{2}'.</source>
        <target state="translated">型名 {1} の用語 '{0}' を適切な用語 '{2}' に置き換えます。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageMember">
        <source>Replace the term '{0}' in member name {1} with the preferred alternate '{2}'.</source>
        <target state="translated">メンバー名 {1} の用語 '{0}' を適切な用語 '{2}' に置き換えます。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageAssemblyNoAlternate">
        <source>Replace the term '{0}' in assembly name {1} with an appropriate alternate or remove it entirely.</source>
        <target state="translated">アセンブリ名 {1} の用語 '{0}' を適切な用語に置き換えるか、削除します。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageNamespaceNoAlternate">
        <source>Replace the term '{0}' in namespace name '{1}' with an appropriate alternate or remove it entirely.</source>
        <target state="translated">名前空間の名前 '{1}' の用語 '{0}' を適切な用語に置き換えるか、削除します。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageMemberParameterNoAlternate">
        <source>In member {0}, replace the term '{1}' in parameter name {2} with an appropriate alternate or remove it entirely.</source>
        <target state="translated">メンバー {0} で、パラメーター名 {2} の用語 '{1}' を適切な用語に置き換えるか、削除します。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageDelegateParameterNoAlternate">
        <source>In delegate {0}, replace the term '{1}' in parameter name {2} with an appropriate alternate or remove it entirely.</source>
        <target state="translated">デリゲート {0} で、パラメーター名 {2} の用語 '{1}' を適切な用語に置き換えるか、削除します。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageTypeTypeParameterNoAlternate">
        <source>On type {0}, replace the term '{1}' in generic type parameter name {2} with an appropriate alternate or remove it entirely.</source>
        <target state="translated">型 {0} で、ジェネリック型パラメーター名 {2} の用語 '{1}' を適切な用語に置き換えるか、削除します。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageMethodTypeParameterNoAlternate">
        <source>On method {0}, replace the term '{1}' in generic type parameter name {2} with an appropriate alternate or remove it entirely.</source>
        <target state="translated">メソッド {0} で、パラメーター名 {2} の用語 '{1}' を適切な用語に置き換えるか、削除します。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageTypeNoAlternate">
        <source>Replace the term '{0}' in type name {1} with an appropriate alternate or remove it entirely.</source>
        <target state="translated">型名 {1} の用語 '{0}' を適切な用語に置き換えるか、削除します。</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageMemberNoAlternate">
        <source>Replace the term '{0}' in member name {1} with an appropriate alternate or remove it entirely.</source>
        <target state="translated">メンバー名 {1} の用語 '{0}' を適切な用語に置き換えるか、削除します。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsAndOperatorEqualsOnValueTypesTitle">
        <source>Override equals and operator equals on value types</source>
        <target state="translated">equals および operator equals を値型でオーバーライドします</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsAndOperatorEqualsOnValueTypesDescription">
        <source>For value types, the inherited implementation of Equals uses the Reflection library and compares the contents of all fields. Reflection is computationally expensive, and comparing every field for equality might be unnecessary. If you expect users to compare or sort instances, or to use instances as hash table keys, your value type should implement Equals.</source>
        <target state="translated">値型の場合、Equals を継承した実装が Reflection ライブラリを使用して、すべてのフィールドの内容を比較します。Reflection は計算コストが高いため、場合によってはすべてのフィールドで等値性を比較する必要はありません。ユーザーがインスタンスの比較または並べ替えを行うことや、ハッシュ テーブル キーとしてインスタンスを使用することが予想される場合には、値型に Equals を実装する必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsAndOperatorEqualsOnValueTypesMessageEquals">
        <source>{0} should override Equals.</source>
        <target state="translated">{0} は Equals をオーバーライドしなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsAndOperatorEqualsOnValueTypesMessageOpEquality">
        <source>{0} should override the equality (==) and inequality (!=) operators.</source>
        <target state="translated">{0} は、等値演算子 (==) および非等値演算子 (!=) をオーバーライドしなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotReturnArraysTitle">
        <source>Properties should not return arrays</source>
        <target state="translated">プロパティは配列を返すことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotReturnArraysDescription">
        <source>Arrays that are returned by properties are not write-protected, even when the property is read-only. To keep the array tamper-proof, the property must return a copy of the array. Typically, users will not understand the adverse performance implications of calling such a property.</source>
        <target state="translated">プロパティが読み取り専用であっても、プロパティで返される配列は書き込み禁止ではありません。配列の改ざんを防ぐには、プロパティで配列のコピーを返す必要があります。一般に、このようなプロパティを呼び出すときのパフォーマンス低下は理解されません。</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotReturnArraysMessage">
        <source>Properties should not return arrays</source>
        <target state="translated">プロパティは配列を返すことはできません</target>
        <note />
      </trans-unit>
      <trans-unit id="AssembliesShouldHaveValidStrongNamesTitle">
        <source>Assemblies should have valid strong names</source>
        <target state="translated">アセンブリには有効な厳密な名前が必要です</target>
        <note />
      </trans-unit>
      <trans-unit id="AssembliesShouldHaveValidStrongNamesDescription">
        <source>The strong name protects clients from unknowingly loading an assembly that has been tampered with. Assemblies without strong names should not be deployed outside very limited scenarios. If you share or distribute assemblies that are not correctly signed, the assembly can be tampered with, the common language runtime might not load the assembly, or the user might have to disable verification on his or her computer.</source>
        <target state="translated">厳密な名前によって、改ざんされたアセンブリをクライアントが知らないうちに読み込むことを防ぐことができます。厳密な名前のないアセンブリが配置される状況は限定されます。適切に署名されていないアセンブリを共有または配布すると、アセンブリが改ざんされたり、共通言語ランタイムでアセンブリが読み込まれなくなったりする可能性があるほか、ユーザーは自身のコンピューターで検証を無効にすることが必要になる場合があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="AssembliesShouldHaveValidStrongNamesMessageNoStrongName">
        <source>Sign {0} with a strong name key.</source>
        <target state="translated">{0} を厳密な名前キーで署名します。</target>
        <note />
      </trans-unit>
      <trans-unit id="AssembliesShouldHaveValidStrongNamesMessageNotValid">
        <source>Verify that {0} has a valid strong name before deploying.</source>
        <target state="translated">配置する前に、{0} に有効な厳密な名前が指定されていることを確認してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideGetHashCodeOnOverridingEqualsTitle">
        <source>Override GetHashCode on overriding Equals</source>
        <target state="translated">オーバーライドする Equals で GetHashCode をオーバーライドします</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideGetHashCodeOnOverridingEqualsDescription">
        <source>GetHashCode returns a value, based on the current instance, that is suited for hashing algorithms and data structures such as a hash table. Two objects that are the same type and are equal must return the same hash code.</source>
        <target state="translated">GetHashCode は、現在のインスタンスに基づいて、ハッシュ アルゴリズムとデータ構造 (ハッシュ テーブルなど) に適した値を返します。同じ型で等しい 2 つのオブジェクトは、同じハッシュ コードを返す必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideGetHashCodeOnOverridingEqualsMessage">
        <source>Override GetHashCode on overriding Equals</source>
        <target state="translated">オーバーライドする Equals で GetHashCode をオーバーライドします</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnOverloadingOperatorEqualsTitle">
        <source>Override Equals on overloading operator equals</source>
        <target state="translated">オーバーロードする演算子 equals で Equals をオーバーライドします</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnOverloadingOperatorEqualsDescription">
        <source>A public type implements the equality operator but does not override Object.Equals.</source>
        <target state="translated">パブリック型では等値演算子が実装されますが、Object.Equals はオーバーライドされていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnOverloadingOperatorEqualsMessage">
        <source>Override Equals on overloading operator equals</source>
        <target state="translated">オーバーロードする演算子 equals で Equals をオーバーライドします</target>
        <note />
      </trans-unit>
      <trans-unit id="Since_0_redefines_operator_1_it_should_also_redefine_operator_2">
        <source>Since '{0}' redefines operator '{1}', it should also redefine operator '{2}'</source>
        <target state="translated">'{0}' は演算子 '{1}' を再定義するため、演算子 '{2}' も再定義しなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_missing_operators">
        <source>Generate missing operators</source>
        <target state="translated">不足している演算子を生成します</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnOverloadingOperatorEqualsCodeActionTitle">
        <source>Override object.Equals</source>
        <target state="translated">object.Equals をオーバーライドします</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnImplementingIEquatableCodeActionTitle">
        <source>Override object.Equals</source>
        <target state="translated">object.Equals をオーバーライドします</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideGetHashCodeOnOverridingEqualsCodeActionTitle">
        <source>Override object.GetHashCode</source>
        <target state="translated">object.GetHashCode をオーバーライドします</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeExceptionPublic">
        <source>Make exception public</source>
        <target state="translated">例外を public に設定します</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesFix1">
        <source>Make '{0}' protected.</source>
        <target state="translated">'{0}' を protected に設定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesFix2">
        <source>Change '{0}' to a public interface implementation.</source>
        <target state="translated">'{0}' をパブリック インターフェイスの実装に変更します。</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesFix3">
        <source>Make the containing type '{0}' sealed.</source>
        <target state="translated">含んでいる型 '{0}' をシールドに設定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="StaticHolderTypeIsNotStatic">
        <source>Type '{0}' is a static holder type but is neither static nor NotInheritable</source>
        <target state="translated">型 '{0}' はスタティック ホルダー型ですが、static でも NotInheritable でもありません</target>
        <note />
      </trans-unit>
      <trans-unit id="StaticHolderTypesShouldBeStaticOrNotInheritable">
        <source>Static holder types should be Static or NotInheritable</source>
        <target state="translated">スタティック ホルダー型は Static または NotInheritable でなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeClassStatic">
        <source>Make Class Static</source>
        <target state="translated">クラスを静的にします</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsMessage">
        <source>Type {0} should override Equals because it implements IEquatable&lt;T&gt;</source>
        <target state="translated">型 {0} は IEquatable&lt;T&gt; を実装するため、Equals をオーバーライドする必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsTitle">
        <source>Override Object.Equals(object) when implementing IEquatable&lt;T&gt;</source>
        <target state="translated">IEquatable&lt;T&gt; を実装するときに Object.Equals(object) をオーバーライドします</target>
        <note />
      </trans-unit>
      <trans-unit id="UseIntegralOrStringArgumentForIndexersDescription">
        <source>Indexers, that is, indexed properties, should use integer or string types for the index. These types are typically used for indexing data structures and increase the usability of the library. Use of the Object type should be restricted to those cases where the specific integer or string type cannot be specified at design time. If the design requires other types for the index, reconsider whether the type represents a logical data store. If it does not represent a logical data store, use a method.</source>
        <target state="translated">インデクサー (インデックス付きのプロパティ) は、インデックスに整数型または文字列型を使用する必要があります。一般に、これらの型は、データ構造のインデックス作成に使用されます。また、ライブラリの操作感が改善されます。Object 型の使用は、デザイン時に特定の整数型または文字列型を指定できない場合に限定してください。デザインによってインデックスに他の型が必要な場合は、該当する型が論理的なデータ ストアを表しているかどうかを再検討してください。論理的なデータ ストアを表していない場合、メソッドを使用します。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseIntegralOrStringArgumentForIndexersMessage">
        <source>Use Integral Or String Argument For Indexers</source>
        <target state="translated">インデクサーには整数または文字列引数を使用します</target>
        <note />
      </trans-unit>
      <trans-unit id="UseIntegralOrStringArgumentForIndexersTitle">
        <source>Use Integral Or String Argument For Indexers</source>
        <target state="translated">インデクサーには整数または文字列引数を使用します</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDirectlyAwaitATaskDescription">
        <source>When an asynchronous method awaits a Task directly, continuation occurs in the same thread that created the task. Consider calling Task.ConfigureAwait(Boolean) to signal your intention for continuation. Call ConfigureAwait(false) on the task to schedule continuations to the thread pool, thereby avoiding a deadlock on the UI thread. Passing false is a good option for app-independent libraries. Calling ConfigureAwait(true) on the task has the same behavior as not explicitly calling ConfigureAwait. By explicitly calling this method, you're letting readers know you intentionally want to perform the continuation on the original synchronization context.</source>
        <target state="translated">非同期メソッドがタスクを直接待機すると、タスクを作成したのと同じスレッドで継続が発生します。継続の意図を示すには、Task.ConfigureAwait(Boolean) の呼び出しを検討してください。タスクで ConfigureAwait(false) を呼び出して、スレッド プールへの継続をスケジュールします。その結果、UI スレッドのデッドロックを回避できます。アプリに依存しないライブラリでは、false を渡すことが適切なオプションです。タスクで ConfigureAwait(true) を呼び出すと、ConfigureAwait を明示的に呼び出さない場合と動作が同じになります。このメソッドを明示的に呼び出すことにより、元の同期コンテキストで意図的に継続を実行していることを閲覧者に示します。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDirectlyAwaitATaskMessage">
        <source>Consider calling ConfigureAwait on the awaited task</source>
        <target state="translated">待機中のタスクでの ConfigureAwait の呼び出しを検討してください</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDirectlyAwaitATaskTitle">
        <source>Consider calling ConfigureAwait on the awaited task</source>
        <target state="translated">待機中のタスクでの ConfigureAwait の呼び出しを検討してください</target>
        <note />
      </trans-unit>
      <trans-unit id="AppendConfigureAwaitFalse">
        <source>Append .ConfigureAwait(false)</source>
        <target state="translated">.ConfigureAwait(false) を追加します</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIEquatableWhenOverridingObjectEqualsDescription">
        <source>When a type T overrides Object.Equals(object), the implementation must cast the object argument to the correct type T before performing the comparison. If the type implements IEquatable&lt;T&gt;, and therefore offers the method T.Equals(T), and if the argument is known at compile time to be of type T, then the compiler can call IEquatable&lt;T&gt;.Equals(T) instead of Object.Equals(object), and no cast is necessary, improving performance.</source>
        <target state="translated">型 T が Object.Equals(object) をオーバーライドする場合、この実装は、比較を行う前にオブジェクトの引数を正しい型 T にキャストする必要があります。型が IEquatable&lt;T&gt; を実装してメソッド T.Equals(T) を提供する場合、およびコンパイル時に引数が型 T であることがわかっている場合、コンパイラは Object.Equals(object) の代わりに IEquatable&lt;T&gt;.Equals(T) を呼び出すことができ、キャストは必要ではなくなるため、パフォーマンスが向上します。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsDescription">
        <source>When a type T implements the interface IEquatable&lt;T&gt;, it suggests to a user who sees a call to the Equals method in source code that an instance of the type can be equated with an instance of any other type. The user might be confused if their attempt to equate the type with an instance of another type fails to compile. This violates the "principle of least surprise".</source>
        <target state="translated">型 T がインターフェイスの IEquatable&lt;T&gt; を実装することは、ソース コード内の Equals メソッドへの呼び出しを見るユーザーにとって、型のインスタンスを他の任意の型のインスタンスと結びつけることができることを意味しています。ユーザーが型を他の型のインスタンスに結びつけようとしてコンパイルが失敗すると、ユーザーは混乱する可能性があります。これは、「驚き最小の原則」に違反しています。</target>
        <note />
      </trans-unit>
      <trans-unit id="RenameToTitle">
        <source>Rename to '{0}'</source>
        <target state="translated">名前を '{0}' に変更する</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHideBaseClassMethodsDescription">
        <source>A method in a base type is hidden by an identically named method in a derived type when the parameter signature of the derived method differs only by types that are more weakly derived than the corresponding types in the parameter signature of the base method.</source>
        <target state="translated">派生メソッドのパラメーター シグネチャ内のある型が、基本メソッドのパラメーター シグネチャ内のそれに対応する型より弱く型指定されていることが、両者の唯一の相違点である場合、基本型内のメソッドが派生型内の同じ名前のメソッドによって隠されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHideBaseClassMethodsMessage">
        <source>Change or remove '{0}' because it hides a more specific base class method: '{1}'.</source>
        <target state="translated">より特定の基底クラス メソッドを隠しているため、'{0}' を変更または削除してください: '{1}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHideBaseClassMethodsTitle">
        <source>Do not hide base class methods</source>
        <target state="translated">基底クラス メソッドを非表示にしません</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForDelegateMessage">
        <source>Remove '{0}' and replace its usage with a generic EventHandler, for e.g. EventHandler&lt;T&gt;, where T is a valid EventArgs</source>
        <target state="translated">'{0}' を削除して、それを EventHandler&lt;T&gt; (T は有効な EventArgs) などのジェネリックの EventHandler と置き換えます</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForDelegateDescription">
        <source>A type contains a delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets Microsoft .NET Framework?2.0.</source>
        <target state="translated">型に void を返すデリゲートが含まれており、デリゲートのシグネチャに 2 つのパラメーター (1 つはオブジェクト、もう 1 つは EventArgs に割り当て可能な型) が含まれ、包含アセンブリの対象が .NET Framework 2.0 です。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForEventMessage">
        <source>Change the event '{0}' to replace the type '{1}' with a generic EventHandler, for e.g. EventHandler&lt;T&gt;, where T is a valid EventArgs</source>
        <target state="translated">イベント '{0}' を変更して、型 '{1}' を EventHandler&lt;T&gt; (T は有効な EventArgs) などのジェネリックの EventHandler と置き換えます。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForEventDescription">
        <source>A delegate that handles a public or protected event does not have the correct signature, return type, or parameter names.</source>
        <target state="translated">公開イベントまたは保護されたイベントを処理するデリゲートに正しいシグネチャがないか、型またはパラメーター名を返します。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForEvent2Message">
        <source>Change the event '{0}' to use a generic EventHandler by defining the event type explicitly, for e.g. Event MyEvent As EventHandler(Of MyEventArgs).</source>
        <target state="translated">汎用 EventHandler を使用するために、イベント型を明示的に定義して、イベント '{0}' を変更します。例: Event MyEvent As EventHandler(Of MyEventArgs)</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForEvent2Description">
        <source>A type contains an event that declares an EventHandler delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets Microsoft .NET Framework?2.0.</source>
        <target state="translated">型に void を返す EventHandler デリゲートを宣言するイベントが含まれており、デリゲートのシグネチャに 2 つのパラメーター (1 つはオブジェクト、もう 1 つは EventArgs に割り当て可能な型) が含まれ、包含アセンブリの対象が .NET Framework 2.0 です。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesMessageBoth">
        <source>{0} should define operator(s) '{1}' and Equals since it implements IComparable.</source>
        <target state="translated">{0} は、IComparable を実装しているため、演算子 '{1}' と Equals を定義しなければなりません。</target>
        <note>1 is a comma-separated list</note>
      </trans-unit>
    </body>
  </file>
</xliff>
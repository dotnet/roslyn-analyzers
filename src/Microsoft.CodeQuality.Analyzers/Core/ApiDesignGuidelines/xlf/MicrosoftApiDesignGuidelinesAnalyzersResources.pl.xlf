<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="pl" original="../MicrosoftApiDesignGuidelinesAnalyzersResources.resx">
    <body>
      <trans-unit id="AppendConfigureAwaitTrue">
        <source>Append .ConfigureAwait(true)</source>
        <target state="translated">Dołącz element .ConfigureAwait(true)</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidAsyncVoidTitle">
        <source>Avoid Async Void</source>
        <target state="translated">Unikaj metod async void</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidAsyncVoidDescription">
        <source>#N/A</source>
        <target state="translated">ND</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidAsyncVoidMessage">
        <source>Avoid Async Void</source>
        <target state="translated">Unikaj metod async void</target>
        <note />
      </trans-unit>
      <trans-unit id="AsyncMethodNamesShouldEndInAsyncTitle">
        <source>Async Method Names Should End in Async</source>
        <target state="translated">Nazwy metod asynchronicznych powinny kończyć się ciągiem Async</target>
        <note />
      </trans-unit>
      <trans-unit id="AsyncMethodNamesShouldEndInAsyncDescription">
        <source>#N/A</source>
        <target state="translated">ND</target>
        <note />
      </trans-unit>
      <trans-unit id="AsyncMethodNamesShouldEndInAsyncMessage">
        <source>Async Method Names Should End in Async</source>
        <target state="translated">Nazwy metod asynchronicznych powinny kończyć się ciągiem Async</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchGeneralExceptionTypesDescription">
        <source>A general exception such as System.Exception or System.SystemException is caught in a catch statement, or a general catch clause is used. General exceptions should not be caught.</source>
        <target state="translated">W instrukcji catch przechwycono wyjątek ogólny, taki jak System.Exception lub System.SystemException, lub jest używana ogólna klauzula catch. Wyjątki ogólne nie powinny być przechwytywane.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchGeneralExceptionTypesMessage">
        <source>Modify '{0}' to catch a more specific exception type, or rethrow the exception.</source>
        <target state="translated">Zmodyfikuj element „{0}”, aby przechwytywać dokładniej określony typ wyjątku, lub ponownie zgłoś wyjątek.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchGeneralExceptionTypesTitle">
        <source>Do not catch general exception types</source>
        <target state="translated">Nie przechwytuj ogólnych typów wyjątków</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassAsyncLambdasAsVoidReturningDelegateTypesTitle">
        <source>Don't Pass Async Lambdas as Void Returning Delegate Types</source>
        <target state="translated">Nie przekazuj asynchronicznych wyrażeń lambda jako typów delegatów zwracających typ void</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassAsyncLambdasAsVoidReturningDelegateTypesDescription">
        <source>#N/A</source>
        <target state="translated">ND</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassAsyncLambdasAsVoidReturningDelegateTypesMessage">
        <source>Don't Pass Async Lambdas as Void Returning Delegate Types</source>
        <target state="translated">Nie przekazuj asynchronicznych wyrażeń lambda jako typów delegatów zwracających typ void</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPrefixEnumValuesWithTypeNameDescription">
        <source>An enumeration's values should not start with the type name of the enumeration.</source>
        <target state="translated">Wartości wyliczenia nie powinny rozpoczynać się od nazwy typu wyliczenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPrefixEnumValuesWithTypeNameMessage">
        <source>Do not prefix enum values with the name of the enum type '{0}'. </source>
        <target state="translated">Nie dodawaj do wartości wyliczenia prefiksu w postaci nazwy typu wyliczenia „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPrefixEnumValuesWithTypeNameTitle">
        <source>Do not prefix enum values with type name</source>
        <target state="translated">Nie dodawaj do wartości wyliczenia prefiksu w postaci nazwy typu</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStoreAsyncLambdasAsVoidReturningDelegateTypesTitle">
        <source>Don't Store Async Lambdas as Void Returning Delegate Types</source>
        <target state="translated">Nie przechowuj asynchronicznych wyrażeń lambda jako typów delegatów zwracających typ void</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStoreAsyncLambdasAsVoidReturningDelegateTypesDescription">
        <source>#N/A</source>
        <target state="translated">ND</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStoreAsyncLambdasAsVoidReturningDelegateTypesMessage">
        <source>Don't Store Async Lambdas as Void Returning Delegate Types</source>
        <target state="translated">Nie przechowuj asynchronicznych wyrażeń lambda jako typów delegatów zwracających typ void</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageFinalizeOverride">
        <source>Remove the finalizer from type '{0}', override Dispose(bool disposing), and put the finalization logic in the code path where 'disposing' is false. Otherwise, it might lead to duplicate Dispose invocations as the Base type '{1}' also provides a finalizer.</source>
        <target state="translated">Usuń finalizator z typu „{0}”, przesłoń funkcję Dispose(bool disposing) i umieść logikę finalizacji w ścieżce kodu, gdzie element „disposing” ma wartość false. W przeciwnym razie mogą pojawić się zduplikowane wywołania funkcji Dispose, ponieważ typ bazowy „{1}” także udostępnia finalizator.</target>
        <note />
      </trans-unit>
      <trans-unit id="PropagateCancellationTokensWhenPossibleTitle">
        <source>Propagate CancellationTokens When Possible</source>
        <target state="translated">Propaguj elementy CancellationToken, jeśli to możliwe</target>
        <note />
      </trans-unit>
      <trans-unit id="PropagateCancellationTokensWhenPossibleDescription">
        <source>#N/A</source>
        <target state="translated">ND</target>
        <note />
      </trans-unit>
      <trans-unit id="PropagateCancellationTokensWhenPossibleMessage">
        <source>Propagate CancellationTokens When Possible</source>
        <target state="translated">Propaguj elementy CancellationToken, jeśli to możliwe</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMixBlockingAndAsyncTitle">
        <source>Don't Mix Blocking and Async</source>
        <target state="translated">Nie mieszaj kodu blokującego i asynchronicznego</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMixBlockingAndAsyncDescription">
        <source>#N/A</source>
        <target state="translated">ND</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMixBlockingAndAsyncMessage">
        <source>Don't Mix Blocking and Async</source>
        <target state="translated">Nie mieszaj kodu blokującego i asynchronicznego</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesThatOwnDisposableFieldsShouldBeDisposableTitle">
        <source>Types that own disposable fields should be disposable</source>
        <target state="translated">Typy zawierające pola możliwe do likwidacji powinny być możliwe do likwidacji</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesThatOwnDisposableFieldsShouldBeDisposableDescription">
        <source>A class declares and implements an instance field that is a System.IDisposable type, and the class does not implement IDisposable. A class that declares an IDisposable field indirectly owns an unmanaged resource and should implement the IDisposable interface.</source>
        <target state="translated">Klasa deklaruje i implementuje pole wystąpienia typu System.IDisposable oraz nie implementuje interfejsu IDisposable. Klasa deklarująca pole IDisposable jest pośrednio właścicielem zasobu niezarządzanego i powinna implementować interfejs IDisposable.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesThatOwnDisposableFieldsShouldBeDisposableMessageNonBreaking">
        <source>Type '{0}' owns disposable field(s) '{1}' but is not disposable</source>
        <target state="translated">Typ „{0}” zawiera pola możliwe do likwidacji („{1}”), ale sam nie jest możliwy do likwidacji</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesTitle">
        <source>Use generic event handler instances</source>
        <target state="translated">Używaj ogólnych wystąpień procedur obsługi zdarzeń</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueTitle">
        <source>Enums should have zero value</source>
        <target state="translated">Wyliczenia powinny mieć wartość zero</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueDescription">
        <source>The default value of an uninitialized enumeration, just as other value types, is zero. A nonflags-attributed enumeration should define a member by using the value of zero so that the default value is a valid value of the enumeration. If an enumeration that has the FlagsAttribute attribute applied defines a zero-valued member, its name should be ""None"" to indicate that no values have been set in the enumeration.</source>
        <target state="translated">Wartość domyślna niezainicjowanego wyliczenia to zero, tak samo jak w przypadku innych typów. Wyliczenie bez atrybutu FlagsAttribute powinno definiować element członkowski za pomocą wartości zero, tak aby wartość domyślna była prawidłową wartością wyliczenia. Jeśli wyliczenie z zastosowanym atrybutem FlagsAttribute definiuje element członkowski o wartości zero, powinien on mieć nazwę „None”, co wskazuje, że w wyliczeniu nie ustawiono żadnych wartości.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueMessageFlagsRename">
        <source>In enum {0}, change the name of {1} to 'None'.</source>
        <target state="translated">W wyliczeniu {0} zmień nazwę elementu {1} na „None”.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueMessageFlagsMultipleZeros">
        <source>Remove all members that have the value zero from {0} except for one member that is named 'None'.</source>
        <target state="translated">Usuń wszystkie elementy członkowskie o wartości zero z wyliczenia {0}, z wyjątkiem jednego elementu członkowskiego o nazwie „None”.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldHaveZeroValueMessageNotFlagsNoZeroValue">
        <source>Add a member to {0} that has a value of zero with a suggested name of 'None'.</source>
        <target state="translated">Dodaj element członkowski o wartości zero do wyliczenia {0} z sugerowaną nazwą „None”.</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypesShouldNotHaveConstructorsTitle">
        <source>Abstract types should not have constructors</source>
        <target state="translated">Typy abstrakcyjne nie powinny mieć konstruktorów</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypesShouldNotHaveConstructorsDescription">
        <source>Constructors on abstract types can be called only by derived types. Because public constructors create instances of a type, and you cannot create instances of an abstract type, an abstract type that has a public constructor is incorrectly designed.</source>
        <target state="translated">Konstruktory typów abstrakcyjnych mogą być wywoływane tylko przez typy pochodne. Konstruktory publiczne tworzą wystąpienia typu, ale nie można tworzyć wystąpień typu abstrakcyjnego, dlatego typ abstrakcyjny z konstruktorem publicznym jest niepoprawnie zaprojektowany.</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypesShouldNotHaveConstructorsMessage">
        <source>Abstract type {0} should not have constructors</source>
        <target state="translated">Typ abstrakcyjny {0} nie powinien mieć konstruktorów</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithClsCompliantTitle">
        <source>Mark assemblies with CLSCompliant</source>
        <target state="translated">Oznacz zestawy atrybutem CLSCompliant</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithClsCompliantDescription">
        <source>The Common Language Specification (CLS) defines naming restrictions, data types, and rules to which assemblies must conform if they will be used across programming languages. Good design dictates that all assemblies explicitly indicate CLS compliance by using CLSCompliantAttribute . If this attribute is not present on an assembly, the assembly is not compliant.</source>
        <target state="translated">Specyfikacja CLS (Common Language Specification) definiuje ograniczenia nazewnictwa, typy danych i reguły, z którymi muszą być zgodne zestawy, jeśli będą używane z różnymi językami programowania. Reguły poprawnego projektowania nakazują, aby wszystkie zestawy jawnie deklarowały zgodność ze specyfikacją CLS za pomocą atrybutu CLSCompliantAttribute. Jeśli zestaw nie ma tego atrybutu, nie jest zgodny.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithClsCompliantMessage">
        <source>Mark assemblies with CLSCompliant</source>
        <target state="translated">Oznacz zestawy atrybutem CLSCompliant</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithAssemblyVersionTitle">
        <source>Mark assemblies with assembly version</source>
        <target state="translated">Oznacz zestawy za pomocą wersji zestawu</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithAssemblyVersionDescription">
        <source>The .NET Framework uses the version number to uniquely identify an assembly, and to bind to types in strongly named assemblies. The version number is used together with version and publisher policy. By default, applications run only with the assembly version with which they were built.</source>
        <target state="translated">Program .NET Framework używa numeru wersji do unikatowego identyfikowania zestawu i tworzenia powiązań z typami w zestawach o silnej nazwie. Numer wersji jest używany w połączeniu z zasadami wersji i wydawcy. Domyślnie aplikacje działają tylko z wersją zestawu, dla której zostały skompilowane.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithAssemblyVersionMessage">
        <source>Mark assemblies with assembly version</source>
        <target state="translated">Oznacz zestawy za pomocą wersji zestawu</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithComVisibleTitle">
        <source>Mark assemblies with ComVisible</source>
        <target state="translated">Oznacz zestawy atrybutem ComVisible</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithComVisibleDescription">
        <source>ComVisibleAttribute determines how COM clients access managed code. Good design dictates that assemblies explicitly indicate COM visibility. COM visibility can be set for the whole assembly and then overridden for individual types and type members. If this attribute is not present, the contents of the assembly are visible to COM clients.</source>
        <target state="translated">Atrybut ComVisibleAttribute określa, w jaki sposób klienci modelu COM uzyskują dostęp do kodu zarządzanego. Zasady poprawnego projektowania nakazują, aby zestawy jawnie deklarowały widoczność modelu COM. Widoczność modelu COM można ustawić dla całego zestawu, a następnie przesłonić dla poszczególnych typów i elementów członkowskich typów. Jeśli nie ma tego atrybutu, zawartość zestawu jest widoczna dla klientów modelu COM.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithComVisibleMessageNoAttribute">
        <source>Because {0} exposes externally visible types, mark it with ComVisible(false) at the assembly level and then mark all types within the assembly that should be exposed to COM clients with ComVisible(true).</source>
        <target state="translated">Ponieważ zestaw {0} udostępnia typy widoczne zewnętrznie, oznacz go atrybutem ComVisible(false) na poziomie zestawu, a następnie oznacz atrybutem ComVisible(true) wszystkie typy w zestawie, które powinny być dostępne dla klientów modelu COM.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAssembliesWithComVisibleMessageAttributeTrue">
        <source>Consider changing the ComVisible attribute on {0} to false, and opting in at the type level.</source>
        <target state="translated">Rozważ zmianę atrybutu ComVisible dla zestawu {0} na wartość false i użycie wartości true na poziomie typów.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAttributesWithAttributeUsageTitle">
        <source>Mark attributes with AttributeUsageAttribute</source>
        <target state="translated">Oznacz atrybuty za pomocą atrybutu AttributeUsageAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAttributesWithAttributeUsageDescription">
        <source>When you define a custom attribute, mark it by using AttributeUsageAttribute to indicate where in the source code the custom attribute can be applied. The meaning and intended usage of an attribute will determine its valid locations in code.</source>
        <target state="translated">Przy definiowaniu atrybutu niestandardowego oznacz go za pomocą atrybutu AttributeUsageAttribute, aby wskazać, gdzie można stosować ten atrybut niestandardowy w kodzie źródłowym. Znaczenie i zamierzone użycie atrybutu określi jego prawidłowe lokalizacje w kodzie.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAttributesWithAttributeUsageMessageDefault">
        <source>Specify AttributeUsage on {0}.</source>
        <target state="translated">Określ atrybut AttributeUsage dla elementu {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAttributesWithAttributeUsageMessageInherited">
        <source>Even though attribute {0} inherits AttributeUsage from its base type, you should consider explicitly specifying AttributeUsage on the type to improve code readability and documentation.</source>
        <target state="translated">Mimo że atrybut {0} dziedziczy atrybut AttributeUsage ze swojego typu podstawowego, rozważ jawne określenie atrybutu AttributeUsage dla typu w celu ulepszenia czytelności kodu i dokumentacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineAccessorsForAttributeArgumentsTitle">
        <source>Define accessors for attribute arguments</source>
        <target state="translated">Zdefiniuj metody dostępu dla argumentów atrybutów</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineAccessorsForAttributeArgumentsDescription">
        <source>Attributes can define mandatory arguments that must be specified when you apply the attribute to a target. These are also known as positional arguments because they are supplied to attribute constructors as positional parameters. For every mandatory argument, the attribute should also provide a corresponding read-only property so that the value of the argument can be retrieved at execution time. Attributes can also define optional arguments, which are also known as named arguments. These arguments are supplied to attribute constructors by name and should have a corresponding read/write property.</source>
        <target state="translated">Atrybuty mogą definiować argumenty obowiązkowe, które muszą zostać określone podczas stosowania atrybutu do elementu docelowego. Są one też nazywane argumentami pozycyjnymi, ponieważ są przekazywane do konstruktorów atrybutu jako parametry pozycyjne. Dla każdego argumentu obowiązkowego atrybut powinien także określać odpowiednią właściwość tylko do odczytu, która umożliwia pobranie wartości argumentu w czasie wykonywania. Atrybuty mogą także definiować argumenty opcjonalne, określane też jako argumenty nazwane. Te argumenty są przekazywane do konstruktorów atrybutu za pomocą nazwy i powinny mieć odpowiednią właściwość do odczytu i zapisu.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineAccessorsForAttributeArgumentsMessageDefault">
        <source>Add a public read-only property accessor for positional argument {0} of Attribute {1}.</source>
        <target state="translated">Dodaj publiczną metodę dostępu do właściwości tylko do odczytu dla argumentu pozycyjnego {0} atrybutu {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineAccessorsForAttributeArgumentsMessageRemoveSetter">
        <source>Remove the property setter from {0} or reduce its accessibility because it corresponds to positional argument {1}.</source>
        <target state="translated">Usuń metodę ustawiającą właściwość z argumentu {0} lub ogranicz jej dostępność, ponieważ odpowiada ona argumentowi pozycyjnemu {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefineAccessorsForAttributeArgumentsMessageIncreaseVisibility">
        <source>If {0} is the property accessor for positional argument {1}, make it public.</source>
        <target state="translated">Jeśli {0} to metoda dostępu do właściwości dla argumentu pozycyjnego {1}, zadeklaruj ją jako publiczną.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertiesWhereAppropriateTitle">
        <source>Use properties where appropriate</source>
        <target state="translated">Użyj właściwości w odpowiednich miejscach</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertiesWhereAppropriateDescription">
        <source>A public or protected method has a name that starts with ""Get"", takes no parameters, and returns a value that is not an array. The method might be a good candidate to become a property.</source>
        <target state="translated">Metoda publiczna lub chroniona ma nazwę zaczynającą się od „Get”, nie pobiera parametrów i zwraca wartość, która nie jest tablicą. Ta metoda może być dobrym kandydatem na właściwość.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePropertiesWhereAppropriateMessage">
        <source>Use properties where appropriate</source>
        <target state="translated">Użyj właściwości w odpowiednich miejscach</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkEnumsWithFlagsTitle">
        <source>Mark enums with FlagsAttribute</source>
        <target state="translated">Oznacz wyliczenia atrybutem FlagsAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkEnumsWithFlagsDescription">
        <source>An enumeration is a value type that defines a set of related named constants. Apply FlagsAttribute to an enumeration when its named constants can be meaningfully combined.</source>
        <target state="translated">Wyliczenie to typ wartości, który definiuje zestaw powiązanych stałych nazwanych. Zastosuj atrybut FlagsAttribute do wyliczenia, jeśli jego stałe nazwane można połączyć w znaczący sposób.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkEnumsWithFlagsMessage">
        <source>Mark enums with FlagsAttribute</source>
        <target state="translated">Oznacz wyliczenia atrybutem FlagsAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesTitle">
        <source>Interface methods should be callable by child types</source>
        <target state="translated">Typy podrzędne powinny móc wywoływać metody interfejsu</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesDescription">
        <source>An unsealed externally visible type provides an explicit method implementation of a public interface and does not provide an alternative externally visible method that has the same name.</source>
        <target state="translated">Niezapieczętowany typ widoczny zewnętrznie udostępnia jawną implementację metody interfejsu publicznego i nie udostępnia alternatywnej metody widocznej zewnętrznie o tej samej nazwie.</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesMessage">
        <source>Make '{0}' sealed (a breaking change if this class has previously shipped), implement the method non-explicitly, or implement a new method that exposes the functionality of '{1}' and is visible to derived classes.</source>
        <target state="translated">Zapięczętuj element „{0}” (istotna zmiana, jeśli ta klasa została wcześniej dostarczona), wdróż metodę niejawnie lub wdróż nową metodę, która ujawnia funkcjonalność {1} i jest widoczna dla klas pochodnych.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesTitle">
        <source>Override methods on comparable types</source>
        <target state="translated">Przesłoń metody porównywalnych typów</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesDescription">
        <source>A public or protected type implements the System.IComparable interface. It does not override Object.Equals nor does it overload the language-specific operator for equality, inequality, less than, less than or equal, greater than or greater than or equal.</source>
        <target state="translated">Typ publiczny lub chroniony implementuje interfejs System.IComparable. Nie przesłania on metody Object.Equals ani nie przeciąża specyficznego dla języka operatora równości, nierówności, mniejszości, mniejszości lub równości, większości ani większości lub równości.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesMessageEquals">
        <source>{0} should override Equals since it implements IComparable.</source>
        <target state="translated">Typ {0} powinien przesłaniać metodę Equals, ponieważ implementuje interfejs IComparable.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesMessageOperator">
        <source>{0} should define operator(s) '{1}' since it implements IComparable.</source>
        <target state="translated">Typ {0} powinien definiować operatory „{1}”, ponieważ implementuje interfejs IComparable.</target>
        <note>1 is a comma-separated list</note>
      </trans-unit>
      <trans-unit id="MovePInvokesToNativeMethodsClassTitle">
        <source>Move pinvokes to native methods class</source>
        <target state="translated">Przenieś metody pinvoke do klasy metod natywnych</target>
        <note />
      </trans-unit>
      <trans-unit id="MovePInvokesToNativeMethodsClassDescription">
        <source>Platform Invocation methods, such as those that are marked by using the System.Runtime.InteropServices.DllImportAttribute attribute, or methods that are defined by using the Declare keyword in Visual Basic, access unmanaged code. These methods should be of the NativeMethods, SafeNativeMethods, or UnsafeNativeMethods class.</source>
        <target state="translated">Metody wywoływania platformy, takie jak metody oznaczone atrybutem System.Runtime.InteropServices.DllImportAttribute, lub metody zdefiniowane za pomocą słowa kluczowego Declare w języku Visual Basic uzyskują dostęp do kodu niezarządzanego. Te metody powinny należeć do klasy NativeMethods, SafeNativeMethods lub UnsafeNativeMethods.</target>
        <note />
      </trans-unit>
      <trans-unit id="MovePInvokesToNativeMethodsClassMessage">
        <source>Move pinvokes to native methods class</source>
        <target state="translated">Przenieś metody pinvoke do klasy metod natywnych</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldDifferByMoreThanCaseTitle">
        <source>Identifiers should differ by more than case</source>
        <target state="translated">Identyfikatory powinny różnić się nie tylko wielkością liter</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldDifferByMoreThanCaseDescription">
        <source>Identifiers for namespaces, types, members, and parameters cannot differ only by case because languages that target the common language runtime are not required to be case-sensitive.</source>
        <target state="translated">Identyfikatory przestrzeni nazw, typów, elementów członkowskich i parametrów nie mogą różnić się tylko wielkością liter, ponieważ języki docelowe środowiska uruchomieniowego języka wspólnego nie muszą rozróżniać wielkości liter.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldDifferByMoreThanCaseMessage">
        <source>Names of '{0}' and '{1}' should differ by more than case.</source>
        <target state="translated">Nazwy elementów „{0}” i „{1}” powinny różnić się nie tylko wielkością liter.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectPrefixTitle">
        <source>Identifiers should have correct prefix</source>
        <target state="translated">Identyfikatory powinny mieć poprawny prefiks</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectPrefixDescription">
        <source>The name of an externally visible interface does not start with an uppercase ""I"". The name of a generic type parameter on an externally visible type or method does not start with an uppercase ""T"".</source>
        <target state="translated">Nazwa interfejsu widocznego zewnętrznie nie zaczyna się wielką literą „I”. Nazwa parametru typu ogólnego dla typu lub metody widocznych zewnętrznie nie zaczyna się wielką literą „T”.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectPrefixMessageInterface">
        <source>Prefix interface name {0} with 'I'.</source>
        <target state="translated">Dodaj do nazwy interfejsu {0} prefiks „I”.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectPrefixMessageTypeParameter">
        <source>Prefix generic type parameter name {0} with 'T'.</source>
        <target state="translated">Dodaj do nazwy parametru typu ogólnego {0} prefiks „T”.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonConstantFieldsShouldNotBeVisibleTitle">
        <source>Non-constant fields should not be visible</source>
        <target state="translated">Pola niebędące stałymi nie powinny być widoczne</target>
        <note />
      </trans-unit>
      <trans-unit id="NonConstantFieldsShouldNotBeVisibleDescription">
        <source>Static fields that are neither constants nor read-only are not thread-safe. Access to such a field must be carefully controlled and requires advanced programming techniques to synchronize access to the class object.</source>
        <target state="translated">Pola statyczne, które nie są stałymi ani wartościami tylko do odczytu, nie są bezpieczne wątkowo. Dostęp do takiego pola musi być starannie kontrolowany i wymaga zaawansowanych technik programistycznych do synchronizowania dostępu do obiektu klasy.</target>
        <note />
      </trans-unit>
      <trans-unit id="NonConstantFieldsShouldNotBeVisibleMessage">
        <source>Non-constant fields should not be visible</source>
        <target state="translated">Pola niebędące stałymi nie powinny być widoczne</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkEnumsWithFlagsTitle">
        <source>Do not mark enums with FlagsAttribute</source>
        <target state="translated">Nie oznaczaj wyliczeń atrybutem FlagsAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkEnumsWithFlagsDescription">
        <source>An externally visible enumeration is marked by using FlagsAttribute, and it has one or more values that are not powers of two or a combination of the other defined values on the enumeration.</source>
        <target state="translated">Wyliczenie widoczne zewnętrznie jest oznaczone atrybutem FlagsAttribute i ma co najmniej jedną wartość, która nie jest potęgą dwójki ani kombinacją innych wartości zdefiniowanych dla wyliczenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkEnumsWithFlagsMessage">
        <source>Do not mark enums with FlagsAttribute</source>
        <target state="translated">Nie oznaczaj wyliczeń atrybutem FlagsAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesTitle">
        <source>Operator overloads have named alternates</source>
        <target state="translated">Przeciążenia operatora mają nazwane alternatywy</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesDescription">
        <source>An operator overload was detected, and the expected named alternative method was not found. The named alternative member provides access to the same functionality as the operator and is provided for developers who program in languages that do not support overloaded operators.</source>
        <target state="translated">Wykryto przeciążenie operatora i nie znaleziono oczekiwanej nazwanej metody alternatywnej. Nazwany alternatywny element członkowski udostępnia tę samą funkcjonalność co operator i jest udostępniany dla deweloperów programujących w językach, które nie obsługują przeciążonych operatorów.</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesMessageDefault">
        <source>Provide a method named '{0}' as a friendly alternate for operator {1}.</source>
        <target state="translated">Określ metodę o nazwie „{0}” jako metodę alternatywną operatora {1} o przyjaznej nazwie.</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesMessageProperty">
        <source>Provide a property named '{0}' as a friendly alternate for operator {1}.</source>
        <target state="translated">Określ właściwość o nazwie „{0}” jako właściwość alternatywną operatora {1} o przyjaznej nazwie.</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesMessageMultiple">
        <source>Provide a method named '{0}' or '{1}' as an alternate for operator {2}.</source>
        <target state="translated">Określ metodę o nazwie „{0}” lub „{1}” jako metodę alternatywną operatora {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorOverloadsHaveNamedAlternatesMessageVisibility">
        <source>Mark {0} as public because it is a friendly alternate for operator {1}.</source>
        <target state="translated">Oznacz metodę {0} jako publiczną, ponieważ jest ona metodą alternatywną operatora {1} o przyjaznej nazwie.</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorsShouldHaveSymmetricalOverloadsTitle">
        <source>Operators should have symmetrical overloads</source>
        <target state="translated">Operatory powinny mieć symetryczne przeciążenia</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorsShouldHaveSymmetricalOverloadsDescription">
        <source>A type implements the equality or inequality operator and does not implement the opposite operator.</source>
        <target state="translated">Typ implementuje operator równości lub nierówności i nie implementuje operatora przeciwnego.</target>
        <note />
      </trans-unit>
      <trans-unit id="OperatorsShouldHaveSymmetricalOverloadsMessage">
        <source>Operators should have symmetrical overloads</source>
        <target state="translated">Operatory powinny mieć symetryczne przeciążenia</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionPropertiesShouldBeReadOnlyTitle">
        <source>Collection properties should be read only</source>
        <target state="translated">Właściwości kolekcji powinny być dostępne tylko do odczytu</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionPropertiesShouldBeReadOnlyDescription">
        <source>A writable collection property allows a user to replace the collection with a different collection. A read-only property stops the collection from being replaced but still allows the individual members to be set.</source>
        <target state="translated">Właściwość kolekcji dostępna do zapisu umożliwia użytkownikowi zamianę kolekcji na inną kolekcję. Właściwość tylko do odczytu uniemożliwia zastąpienie kolekcji, lecz nadal umożliwia ustawianie poszczególnych elementów członkowskich.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionPropertiesShouldBeReadOnlyMessage">
        <source>Change '{0}' to be read-only by removing the property setter.</source>
        <target state="translated">Zmień element „{0}” w tylko do odczytu, usuwając metodę ustawiającą właściwości.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverloadOperatorEqualsOnOverridingValueTypeEqualsTitle">
        <source>Overload operator equals on overriding value type Equals</source>
        <target state="translated">Przeciąż operator równości przy przesłanianiu metody Equals dla typu wartości</target>
        <note />
      </trans-unit>
      <trans-unit id="OverloadOperatorEqualsOnOverridingValueTypeEqualsDescription">
        <source>In most programming languages there is no default implementation of the equality operator (==) for value types. If your programming language supports operator overloads, you should consider implementing the equality operator. Its behavior should be identical to that of Equals</source>
        <target state="translated">W większości języków programowania nie ma domyślnej implementacji operatora równości (==) dla typów wartości. Jeśli używasz języka programowania, który obsługuje przeciążanie operatorów, rozważ zaimplementowanie operatora równości. Jego zachowanie powinno być takie samo jak metody Equals.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverloadOperatorEqualsOnOverridingValueTypeEqualsMessage">
        <source>Overload operator equals on overriding value type Equals</source>
        <target state="translated">Przeciąż operator równości przy przesłanianiu metody Equals dla typu wartości</target>
        <note />
      </trans-unit>
      <trans-unit id="PassSystemUriObjectsInsteadOfStringsTitle">
        <source>Pass system uri objects instead of strings</source>
        <target state="translated">Przekazuj systemowe obiekty URI zamiast ciągów</target>
        <note />
      </trans-unit>
      <trans-unit id="PassSystemUriObjectsInsteadOfStringsDescription">
        <source>A call is made to a method that has a string parameter whose name contains "uri", "URI", "urn", "URN", "url", or "URL". The declaring type of the method contains a corresponding method overload that has a System.Uri parameter.</source>
        <target state="translated">Wywołano metodę z parametrem ciągu o nazwie zawierającej ciąg „uri”, „URI”, „urn”, „URN”, „url” lub „URL”. Typ deklarujący metody zawiera odpowiednie przeciążenie metody z parametrem System.Uri.</target>
        <note />
      </trans-unit>
      <trans-unit id="PassSystemUriObjectsInsteadOfStringsMessage">
        <source>Modify '{0}' to call '{1}' instead of '{2}'.</source>
        <target state="translated">Zmodyfikuj element „{0}” w celu wywoływania metody „{1}” zamiast „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIEquatableWhenOverridingObjectEqualsTitle">
        <source>Type {0} should implement IEquatable&lt;T&gt; because it overrides Equals</source>
        <target state="translated">Typ {0} powinien implementować interfejs IEquatable&lt;T&gt;, ponieważ przesłania metodę Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIEquatableWhenOverridingObjectEqualsMessage">
        <source>Implement IEquatable when overriding Object.Equals</source>
        <target state="translated">Zaimplementuj interfejs IEquatable przy przesłanianiu metody Object.Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="CancellationTokenParametersMustComeLastTitle">
        <source>CancellationToken parameters must come last</source>
        <target state="translated">Parametry CancellationToken muszą występować na końcu</target>
        <note />
      </trans-unit>
      <trans-unit id="CancellationTokenParametersMustComeLastMessage">
        <source>Method '{0}' should take CancellationToken as the last parameter</source>
        <target state="translated">Metoda „{0}” powinna pobierać wartość CancellationToken jako ostatni parametr</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstructorMakeNoninheritableBaseClassInheritableTitle">
        <source>Constructor make noninheritable base class inheritable</source>
        <target state="translated">Konstruktor umożliwia dziedziczenie klasy podstawowej nieprzeznaczonej do dziedziczenia</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstructorMakeNoninheritableBaseClassInheritableDescription">
        <source>When a base class is noninheritable because its constructor is internal, a derived class should not make it inheritable by having a public or protected constructor.</source>
        <target state="translated">Jeśli klasa podstawowa nie jest przeznaczona do dziedziczenia, ponieważ ma konstruktor wewnętrzny, to klasa pochodna nie powinna umożliwiać jej dziedziczenia, udostępniając konstruktor publiczny lub chroniony.</target>
        <note />
      </trans-unit>
      <trans-unit id="ConstructorMakeNoninheritableBaseClassInheritableMessage">
        <source>Constructor make noninheritable base class inheritable</source>
        <target state="translated">Konstruktor umożliwia dziedziczenie klasy podstawowej nieprzeznaczonej do dziedziczenia</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainTypeNamesTitle">
        <source>Identifier contains type name</source>
        <target state="translated">Identyfikator zawiera nazwę typu</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainTypeNamesDescription">
        <source>Names of parameters and members are better used to communicate their meaning than to describe their type, which is expected to be provided by development tools. For names of members, if a data type name must be used, use a language-independent name instead of a language-specific one.</source>
        <target state="translated">Nazwy parametrów i elementów członkowskich powinny raczej określać ich znaczenie niż opisywać ich typ, który powinien być udostępniany przez narzędzia programistyczne. Jeśli jest konieczne użycie nazwy typu danych w nazwach elementów członkowskich, użyj nazwy niezależnej od języka zamiast nazwy specyficznej dla języka.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainTypeNamesMessage">
        <source>Identifier '{0}' contains type name</source>
        <target state="translated">Identyfikator „{0}” zawiera nazwę typu</target>
        <note />
      </trans-unit>
      <trans-unit id="CreatePropertyAccessorForParameter">
        <source>Create a property accessor.</source>
        <target state="translated">Utwórz metodę dostępu do właściwości.</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeGetterPublic">
        <source>Make the getter of the property public</source>
        <target state="translated">Zadeklaruj metodę pobierającą właściwość jako publiczną</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeSetterNonPublic">
        <source>Make the setter of the property non-public</source>
        <target state="translated">Zadeklaruj metodę ustawiającą właściwość jako niepubliczną</target>
        <note />
      </trans-unit>
      <trans-unit id="AddAssemblyLevelComVisibleFalse">
        <source>Because {0} exposes externally visible types, mark it with ComVisible(false) at the assembly level and then mark all types within the assembly that should be exposed to COM clients with ComVisible(true).</source>
        <target state="translated">Ponieważ zestaw {0} udostępnia typy widoczne zewnętrznie, oznacz go atrybutem ComVisible(false) na poziomie zestawu, a następnie oznacz atrybutem ComVisible(true) wszystkie typy w zestawie, które powinny być dostępne dla klientów modelu COM.</target>
        <note />
      </trans-unit>
      <trans-unit id="ChangeAssemblyLevelComVisibleToFalse">
        <source>Consider changing the ComVisible attribute on {0} to false, and opting in at the type level.</source>
        <target state="translated">Rozważ zmianę atrybutu ComVisible dla zestawu {0} na wartość false i użycie wartości true na poziomie typów.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementComparable">
        <source>Implement Equality and Comparison methods and operators</source>
        <target state="translated">Zaimplementuj metody i operatory równości i porównania</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementEquatable">
        <source>Implement IEquatable</source>
        <target state="translated">Zaimplementuj interfejs IEquatable</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableInterface">
        <source>Implement IDisposable Interface</source>
        <target state="translated">Zaimplementuj interfejs IDisposable</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkEnumsWithFlagsCodeFix">
        <source>Remove FlagsAttribute from enum.</source>
        <target state="translated">Usuń atrybut FlagsAttribute z wyliczenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkEnumsWithFlagsCodeFix">
        <source>Apply FlagsAttribute to enum.</source>
        <target state="translated">Zastosuj atrybut FlagsAttribute do wyliczenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldZeroValueFlagsMultipleZeroCodeFix">
        <source>Remove all members that have the value zero except for one member that is named 'None'.</source>
        <target state="translated">Usuń wszystkie elementy członkowskie o wartości zero z wyjątkiem elementu członkowskiego o nazwie „None”.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldZeroValueFlagsRenameCodeFix">
        <source>Rename zero-valued enum field to 'None'.</source>
        <target state="translated">Zmień nazwę pola wyliczenia o wartości zero na „None”.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumsShouldZeroValueNotFlagsNoZeroValueCodeFix">
        <source>Add a zero-valued member 'None' to enum.</source>
        <target state="translated">Dodaj element członkowski o wartości zero i nazwie „None” do wyliczenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="AbstractTypesShouldNotHavePublicConstructorsCodeFix">
        <source>Change the accessibility of public constructors to protected.</source>
        <target state="translated">Zmień poziom dostępu do konstruktorów publicznych na chroniony.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareStaticMembersOnGenericTypesTitle">
        <source>Do not declare static members on generic types</source>
        <target state="translated">Nie deklaruj statycznych elementów członkowskich dla typów ogólnych</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareStaticMembersOnGenericTypesDescription">
        <source>When a static member of a generic type is called, the type argument must be specified for the type. When a generic instance member that does not support inference is called, the type argument must be specified for the member. In these two cases, the syntax for specifying the type argument is different and easily confused.</source>
        <target state="translated">Gdy jest wywoływany statyczny element członkowski typu ogólnego, dla tego typu musi być określony argument typu. Gdy jest wywoływany ogólny element członkowski wystąpienia nieobsługujący wnioskowania, dla tego elementu członkowskiego musi być określony argument typu. W tych dwóch przypadkach składnie określania argumentu typu są różne i można je łatwo pomylić.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareStaticMembersOnGenericTypesMessage">
        <source>Do not declare static members on generic types</source>
        <target state="translated">Nie deklaruj statycznych elementów członkowskich dla typów ogólnych</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionsShouldImplementGenericInterfaceTitle">
        <source>Collections should implement generic interface</source>
        <target state="translated">Kolekcje powinny implementować interfejs ogólny</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionsShouldImplementGenericInterfaceDescription">
        <source>To broaden the usability of a collection, implement one of the generic collection interfaces. Then the collection can be used to populate generic collection types.</source>
        <target state="translated">Aby zwiększyć użyteczność kolekcji, zaimplementuj jeden z ogólnych interfejsów kolekcji. Wtedy w kolekcji będzie można umieszczać typy ogólne.</target>
        <note />
      </trans-unit>
      <trans-unit id="CollectionsShouldImplementGenericInterfaceMessage">
        <source>Collection '{0}' directly or indirectly inherits '{1}' without implementing '{2}'. Publicly-visible collections should implement the generic version to broaden usability.</source>
        <target state="translated">Kolekcja „{0}” bezpośrednio lub pośrednio dziedziczy element „{1}” bez implementowania elementu „{2}”. Kolekcje widoczne publicznie powinny dziedziczyć wersję ogólną w celu rozszerzenia użyteczności.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumStorageShouldBeInt32Title">
        <source>Enum Storage should be Int32</source>
        <target state="translated">Wyliczenia powinny być przechowywane jako typ Int32</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumStorageShouldBeInt32Description">
        <source>An enumeration is a value type that defines a set of related named constants. By default, the System.Int32 data type is used to store the constant value. Although you can change this underlying type, it is not required or recommended for most scenarios.</source>
        <target state="translated">Wyliczenie to typ wartości, który definiuje zestaw powiązanych stałych nazwanych. Domyślnie do przechowywania wartości stałej jest używany typ danych System.Int32. Można zmienić ten typ bazowy, ale nie jest to wymagane ani zalecane w większości scenariuszy.</target>
        <note />
      </trans-unit>
      <trans-unit id="EnumStorageShouldBeInt32Message">
        <source>If possible, make the underlying type of {0} System.Int32 instead of {1}.</source>
        <target state="translated">Jeśli to możliwe, zmień typ bazowy wyliczenia {0} na System.Int32 zamiast {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEventsWhereAppropriateTitle">
        <source>Use events where appropriate</source>
        <target state="translated">Użyj zdarzeń w odpowiednich miejscach</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEventsWhereAppropriateDescription">
        <source>This rule detects methods that have names that ordinarily would be used for events. If a method is called in response to a clearly defined state change, the method should be invoked by an event handler. Objects that call the method should raise events instead of calling the method directly.</source>
        <target state="translated">Ta reguła wykrywa metody z nazwami, które zwykle są używane dla zdarzeń. Jeśli metoda jest wywoływana w odpowiedzi na wyraźnie zdefiniowaną zmianę stanu, powinna być wywoływana przez procedurę obsługi zdarzeń. Obiekty wywołujące metodę powinny zgłaszać zdarzenia zamiast bezpośredniego wywoływania metody.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseEventsWhereAppropriateMessage">
        <source>Consider making '{0}' an event.</source>
        <target state="translated">Rozważ przekształcenie metody „{0}” w zdarzenie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementStandardExceptionConstructorsTitle">
        <source>Implement standard exception constructors</source>
        <target state="translated">Zaimplementuj standardowe konstruktory wyjątku</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementStandardExceptionConstructorsDescription">
        <source>Failure to provide the full set of constructors can make it difficult to correctly handle exceptions.</source>
        <target state="translated">Jeśli pełny zestaw konstruktorów nie zostanie zdefiniowany, może to utrudnić poprawną obsługę wyjątków.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementStandardExceptionConstructorsMessageMissingConstructor">
        <source>Add the following constructor to {0}: {1}.</source>
        <target state="translated">Dodaj następujący konstruktor do elementu {0}: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementStandardExceptionConstructorsMessageAccessibility">
        <source>Change the accessibility of {0} to {1}.</source>
        <target state="translated">Zmień dostępność elementu {0} na {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="NestedTypesShouldNotBeVisibleTitle">
        <source>Nested types should not be visible</source>
        <target state="translated">Typy zagnieżdżone nie powinny być widoczne</target>
        <note />
      </trans-unit>
      <trans-unit id="NestedTypesShouldNotBeVisibleDescription">
        <source>A nested type is a type that is declared in the scope of another type. Nested types are useful to encapsulate private implementation details of the containing type. Used for this purpose, nested types should not be externally visible.</source>
        <target state="translated">Typ zagnieżdżony to typ zadeklarowany w zakresie innego typu. Typy zagnieżdżone są przydatne do hermetyzowania prywatnych szczegółów implementacji zawierającego typu. Typy zagnieżdżone użyte do tego celu nie powinny być widoczne zewnętrznie.</target>
        <note />
      </trans-unit>
      <trans-unit id="NestedTypesShouldNotBeVisibleMessageDefault">
        <source>Do not nest type {0}. Alternatively, change its accessibility so that it is not externally visible.</source>
        <target state="translated">Nie zagnieżdżaj typu {0}. Możesz też zmienić jego dostępność tak, aby nie był widoczny zewnętrznie.</target>
        <note />
      </trans-unit>
      <trans-unit id="NestedTypesShouldNotBeVisibleMessageVisualBasicModule">
        <source>Do not nest type {0}. Alternatively, change its accessibility so that it is not externally visible. If this type is defined in a Visual Basic Module, it will be considered a nested type to other .NET languages. In that case, consider moving the type outside of the Module.</source>
        <target state="translated">Nie zagnieżdżaj typu {0}. Możesz też zmienić jego dostępność tak, aby nie był widoczny zewnętrznie. Jeśli ten typ jest zdefiniowany w module języka Visual Basic, będzie uznawany za typ zagnieżdżony przez inne języki .NET. W takim przypadku rozważ przeniesienie typu poza moduł.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidEmptyInterfacesTitle">
        <source>Avoid empty interfaces</source>
        <target state="translated">Unikaj pustych interfejsów</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidEmptyInterfacesDescription">
        <source>Interfaces define members that provide a behavior or usage contract. The functionality that is described by the interface can be adopted by any type, regardless of where the type appears in the inheritance hierarchy. A type implements an interface by providing implementations for the members of the interface. An empty interface does not define any members; therefore, it does not define a contract that can be implemented.</source>
        <target state="translated">Interfejsy definiują elementy członkowskie udostępniające kontrakt zachowania lub użycia. Funkcjonalność opisana przez interfejs może zostać zaadaptowana przez dowolny typ, niezależnie od miejsca występowania tego typu w hierarchii dziedziczenia. Typ implementuje interfejs przez udostępnienie implementacji dla elementów członkowskich interfejsu. Pusty interfejs nie definiuje żadnych elementów członkowskich, a zatem nie definiuje kontraktu, który można zaimplementować.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidEmptyInterfacesMessage">
        <source>Avoid empty interfaces</source>
        <target state="translated">Unikaj pustych interfejsów</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideObsoleteAttributeMessageTitle">
        <source>Provide ObsoleteAttribute message</source>
        <target state="translated">Określ komunikat dla atrybutu ObsoleteAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideObsoleteAttributeMessageDescription">
        <source>A type or member is marked by using a System.ObsoleteAttribute attribute that does not have its ObsoleteAttribute.Message property specified. When a type or member that is marked by using ObsoleteAttribute is compiled, the Message property of the attribute is displayed. This gives the user information about the obsolete type or member.</source>
        <target state="translated">Typ lub element członkowski jest oznaczony atrybutem System.ObsoleteAttribute, dla którego nie określono właściwości ObsoleteAttribute.Message. Gdy jest kompilowany typ lub element członkowski oznaczony atrybutem ObsoleteAttribute, wyświetlana jest właściwość Message atrybutu. Zapewnia to użytkownikowi informację o przestarzałym typie lub elemencie członkowskim.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideObsoleteAttributeMessageMessage">
        <source>Provide a message for the ObsoleteAttribute that marks {0} as Obsolete</source>
        <target state="translated">Określ komunikat dla atrybutu ObsoleteAttribute, który oznacza element {0} jako przestarzały</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotBeWriteOnlyTitle">
        <source>Properties should not be write only</source>
        <target state="translated">Właściwości nie powinny być dostępne tylko do zapisu</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotBeWriteOnlyDescription">
        <source>Although it is acceptable and often necessary to have a read-only property, the design guidelines prohibit the use of write-only properties. This is because letting a user set a value, and then preventing the user from viewing that value, does not provide any security. Also, without read access, the state of shared objects cannot be viewed, which limits their usefulness.</source>
        <target state="translated">Używanie właściwości tylko do odczytu jest akceptowalne i często konieczne, ale zasady projektowania zakazują używania właściwości tylko do zapisu. Przyczyną jest to, że umożliwienie użytkownikowi ustawienia wartości, a następnie uniemożliwienie odczytywania tej wartości nie stanowi żadnego zabezpieczenia. Bez dostępu do odczytu nie można także odczytywać stanu obiektów udostępnionych, co ogranicza ich użyteczność.</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotBeWriteOnlyMessageAddGetter">
        <source>Because property {0} is write-only, either add a property getter with an accessibility that is greater than or equal to its setter or convert this property into a method.</source>
        <target state="translated">Ponieważ właściwość {0} jest właściwością tylko do zapisu, dodaj metodę pobierającą właściwość z dostępnością co najmniej taką samą lub większą niż jej metoda ustawiająca albo przekonwertuj tę właściwość na metodę.</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotBeWriteOnlyMessageMakeMoreAccessible">
        <source>Because the property getter for {0} is less visible than its setter, either increase the accessibility of its getter or decrease the accessibility of its setter.</source>
        <target state="translated">Ponieważ metoda pobierająca właściwość {0} ma mniejszą widoczność niż jej metoda ustawiająca, zwiększ dostępność metody pobierającej lub zmniejsz dostępność metody ustawiającej.</target>
        <note />
      </trans-unit>
      <trans-unit id="DeclareTypesInNamespacesTitle">
        <source>Declare types in namespaces</source>
        <target state="translated">Zadeklaruj typy w przestrzeniach nazw</target>
        <note />
      </trans-unit>
      <trans-unit id="DeclareTypesInNamespacesDescription">
        <source>Types are declared in namespaces to prevent name collisions and as a way to organize related types in an object hierarchy.</source>
        <target state="translated">Typy są deklarowane w przestrzeniach nazw w celu uniknięcia kolizji nazw oraz jako sposób organizowania powiązanych typów w hierarchię obiektów.</target>
        <note />
      </trans-unit>
      <trans-unit id="DeclareTypesInNamespacesMessage">
        <source>Declare types in namespaces</source>
        <target state="translated">Zadeklaruj typy w przestrzeniach nazw</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareVisibleInstanceFieldsTitle">
        <source>Do not declare visible instance fields</source>
        <target state="translated">Nie deklaruj widocznych pól wystąpień</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareVisibleInstanceFieldsDescription">
        <source>The primary use of a field should be as an implementation detail. Fields should be private or internal and should be exposed by using properties.</source>
        <target state="translated">Pole powinno być używane przede wszystkim jako szczegół implementacji. Pola powinny być prywatne lub wewnętrzne i powinny być udostępniane za pomocą właściwości.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDeclareVisibleInstanceFieldsMessage">
        <source>Do not declare visible instance fields</source>
        <target state="translated">Nie deklaruj widocznych pól wystąpień</target>
        <note />
      </trans-unit>
      <trans-unit id="UriParametersShouldNotBeStringsTitle">
        <source>Uri parameters should not be strings</source>
        <target state="translated">Parametry z identyfikatorami URI nie powinny być ciągami</target>
        <note />
      </trans-unit>
      <trans-unit id="UriParametersShouldNotBeStringsDescription">
        <source>If a method takes a string representation of a URI, a corresponding overload should be provided that takes an instance of the URI class, which provides these services in a safe and secure manner.</source>
        <target state="translated">Jeśli metoda pobiera reprezentację identyfikatora URI w postaci ciągu, należy określić odpowiednie przeciążenie, które pobiera wystąpienie klasy URI udostępniające te usługi w bezpieczny sposób.</target>
        <note />
      </trans-unit>
      <trans-unit id="UriParametersShouldNotBeStringsMessage">
        <source>Change the type of parameter {0} of method {1} from string to System.Uri, or provide an overload to {1} that allows {0} to be passed as a System.Uri object.</source>
        <target state="translated">Zmień typ parametru {0} metody {1} z ciągu na System.Uri lub określ przeciążenie metody {1} umożliwiające przekazanie parametru {0} jako obiektu System.Uri.</target>
        <note />
      </trans-unit>
      <trans-unit id="UriReturnValuesShouldNotBeStringsTitle">
        <source>Uri return values should not be strings</source>
        <target state="translated">Zwracane wartości identyfikatorów URI nie powinny być ciągami</target>
        <note />
      </trans-unit>
      <trans-unit id="UriReturnValuesShouldNotBeStringsDescription">
        <source>This rule assumes that the method returns a URI. A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner.</source>
        <target state="translated">W tej regule przyjęto, że metoda zwraca identyfikator URI. Reprezentacja identyfikatora URI w postaci ciągu jest narażona na błędy analizy i kodowania oraz może powodować luki w zabezpieczeniach. Klasa System.Uri udostępnia te usługi w bezpieczny sposób.</target>
        <note />
      </trans-unit>
      <trans-unit id="UriReturnValuesShouldNotBeStringsMessage">
        <source>Change the return type of method {0} from string to System.Uri.</source>
        <target state="translated">Zmień zwracany typ metody {0} z ciągu na System.Uri.</target>
        <note />
      </trans-unit>
      <trans-unit id="UriPropertiesShouldNotBeStringsTitle">
        <source>Uri properties should not be strings</source>
        <target state="translated">Właściwości z identyfikatorami URI nie powinny być ciągami</target>
        <note />
      </trans-unit>
      <trans-unit id="UriPropertiesShouldNotBeStringsDescription">
        <source>This rule assumes that the property represents a Uniform Resource Identifier (URI). A string representation of a URI is prone to parsing and encoding errors, and can lead to security vulnerabilities. The System.Uri class provides these services in a safe and secure manner.</source>
        <target state="translated">W tej regule przyjęto, że właściwość reprezentuje identyfikator URI (Uniform Resource Identifier). Reprezentacja identyfikatora URI w postaci ciągu jest narażona na błędy analizy i kodowania oraz może powodować luki w zabezpieczeniach. Klasa System.Uri udostępnia te usługi w bezpieczny sposób.</target>
        <note />
      </trans-unit>
      <trans-unit id="UriPropertiesShouldNotBeStringsMessage">
        <source>Change the type of property {0} from string to System.Uri.</source>
        <target state="translated">Zmień typ właściwości {0} z ciągu na System.Uri.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyTitle">
        <source>Implement IDisposable Correctly</source>
        <target state="translated">Zaimplementuj poprawnie interfejs IDisposable</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyDescription">
        <source>All IDisposable types should implement the Dispose pattern correctly.</source>
        <target state="translated">Wszystkie typy IDisposable powinny poprawnie implementować wzorzec Dispose.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageIDisposableReimplementation">
        <source>Remove IDisposable from the list of interfaces implemented by '{0}' as it is already implemented by base type '{1}'.</source>
        <target state="translated">Usuń interfejs IDisposable z listy interfejsów implementowanych przez element „{0}”, ponieważ jest on już implementowany przez typ bazowy „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageDisposeOverride">
        <source>Remove '{0}', override Dispose(bool disposing), and put the dispose logic in the code path where 'disposing' is true.</source>
        <target state="translated">Usuń funkcję „{0}”, przesłoń funkcję Dispose(bool disposing) i umieść logikę usuwania w ścieżce kodu, gdzie element „disposing” ma wartość true.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageDisposeSignature">
        <source>Ensure that '{0}' is declared as public and sealed.</source>
        <target state="translated">Upewnij się, że element „{0}” jest zadeklarowany jako public i sealed.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageRenameDispose">
        <source>Rename '{0}' to 'Dispose' and ensure that it is declared as public and sealed.</source>
        <target state="translated">Zmień nazwę elementu „{0}” na „Dispose” i upewnij się, że jest on zadeklarowany jako public i sealed.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageDisposeBoolSignature">
        <source>Ensure that '{0}' is declared as protected, virtual, and unsealed.</source>
        <target state="translated">Upewnij się, że element „{0}” jest zadeklarowany jako protected, virtual i unsealed.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageDisposeImplementation">
        <source>Modify '{0}' so that it calls Dispose(true), then calls GC.SuppressFinalize on the current object instance ('this' or 'Me' in Visual Basic), and then returns.</source>
        <target state="translated">Zmodyfikuj element „{0}” tak, aby wywoływał funkcję Dispose(true), a następnie wywoływał funkcję GC.SuppressFinalize dla bieżącego wystąpienia obiektu („this” lub „Me” w języku Visual Basic), po czym wykonywał instrukcję return.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageFinalizeImplementation">
        <source>Modify '{0}' so that it calls Dispose(false) and then returns.</source>
        <target state="translated">Zmodyfikuj element „{0}” tak, aby wywoływał funkcję Dispose(false), a następnie wykonywał instrukcję return.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIDisposableCorrectlyMessageProvideDisposeBool">
        <source>Provide an overridable implementation of Dispose(bool) on '{0}' or mark the type as sealed. A call to Dispose(false) should only clean up native resources. A call to Dispose(true) should clean up both managed and native resources.</source>
        <target state="translated">Zapewnij możliwą do zastąpienia implementację funkcji Dispose(bool) dla elementu „{0}” lub oznacz typ jako sealed. Wywołanie funkcji Dispose(false) powinno czyścić tylko zasoby natywne. Wywołanie funkcji Dispose(true) powinno czyścić zasoby zarządzane i natywne.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionsShouldBePublicTitle">
        <source>Exceptions should be public</source>
        <target state="translated">Wyjątki powinny być publiczne</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionsShouldBePublicDescription">
        <source>An internal exception is visible only inside its own internal scope. After the exception falls outside the internal scope, only the base exception can be used to catch the exception. If the internal exception is inherited from T:System.Exception, T:System.SystemException, or T:System.ApplicationException, the external code will not have sufficient information to know what to do with the exception.</source>
        <target state="translated">Wyjątek wewnętrzny jest widoczny tylko wewnątrz własnego zakresu wewnętrznego. Gdy wyjątek zostanie przekazany poza zakres wewnętrzny, do przechwycenia tego wyjątku można użyć tylko wyjątku podstawowego. Jeśli wyjątek wewnętrzny jest dziedziczony z wyjątku T:System.Exception, T:System.SystemException lub T:System.ApplicationException, kod zewnętrzny nie będzie miał wystarczających informacji do określenia, co zrobić z wyjątkiem.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExceptionsShouldBePublicMessage">
        <source>Exceptions should be public</source>
        <target state="translated">Wyjątki powinny być publiczne</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsTitle">
        <source>Do not raise exceptions in unexpected locations</source>
        <target state="translated">Nie zgłaszaj wyjątków w nieoczekiwanych lokalizacjach</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsDescription">
        <source>A method that is not expected to throw exceptions throws an exception.</source>
        <target state="translated">Wyjątek zgłasza metoda, od której nie oczekuje się zgłaszania wyjątków.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsMessagePropertyGetter">
        <source>{0} creates an exception of type {1}, an exception type that should not be raised in a property. If this exception instance might be raised, use a different exception type, convert this property into a method, or change this property's logic so that it no longer raises an exception.</source>
        <target state="translated">Właściwość {0} tworzy wyjątek typu {1}, który nie powinien być zgłaszany przez właściwość. Jeśli to wystąpienie wyjątku może zostać zgłoszone, użyj innego typu wyjątku, przekonwertuj tę właściwość na metodę lub zmień logikę tej właściwości tak, aby nie zgłaszała wyjątku.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsMessageHasAllowedExceptions">
        <source>{0} creates an exception of type {1}, an exception type that should not be raised in this type of method. If this exception instance might be raised, either use a different exception type or change this method's logic so that it no longer raises an exception.</source>
        <target state="translated">Metoda {0} tworzy wyjątek typu {1}, który nie powinien być zgłaszany przez metodę tego typu. Jeśli to wystąpienie wyjątku może zostać zgłoszone, użyj innego typu wyjątku lub zmień logikę tej metody tak, aby nie zgłaszała wyjątku.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInUnexpectedLocationsMessageNoAllowedExceptions">
        <source>{0} creates an exception of type {1}. Exceptions should not be raised in this type of method. If this exception instance might be raised, change this method's logic so it no longer raises an exception.</source>
        <target state="translated">Metoda {0} tworzy wyjątek typu {1}. Ten typ metody nie powinien zgłaszać wyjątków. Jeśli to wystąpienie wyjątku może zostać zgłoszone, zmień logikę tej metody tak, aby nie zgłaszała wyjątku.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresTitle">
        <source>Identifiers should not contain underscores</source>
        <target state="translated">Identyfikatory nie powinny zawierać znaków podkreślenia</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresDescription">
        <source>By convention, identifier names do not contain the underscore (_) character. This rule checks namespaces, types, members, and parameters.</source>
        <target state="translated">Według konwencji nazwy identyfikatorów nie powinny zawierać znaku podkreślenia (_). Ta reguła sprawdza przestrzenie nazw, typy, elementy członkowskie i parametry.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageAssembly">
        <source>Remove the underscores from assembly name {0}.</source>
        <target state="translated">Usuń znaki podkreślenia z nazwy zestawu {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageNamespace">
        <source>Remove the underscores from namespace name '{0}'.</source>
        <target state="translated">Usuń znaki podkreślenia z nazwy przestrzeni nazw „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageType">
        <source>Remove the underscores from type name {0}.</source>
        <target state="translated">Usuń znaki podkreślenia z nazwy typu {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageMember">
        <source>Remove the underscores from member name {0}.</source>
        <target state="translated">Usuń znaki podkreślenia z nazwy elementu członkowskiego {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageTypeTypeParameter">
        <source>On type {0}, remove the underscores from generic type parameter name {1}.</source>
        <target state="translated">W typie {0} usuń znaki podkreślenia z nazwy parametru typu ogólnego {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageMethodTypeParameter">
        <source>On method {0}, remove the underscores from generic type parameter name {1}.</source>
        <target state="translated">W metodzie {0} usuń znaki podkreślenia z nazwy parametru typu ogólnego {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageMemberParameter">
        <source>In member {0}, remove the underscores from parameter name {1}.</source>
        <target state="translated">W elemencie członkowskim {0} usuń znaki podkreślenia z nazwy parametru {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotContainUnderscoresMessageDelegateParameter">
        <source>In delegate {0}, remove the underscores from parameter name {1}.</source>
        <target state="translated">W delegacie {0} usuń znaki podkreślenia z nazwy parametru {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectSuffixTitle">
        <source>Identifiers should have correct suffix</source>
        <target state="translated">Identyfikatory powinny mieć poprawny sufiks</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectSuffixDescription">
        <source>By convention, the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, have a suffix that is associated with the base type or interface.</source>
        <target state="translated">Według konwencji nazwy typów rozszerzających pewne typy podstawowe, implementujące pewne interfejsy lub pochodzące od tych typów mają sufiks skojarzony z podstawowym typem lub interfejsem.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectSuffixMessageDefault">
        <source>Rename {0} to end in '{1}'.</source>
        <target state="translated">Zmień nazwę {0} tak, aby kończyła się sufiksem „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldHaveCorrectSuffixMessageSpecialCollection">
        <source>Rename {0} to end in either 'Collection' or '{1}'.</source>
        <target state="translated">Zmień nazwę {0} tak, aby kończyła się sufiksem „Collection” lub „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixTitle">
        <source>Identifiers should not have incorrect suffix</source>
        <target state="translated">Identyfikatory nie powinny mieć niepoprawnego sufiksu</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixDescription">
        <source>By convention, only the names of types that extend certain base types or that implement certain interfaces, or types that are derived from these types, should end with specific reserved suffixes. Other type names should not use these reserved suffixes.</source>
        <target state="translated">Według konwencji tylko nazwy typów rozszerzających pewne typy podstawowe, implementujące pewne interfejsy lub pochodzące od tych typów powinny kończyć się określonymi zastrzeżonymi sufiksami. Inne nazwy typów nie powinny używać tych zastrzeżonych sufiksów.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixMessageTypeNoAlternate">
        <source>Rename type name {0} so that it does not end in '{1}'.</source>
        <target state="translated">Zmień nazwę typu {0} tak, aby nie kończyła się sufiksem „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixMessageMemberNewerVersion">
        <source>Either replace the suffix '{0}' in member name {1} with the suggested numeric alternate '2' or provide a more meaningful suffix that distinguishes it from the member it replaces.</source>
        <target state="translated">Zamień sufiks „{0}” w nazwie elementu członkowskiego {1} na zalecany alternatywny sufiks liczbowy „2” lub określ bardziej opisowy sufiks, który umożliwi odróżnienie go od zamienianego elementu członkowskiego.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixMessageTypeNewerVersion">
        <source>Either replace the suffix '{0}' in type name {1} with the suggested numeric alternate '2' or provide a more meaningful suffix that distinguishes it from the type it replaces.</source>
        <target state="translated">Zamień sufiks „{0}” w nazwie typu {1} na zalecany alternatywny sufiks liczbowy „2” lub określ bardziej opisowy sufiks, który umożliwi odróżnienie go od zamienianego typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotHaveIncorrectSuffixMessageMemberWithAlternate">
        <source>Either replace the suffix '{0}' in member name '{1}' with the suggested alternate '{2}' or remove the suffix completely.</source>
        <target state="translated">Zamień sufiks „{0}” w nazwie elementu członkowskiego „{1}” na zalecany alternatywny sufiks „{2}” lub całkowicie usuń sufiks.</target>
        <note />
      </trans-unit>
      <trans-unit id="FlagsEnumsShouldHavePluralNamesTitle">
        <source>Flags enums should have plural names</source>
        <target state="translated">Wyliczenia z flagami powinny mieć nazwy w liczbie mnogiej</target>
        <note />
      </trans-unit>
      <trans-unit id="FlagsEnumsShouldHavePluralNamesDescription">
        <source>A public enumeration has the System.FlagsAttribute attribute, and its name does not end in ""s"". Types that are marked by using FlagsAttribute have names that are plural because the attribute indicates that more than one value can be specified.</source>
        <target state="translated">Wyliczenie publiczne ma atrybut System.FlagsAttribute, lecz jego nazwa nie kończy się literą „s”. Nazwy typów oznaczonych atrybutem FlagsAttribute mają nazwy w liczbie mnogiej, ponieważ ten atrybut wskazuje, że można określić więcej niż jedną wartość.</target>
        <note />
      </trans-unit>
      <trans-unit id="FlagsEnumsShouldHavePluralNamesMessage">
        <source>Flags enums should have plural names</source>
        <target state="translated">Wyliczenia z flagami powinny mieć nazwy w liczbie mnogiej</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsTitle">
        <source>Identifiers should not match keywords</source>
        <target state="translated">Identyfikatory nie powinny być takie same jak słowa kluczowe</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsDescription">
        <source>A namespace name or a type name matches a reserved keyword in a programming language. Identifiers for namespaces and types should not match keywords that are defined by languages that target the common language runtime.</source>
        <target state="translated">Nazwa przestrzeni nazw lub nazwa typu jest taka sama jak zastrzeżone słowo kluczowe języka programowania. Identyfikatory przestrzeni nazw i typów nie powinny być takie same jak słowa kluczowe zdefiniowane przez języki docelowe środowiska uruchomieniowego języka wspólnego.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsMessageMemberParameter">
        <source>In virtual/interface member {0}, rename parameter {1} so that it no longer conflicts with the reserved language keyword '{2}'. Using a reserved keyword as the name of a parameter on a virtual/interface member makes it harder for consumers in other languages to override/implement the member.</source>
        <target state="translated">W elemencie członkowskim interfejsu lub wirtualnym elemencie członkowskim {0} zmień nazwę parametru {1} tak, aby nie powodowała konfliktu z zastrzeżonym słowem kluczowym języka „{2}”. Użycie zastrzeżonego słowa kluczowego jako nazwy parametru w elemencie członkowskim interfejsu lub wirtualnym elemencie członkowskim utrudnia klientom w innych językach przesłonięcie/zaimplementowanie tego elementu członkowskiego.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsMessageMember">
        <source>Rename virtual/interface member {0} so that it no longer conflicts with the reserved language keyword '{1}'. Using a reserved keyword as the name of a virtual/interface member makes it harder for consumers in other languages to override/implement the member.</source>
        <target state="translated">Zmień nazwę elementu członkowskiego interfejsu lub wirtualnego elementu członkowskiego {0} tak, aby nie powodowała konfliktu z zastrzeżonym słowem kluczowym języka „{1}”. Użycie zastrzeżonego słowa kluczowego jako nazwy elementu członkowskiego interfejsu lub wirtualnego elementu członkowskiego utrudnia klientom w innych językach przesłonięcie/zaimplementowanie tego elementu członkowskiego.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsMessageType">
        <source>Rename type {0} so that it no longer conflicts with the reserved language keyword '{1}'. Using a reserved keyword as the name of a type makes it harder for consumers in other languages to use the type.</source>
        <target state="translated">Zmień nazwę typu {0} tak, aby nie powodowała konfliktu z zastrzeżonym słowem kluczowym języka „{1}”. Użycie zastrzeżonego słowa kluczowego jako nazwy typu utrudnia klientom użycie tego typu w innych językach.</target>
        <note />
      </trans-unit>
      <trans-unit id="IdentifiersShouldNotMatchKeywordsMessageNamespace">
        <source>Rename namespace {0} so that it no longer conflicts with the reserved language keyword '{1}'. Using a reserved keyword as the name of a namespace makes it harder for consumers in other languages to use the namespace.</source>
        <target state="translated">Zmień nazwę przestrzeni nazw {0} tak, aby nie powodowała konfliktu z zastrzeżonym słowem kluczowym języka „{1}”. Użycie zastrzeżonego słowa kluczowego jako nazwy przestrzeni nazw utrudnia klientom użycie tej przestrzeni nazw w innych językach.</target>
        <note />
      </trans-unit>
      <trans-unit id="OnlyFlagsEnumsShouldHavePluralNamesTitle">
        <source>Only FlagsAttribute enums should have plural names</source>
        <target state="translated">Tylko wyliczenia z atrybutem FlagsAttribute powinny mieć nazwy w liczbie mnogiej</target>
        <note />
      </trans-unit>
      <trans-unit id="OnlyFlagsEnumsShouldHavePluralNamesDescription">
        <source>Naming conventions dictate that a plural name for an enumeration indicates that more than one value of the enumeration can be specified at the same time.</source>
        <target state="translated">Konwencje nazewnictwa określają, że nazwa wyliczenia w liczbie mnogiej wskazuje, iż jednocześnie można określić wiele wartości wyliczenia.</target>
        <note />
      </trans-unit>
      <trans-unit id="OnlyFlagsEnumsShouldHavePluralNamesMessage">
        <source>Only FlagsAttribute enums should have plural names</source>
        <target state="translated">Tylko wyliczenia z atrybutem FlagsAttribute powinny mieć nazwy w liczbie mnogiej</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertyNamesShouldNotMatchGetMethodsTitle">
        <source>Property names should not match get methods</source>
        <target state="translated">Nazwy właściwości nie powinny być takie same jak nazwy metod pobierających</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertyNamesShouldNotMatchGetMethodsDescription">
        <source>The name of a public or protected member starts with ""Get"" and otherwise matches the name of a public or protected property. ""Get"" methods and properties should have names that clearly distinguish their function.</source>
        <target state="translated">Nazwa publicznego lub chronionego elementu członkowskiego zaczyna się od „Get” i jest taka sama jak nazwa właściwości publicznej lub chronionej. Metody i właściwości „Get” powinny mieć nazwy jasno określające ich funkcję.</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertyNamesShouldNotMatchGetMethodsMessage">
        <source>The property name '{0}' is confusing given the existence of method '{1}'. Rename or remove one of these members.</source>
        <target state="translated">Nazwa właściwości „{0}” jest myląca ze względu na istnienie metody „{1}”. Zmień nazwę jednego z tych elementów członkowskich lub usuń go.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNamesShouldNotMatchNamespacesTitle">
        <source>Type names should not match namespaces</source>
        <target state="translated">Nazwy typów nie powinny być takie same jak przestrzenie nazw</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNamesShouldNotMatchNamespacesDescription">
        <source>Type names should not match the names of namespaces that are defined in the .NET Framework class library. Violating this rule can reduce the usability of the library.</source>
        <target state="translated">Nazwy typów nie powinny być takie same jak nazwy przestrzeni nazw zdefiniowane w bibliotece klas programu .NET Framework. Naruszenie tej reguły może zmniejszyć użyteczność biblioteki.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNamesShouldNotMatchNamespacesMessageDefault">
        <source>The type name {0} conflicts in whole or in part with the namespace name '{1}'. Change either name to eliminate the conflict.</source>
        <target state="translated">Nazwa typu {0} powoduje konflikt w całości lub częściowo z nazwą przestrzeni nazw „{1}”. Zmień jedną z tych nazw, aby wyeliminować konflikt.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypeNamesShouldNotMatchNamespacesMessageSystem">
        <source>The type name {0} conflicts in whole or in part with the namespace name '{1}' defined in the .NET Framework. Rename the type to eliminate the conflict.</source>
        <target state="translated">Nazwa typu {0} powoduje konflikt w całości lub częściowo z nazwą przestrzeni nazw „{1}” zdefiniowaną w programie .NET Framework. Zmień nazwę typu, aby wyeliminować konflikt.</target>
        <note />
      </trans-unit>
      <trans-unit id="ParameterNamesShouldMatchBaseDeclarationTitle">
        <source>Parameter names should match base declaration</source>
        <target state="translated">Nazwy parametrów powinny być zgodne z deklaracją podstawową</target>
        <note />
      </trans-unit>
      <trans-unit id="ParameterNamesShouldMatchBaseDeclarationDescription">
        <source>Consistent naming of parameters in an override hierarchy increases the usability of the method overrides. A parameter name in a derived method that differs from the name in the base declaration can cause confusion about whether the method is an override of the base method or a new overload of the method.</source>
        <target state="translated">Spójne nazewnictwo parametrów w hierarchii przesłaniania zwiększa użyteczność przesłonięć metod. Nazwa parametru w metodzie pochodnej różniąca się od nazwy w deklaracji podstawowej może utrudnić zrozumienie tego, czy metoda przesłania metodę podstawową, czy jest jej nowym przeciążeniem.</target>
        <note />
      </trans-unit>
      <trans-unit id="ParameterNamesShouldMatchBaseDeclarationMessage">
        <source>In member {0}, change parameter name {1} to {2} in order to match the identifier as it has been declared in {3}.</source>
        <target state="translated">W elemencie członkowskim {0} zmień nazwę parametru {1} na {2}, aby zapewnić zgodność z identyfikatorem zadeklarowanym w elemencie {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsTitle">
        <source>Use preferred terms</source>
        <target state="translated">Używaj preferowanych terminów</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsDescription">
        <source>The name of an externally visible identifier includes a term for which an alternative, preferred term exists. Alternatively, the name includes the term ""Flag"" or ""Flags"".</source>
        <target state="translated">Nazwa zewnętrznie widocznego identyfikatora zawiera termin, który ma preferowany termin alternatywny. Inna możliwość to ciąg „Flag” lub „Flags” znajdujący się w terminie.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageAssembly">
        <source>Replace the term '{0}' in assembly name {1} with the preferred alternate '{2}'.</source>
        <target state="translated">Zamień termin „{0}” w nazwie zestawu {1} na preferowany termin alternatywny „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageNamespace">
        <source>Replace the term '{0}' in namespace name '{1}' with the preferred alternate '{2}'.</source>
        <target state="translated">Zamień termin „{0}” w nazwie przestrzeni nazw {1} na preferowany termin alternatywny „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageMemberParameter">
        <source>In member {0}, replace the term '{1}' in parameter name {2} with the preferred alternate '{3}'.</source>
        <target state="translated">W elemencie członkowskim {0} zamień termin „{1}” w nazwie parametru {2} na preferowany termin alternatywny „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageDelegateParameter">
        <source>In delegate {0}, replace the term '{1}' in parameter name {2} with the preferred alternate '{3}'.</source>
        <target state="translated">W delegacie {0} zamień termin „{1}” w nazwie parametru {2} na preferowany termin alternatywny „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageTypeTypeParameter">
        <source>On type {0}, replace the term '{1}' in generic type parameter name {2} with the preferred alternate '{3}'.</source>
        <target state="translated">W typie {0} zamień termin „{1}” w nazwie parametru typu ogólnego {2} na preferowany termin alternatywny „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageMethodTypeParameter">
        <source>On method {0}, replace the term '{1}' in generic type parameter name {2} with the preferred alternate '{3}'.</source>
        <target state="translated">W metodzie {0} zamień termin „{1}” w nazwie parametru typu ogólnego {2} na preferowany termin alternatywny „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageType">
        <source>Replace the term '{0}' in type name {1} with the preferred alternate '{2}'.</source>
        <target state="translated">Zamień termin „{0}” w nazwie typu {1} na preferowany termin alternatywny „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageMember">
        <source>Replace the term '{0}' in member name {1} with the preferred alternate '{2}'.</source>
        <target state="translated">Zamień termin „{0}” w nazwie elementu członkowskiego {1} na preferowany termin alternatywny „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageAssemblyNoAlternate">
        <source>Replace the term '{0}' in assembly name {1} with an appropriate alternate or remove it entirely.</source>
        <target state="translated">Zamień termin „{0}” w nazwie zestawu {1} na odpowiedni termin alternatywny lub usuń go całkowicie.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageNamespaceNoAlternate">
        <source>Replace the term '{0}' in namespace name '{1}' with an appropriate alternate or remove it entirely.</source>
        <target state="translated">Zamień termin „{0}” w nazwie przestrzeni nazw „{1}” na odpowiedni termin alternatywny lub usuń go całkowicie.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageMemberParameterNoAlternate">
        <source>In member {0}, replace the term '{1}' in parameter name {2} with an appropriate alternate or remove it entirely.</source>
        <target state="translated">W elemencie członkowskim {0} zamień termin „{1}” w nazwie parametru {2} na odpowiedni termin alternatywny lub usuń go całkowicie.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageDelegateParameterNoAlternate">
        <source>In delegate {0}, replace the term '{1}' in parameter name {2} with an appropriate alternate or remove it entirely.</source>
        <target state="translated">W delegacie {0} zamień termin „{1}” w nazwie parametru {2} na odpowiedni termin alternatywny lub usuń go całkowicie.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageTypeTypeParameterNoAlternate">
        <source>On type {0}, replace the term '{1}' in generic type parameter name {2} with an appropriate alternate or remove it entirely.</source>
        <target state="translated">W typie {0} zamień termin „{1}” w nazwie parametru typu ogólnego {2} na odpowiedni termin alternatywny lub usuń go całkowicie.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageMethodTypeParameterNoAlternate">
        <source>On method {0}, replace the term '{1}' in generic type parameter name {2} with an appropriate alternate or remove it entirely.</source>
        <target state="translated">W metodzie {0} zamień termin „{1}” w nazwie parametru typu ogólnego {2} na odpowiedni termin alternatywny lub usuń go całkowicie.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageTypeNoAlternate">
        <source>Replace the term '{0}' in type name {1} with an appropriate alternate or remove it entirely.</source>
        <target state="translated">Zamień termin „{0}” w nazwie typu {1} na odpowiedni termin alternatywny lub usuń go całkowicie.</target>
        <note />
      </trans-unit>
      <trans-unit id="UsePreferredTermsMessageMemberNoAlternate">
        <source>Replace the term '{0}' in member name {1} with an appropriate alternate or remove it entirely.</source>
        <target state="translated">Zamień termin „{0}” w nazwie elementu członkowskiego {1} na odpowiedni termin alternatywny lub usuń go całkowicie.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsAndOperatorEqualsOnValueTypesTitle">
        <source>Override equals and operator equals on value types</source>
        <target state="translated">Przesłoń metodę Equals i operator równości w typach wartości</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsAndOperatorEqualsOnValueTypesDescription">
        <source>For value types, the inherited implementation of Equals uses the Reflection library and compares the contents of all fields. Reflection is computationally expensive, and comparing every field for equality might be unnecessary. If you expect users to compare or sort instances, or to use instances as hash table keys, your value type should implement Equals.</source>
        <target state="translated">W przypadku typów wartości dziedziczona implementacja metody Equals używa biblioteki odbić i porównuje zawartość wszystkich pól. Odbicia wymagają kosztownych obliczeń, a porównywanie wszystkich pól pod kątem równości może być niepotrzebne. Jeśli oczekujesz, że użytkownicy będą porównywać lub sortować wystąpienia albo używać wystąpień jako kluczy tablicy skrótów, typ wartości powinien implementować metodę Equals.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsAndOperatorEqualsOnValueTypesMessageEquals">
        <source>{0} should override Equals.</source>
        <target state="translated">Typ {0} powinien przesłaniać metodę Equals.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsAndOperatorEqualsOnValueTypesMessageOpEquality">
        <source>{0} should override the equality (==) and inequality (!=) operators.</source>
        <target state="translated">Typ {0} powinien przesłaniać operatory równości (==) i nierówności (!=).</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotReturnArraysTitle">
        <source>Properties should not return arrays</source>
        <target state="translated">Właściwości nie powinny zwracać tablic</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotReturnArraysDescription">
        <source>Arrays that are returned by properties are not write-protected, even when the property is read-only. To keep the array tamper-proof, the property must return a copy of the array. Typically, users will not understand the adverse performance implications of calling such a property.</source>
        <target state="translated">Tablice zwracane przez właściwości nie są chronione przed zapisem, nawet jeśli właściwość jest dostępna tylko do odczytu. Aby uniemożliwić naruszenie tablicy, właściwość musi zwracać jej kopię. Zazwyczaj użytkownicy nie rozumieją negatywnego wpływu na wydajność, jaki ma wywoływanie takiej właściwości.</target>
        <note />
      </trans-unit>
      <trans-unit id="PropertiesShouldNotReturnArraysMessage">
        <source>Properties should not return arrays</source>
        <target state="translated">Właściwości nie powinny zwracać tablic</target>
        <note />
      </trans-unit>
      <trans-unit id="AssembliesShouldHaveValidStrongNamesTitle">
        <source>Assemblies should have valid strong names</source>
        <target state="translated">Zestawy powinny mieć prawidłowe silne nazwy</target>
        <note />
      </trans-unit>
      <trans-unit id="AssembliesShouldHaveValidStrongNamesDescription">
        <source>The strong name protects clients from unknowingly loading an assembly that has been tampered with. Assemblies without strong names should not be deployed outside very limited scenarios. If you share or distribute assemblies that are not correctly signed, the assembly can be tampered with, the common language runtime might not load the assembly, or the user might have to disable verification on his or her computer.</source>
        <target state="translated">Silna nazwa chroni klientów przed niezamierzonym załadowaniem zestawu, który został naruszony. Zestawy bez silnych nazw nie powinny być wdrażane, z wyjątkiem bardzo ograniczonego zestawu scenariuszy. Jeśli udostępniasz lub rozpowszechniasz zestawy bez poprawnego podpisu, zestaw może zostać naruszony, środowisko uruchomieniowe języka wspólnego może nie załadować zestawu lub użytkownik może być zmuszony do wyłączenia weryfikacji na swoim komputerze.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssembliesShouldHaveValidStrongNamesMessageNoStrongName">
        <source>Sign {0} with a strong name key.</source>
        <target state="translated">Podpisz zestaw {0} kluczem o silnej nazwie.</target>
        <note />
      </trans-unit>
      <trans-unit id="AssembliesShouldHaveValidStrongNamesMessageNotValid">
        <source>Verify that {0} has a valid strong name before deploying.</source>
        <target state="translated">Zweryfikuj przed wdrożeniem, czy zestaw {0} ma prawidłową silną nazwę.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideGetHashCodeOnOverridingEqualsTitle">
        <source>Override GetHashCode on overriding Equals</source>
        <target state="translated">Przesłoń metodę GetHashCode przy przesłanianiu metody Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideGetHashCodeOnOverridingEqualsDescription">
        <source>GetHashCode returns a value, based on the current instance, that is suited for hashing algorithms and data structures such as a hash table. Two objects that are the same type and are equal must return the same hash code.</source>
        <target state="translated">Metoda GetHashCode zwraca wartość na podstawie bieżącego wystąpienia, co jest przydatne na potrzeby algorytmów skrótu i struktur danych takich jak tablica skrótów. Dwa obiekty, które są tego samego typu i są równe, muszą zwracać ten sam kod skrótu.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideGetHashCodeOnOverridingEqualsMessage">
        <source>Override GetHashCode on overriding Equals</source>
        <target state="translated">Przesłoń metodę GetHashCode przy przesłanianiu metody Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnOverloadingOperatorEqualsTitle">
        <source>Override Equals on overloading operator equals</source>
        <target state="translated">Przesłoń metodę Equals przy przeciążaniu operatora równości</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnOverloadingOperatorEqualsDescription">
        <source>A public type implements the equality operator but does not override Object.Equals.</source>
        <target state="translated">Typ publiczny implementuje operator równości, lecz nie przesłania metody Object.Equals.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnOverloadingOperatorEqualsMessage">
        <source>Override Equals on overloading operator equals</source>
        <target state="translated">Przesłoń metodę Equals przy przeciążaniu operatora równości</target>
        <note />
      </trans-unit>
      <trans-unit id="Since_0_redefines_operator_1_it_should_also_redefine_operator_2">
        <source>Since '{0}' redefines operator '{1}', it should also redefine operator '{2}'</source>
        <target state="translated">Ponieważ typ „{0}” definiuje ponownie operator „{1}”, powinien także definiować ponownie operator „{2}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_missing_operators">
        <source>Generate missing operators</source>
        <target state="translated">Wygeneruj brakujące operatory</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnOverloadingOperatorEqualsCodeActionTitle">
        <source>Override object.Equals</source>
        <target state="translated">Przesłoń metodę object.Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideEqualsOnImplementingIEquatableCodeActionTitle">
        <source>Override object.Equals</source>
        <target state="translated">Przesłoń metodę object.Equals</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideGetHashCodeOnOverridingEqualsCodeActionTitle">
        <source>Override object.GetHashCode</source>
        <target state="translated">Przesłoń metodę object.GetHashCode</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeExceptionPublic">
        <source>Make exception public</source>
        <target state="translated">Zadeklaruj wyjątek jako publiczny</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesFix1">
        <source>Make '{0}' protected.</source>
        <target state="translated">Zadeklaruj element „{0}” jako chroniony.</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesFix2">
        <source>Change '{0}' to a public interface implementation.</source>
        <target state="translated">Zmodyfikuj element „{0}” zgodnie z implementacją interfejsu publicznego.</target>
        <note />
      </trans-unit>
      <trans-unit id="InterfaceMethodsShouldBeCallableByChildTypesFix3">
        <source>Make the containing type '{0}' sealed.</source>
        <target state="translated">Zapieczętuj typ zawierający „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="StaticHolderTypeIsNotStatic">
        <source>Type '{0}' is a static holder type but is neither static nor NotInheritable</source>
        <target state="translated">Typ „{0}” jest statycznym typem przechowującym, ale nie jest statyczny i nie ma modyfikatora NotInheritable</target>
        <note />
      </trans-unit>
      <trans-unit id="StaticHolderTypesShouldBeStaticOrNotInheritable">
        <source>Static holder types should be Static or NotInheritable</source>
        <target state="translated">Statyczne typy przechowujące powinny być zadeklarowane za pomocą modyfikatora Static lub NotInheritable</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeClassStatic">
        <source>Make Class Static</source>
        <target state="translated">Zadeklaruj klasę jako statyczną</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsMessage">
        <source>Type {0} should override Equals because it implements IEquatable&lt;T&gt;</source>
        <target state="translated">Typ {0} powinien przesłaniać metodę Equals, ponieważ implementuje interfejs IEquatable&lt;T&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsTitle">
        <source>Override Object.Equals(object) when implementing IEquatable&lt;T&gt;</source>
        <target state="translated">Przesłoń metodę Object.Equals(object) przy implementowaniu interfejsu IEquatable&lt;T&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="UseIntegralOrStringArgumentForIndexersDescription">
        <source>Indexers, that is, indexed properties, should use integer or string types for the index. These types are typically used for indexing data structures and increase the usability of the library. Use of the Object type should be restricted to those cases where the specific integer or string type cannot be specified at design time. If the design requires other types for the index, reconsider whether the type represents a logical data store. If it does not represent a logical data store, use a method.</source>
        <target state="translated">Indeksatory (tj. indeksowane właściwości) powinny używać typów całkowitoliczbowych lub ciągów na potrzeby indeksu. Te typy są zazwyczaj używane do indeksowania struktur danych i zwiększają użyteczność biblioteki. Użycie typu Object powinno być ograniczone do przypadków, w których konkretnego typu całkowitoliczbowego lub ciągu nie można określić podczas projektowania. Jeśli projekt wymaga użycia innych typów dla indeksu, rozważ ponownie, czy typ reprezentuje logiczny magazyn danych. Jeśli typ nie reprezentuje logicznego magazynu danych, użyj metody.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseIntegralOrStringArgumentForIndexersMessage">
        <source>Use Integral Or String Argument For Indexers</source>
        <target state="translated">Użyj argumentu całkowitoliczbowego lub ciągu dla indeksatorów</target>
        <note />
      </trans-unit>
      <trans-unit id="UseIntegralOrStringArgumentForIndexersTitle">
        <source>Use Integral Or String Argument For Indexers</source>
        <target state="translated">Użyj argumentu całkowitoliczbowego lub ciągu dla indeksatorów</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDirectlyAwaitATaskDescription">
        <source>When an asynchronous method awaits a Task directly, continuation occurs in the same thread that created the task. Consider calling Task.ConfigureAwait(Boolean) to signal your intention for continuation. Call ConfigureAwait(false) on the task to schedule continuations to the thread pool, thereby avoiding a deadlock on the UI thread. Passing false is a good option for app-independent libraries. Calling ConfigureAwait(true) on the task has the same behavior as not explicitly calling ConfigureAwait. By explicitly calling this method, you're letting readers know you intentionally want to perform the continuation on the original synchronization context.</source>
        <target state="translated">Gdy metoda asynchroniczna oczekuje na zadanie bezpośrednio, kontynuowanie następuje w tym samym wątku, w którym utworzono zadanie. Rozważ wywołanie metody Task.ConfigureAwait(wartość logiczna), aby zasygnalizować zamiar kontynuowania. Wywołaj metodę ConfigureAwait(false) w zadaniu, aby zaplanować kontynuacje do puli wątków, co pozwoli uniknąć zakleszczenia wątku interfejsu użytkownika. Przekazywanie wartości false to dobra opcja dla bibliotek niezależnych od aplikacji. Wywoływanie metody ConfigureAwait(true) w zadaniu działa tak samo jak brak jawnego wywołania metody ConfigureAwait. Wywołując jawnie tę metodę, informujesz czytelników, że celowo zamierzasz kontynuować w pierwotnym kontekście synchronizacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDirectlyAwaitATaskMessage">
        <source>Consider calling ConfigureAwait on the awaited task</source>
        <target state="translated">Rozważ wywołanie metody ConfigureAwait w zadaniu, na które się oczekuje</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDirectlyAwaitATaskTitle">
        <source>Consider calling ConfigureAwait on the awaited task</source>
        <target state="translated">Rozważ wywołanie metody ConfigureAwait w zadaniu, na które się oczekuje</target>
        <note />
      </trans-unit>
      <trans-unit id="AppendConfigureAwaitFalse">
        <source>Append .ConfigureAwait(false)</source>
        <target state="translated">Dołącz wywołanie .ConfigureAwait(false)</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementIEquatableWhenOverridingObjectEqualsDescription">
        <source>When a type T overrides Object.Equals(object), the implementation must cast the object argument to the correct type T before performing the comparison. If the type implements IEquatable&lt;T&gt;, and therefore offers the method T.Equals(T), and if the argument is known at compile time to be of type T, then the compiler can call IEquatable&lt;T&gt;.Equals(T) instead of Object.Equals(object), and no cast is necessary, improving performance.</source>
        <target state="translated">Gdy typ T przesłania metodę Object.Equals(object), implementacja musi rzutować obiekt będący argumentem na poprawny typ T przed wykonaniem porównania. Jeśli typ implementuje interfejs IEquatable&lt;T&gt;, a więc oferuje metodę T.Equals(T), i jeśli o argumencie wiadomo w chwili kompilacji, że jest typu T, kompilator może wywołać metodę IEquatable&lt;T&gt;.Equals(T) zamiast metody Object.Equals(object) bez konieczności wykonywania rzutowania, co poprawia wydajność.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsDescription">
        <source>When a type T implements the interface IEquatable&lt;T&gt;, it suggests to a user who sees a call to the Equals method in source code that an instance of the type can be equated with an instance of any other type. The user might be confused if their attempt to equate the type with an instance of another type fails to compile. This violates the "principle of least surprise".</source>
        <target state="translated">Gdy typ T implementuje interfejs IEquatable&lt;T&gt;, sugeruje użytkownikowi, który widzi wywołanie metody Equals w kodzie źródłowym, że wystąpienie typu może zostać porównane z wystąpieniem dowolnego innego typu. Użytkownik może być zdezorientowany, gdy jego próba skompilowania porównania typu z wystąpieniem innego typu nie powiedzie się. Jest to niezgodne z „zasadą najmniejszego zaskoczenia”.</target>
        <note />
      </trans-unit>
      <trans-unit id="RenameToTitle">
        <source>Rename to '{0}'</source>
        <target state="translated">Zmień nazwę na „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHideBaseClassMethodsDescription">
        <source>A method in a base type is hidden by an identically named method in a derived type when the parameter signature of the derived method differs only by types that are more weakly derived than the corresponding types in the parameter signature of the base method.</source>
        <target state="translated">Metoda w typie podstawowym jest ukryta przez metodę o takiej samej nazwie w typie pochodnym, jeśli sygnatura parametrów metody pochodnej różni się tylko typami, które są wyżej w hierarchii dziedziczenia niż odpowiadające typy w sygnaturze parametrów metody podstawowej.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHideBaseClassMethodsMessage">
        <source>Change or remove '{0}' because it hides a more specific base class method: '{1}'.</source>
        <target state="translated">Zmień lub usuń metodę „{0}”, ponieważ ukrywa ona bardziej wyspecjalizowaną metodę klasy podstawowej: „{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotHideBaseClassMethodsTitle">
        <source>Do not hide base class methods</source>
        <target state="translated">Nie ukrywaj metod klasy podstawowej</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForDelegateMessage">
        <source>Remove '{0}' and replace its usage with a generic EventHandler, for e.g. EventHandler&lt;T&gt;, where T is a valid EventArgs</source>
        <target state="translated">Usuń element „{0}” i zamień jego użycie na ogólną procedurę EventHandler, np. EventHandler&lt;T&gt;, gdzie T to prawidłowe argumenty zdarzenia</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForDelegateDescription">
        <source>A type contains a delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets Microsoft .NET Framework?2.0.</source>
        <target state="translated">Typ zawiera delegata zwracającego typ void, którego sygnatura zawiera dwa parametry (pierwszy jest obiektem, a drugi typem, który można przypisać do typu EventArgs), a zawierający zestaw jest przeznaczony dla programu Microsoft .NET Framework 2.0.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForEventMessage">
        <source>Change the event '{0}' to replace the type '{1}' with a generic EventHandler, for e.g. EventHandler&lt;T&gt;, where T is a valid EventArgs</source>
        <target state="translated">Zmień zdarzenie „{0}”, aby zamienić typ „{1}” na ogólną procedurę EventHandler, np. EventHandler&lt;T&gt;, gdzie T to prawidłowy element EventArgs (argumenty zdarzenia)</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForEventDescription">
        <source>A delegate that handles a public or protected event does not have the correct signature, return type, or parameter names.</source>
        <target state="translated">Delegat obsługujący publiczne lub chronione zdarzenie nie ma prawidłowej sygnatury, typu zwracanego lub nazw parametrów.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForEvent2Message">
        <source>Change the event '{0}' to use a generic EventHandler by defining the event type explicitly, for e.g. Event MyEvent As EventHandler(Of MyEventArgs).</source>
        <target state="translated">Zmień zdarzenie „{0}”, aby użyć ogólnego elementu EventHandler, definiując jawnie typ zdarzenia, na przykład Event MyEvent As EventHandler(Of MyEventArgs).</target>
        <note />
      </trans-unit>
      <trans-unit id="UseGenericEventHandlerInstancesForEvent2Description">
        <source>A type contains an event that declares an EventHandler delegate that returns void, whose signature contains two parameters (the first an object and the second a type that is assignable to EventArgs), and the containing assembly targets Microsoft .NET Framework?2.0.</source>
        <target state="translated">Typ zawiera zdarzenie, które deklaruje delegata EventHandler zwracającego wartość void i ma sygnaturę zawierającą dwa parametry (pierwszy jest obiektem, a drugi typem z możliwością przypisania do elementu EventArgs) oraz zawiera zestaw przeznaczony dla platformy Microsoft .NET Framework?2.0.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideMethodsOnComparableTypesMessageBoth">
        <source>{0} should define operator(s) '{1}' and Equals since it implements IComparable.</source>
        <target state="translated">Typ {0} powinien definiować operatory „{1}” i metodę Equals, ponieważ implementuje interfejs IComparable.</target>
        <note>1 is a comma-separated list</note>
      </trans-unit>
    </body>
  </file>
</xliff>
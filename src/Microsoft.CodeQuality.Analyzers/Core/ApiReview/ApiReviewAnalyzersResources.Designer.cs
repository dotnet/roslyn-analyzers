//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Microsoft.CodeQuality.Analyzers.ApiReview {
    using System;
    using System.Reflection;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class ApiReviewAnalyzersResources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal ApiReviewAnalyzersResources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Microsoft.CodeQuality.Core.Analyzers.ApiReview.ApiReviewAnalyzersResources", typeof(ApiReviewAnalyzersResources).GetTypeInfo().Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A member calls a potentially dangerous or problematic method..
        /// </summary>
        internal static string AvoidCallingProblematicMethodsDescription {
            get {
                return ResourceManager.GetString("AvoidCallingProblematicMethodsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} is a P/Invoke declaration to an OLE32 API that cannot be reliably called after the runtime has been initialized. The workaround is to write an unmanaged shim that will call the routine and then activate and call into managed code. You can do this using an export from a mixed-mode C++ DLL, by registering a managed component for use by COM, or by using the runtime hosting API..
        /// </summary>
        internal static string AvoidCallingProblematicMethodsMessageCoInitializeSecurity {
            get {
                return ResourceManager.GetString("AvoidCallingProblematicMethodsMessageCoInitializeSecurity", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} is a P/Invoke declaration to an OLE32 API that cannot be reliably called against a runtime callable wrapper (a managed object wrapping a COM object). Runtime callable wrappers dynamically fetch interface pointers so the effect of the call might be arbitrarily lost. Runtime callable wrappers for a given COM object are also shared across an application domain so the call could possibly affect other users. Replace this call with a native wrapper COM object for the interface pointer that does the appropriat [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string AvoidCallingProblematicMethodsMessageCoSetProxyBlanket {
            get {
                return ResourceManager.GetString("AvoidCallingProblematicMethodsMessageCoSetProxyBlanket", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove the call to GC.Collect from {0}. It is usually unnecessary to force garbage collection, and doing so can severely degrade performance..
        /// </summary>
        internal static string AvoidCallingProblematicMethodsMessageSystemGCCollect {
            get {
                return ResourceManager.GetString("AvoidCallingProblematicMethodsMessageSystemGCCollect", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove the call to Assembly.LoadFile from {0}..
        /// </summary>
        internal static string AvoidCallingProblematicMethodsMessageSystemReflectionAssemblyLoadFile {
            get {
                return ResourceManager.GetString("AvoidCallingProblematicMethodsMessageSystemReflectionAssemblyLoadFile", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove the call to Assembly.LoadFrom from {0}..
        /// </summary>
        internal static string AvoidCallingProblematicMethodsMessageSystemReflectionAssemblyLoadFrom {
            get {
                return ResourceManager.GetString("AvoidCallingProblematicMethodsMessageSystemReflectionAssemblyLoadFrom", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove the call to Assembly.LoadWithPartialName from {0}..
        /// </summary>
        internal static string AvoidCallingProblematicMethodsMessageSystemReflectionAssemblyLoadWithPartialName {
            get {
                return ResourceManager.GetString("AvoidCallingProblematicMethodsMessageSystemReflectionAssemblyLoadWithPartialName", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove the call to SafeHandle.DangerousGetHandle from {0}..
        /// </summary>
        internal static string AvoidCallingProblematicMethodsMessageSystemRuntimeInteropServicesSafeHandleDangerousGetHandle {
            get {
                return ResourceManager.GetString("AvoidCallingProblematicMethodsMessageSystemRuntimeInteropServicesSafeHandleDanger" +
                        "ousGetHandle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove the call to Thread.Resume from {0}. Suspending and resuming threads can be dangerous if the system is in the middle of a critical operation such as executing a class constructor of an important system type or resolving security for a shared assembly..
        /// </summary>
        internal static string AvoidCallingProblematicMethodsMessageSystemThreadingThreadResume {
            get {
                return ResourceManager.GetString("AvoidCallingProblematicMethodsMessageSystemThreadingThreadResume", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove the call to Thread.Suspend from {0}. Suspending and resuming threads can be dangerous if the system is in the middle of a critical operation such as executing a class constructor of an important system type or resolving security for a shared assembly..
        /// </summary>
        internal static string AvoidCallingProblematicMethodsMessageSystemThreadingThreadSuspend {
            get {
                return ResourceManager.GetString("AvoidCallingProblematicMethodsMessageSystemThreadingThreadSuspend", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove the call to System.Type.InvokeMember with BindingFlags.NonPublic from {0}. Taking a dependency on a private member increases the chance of a breaking change in the future..
        /// </summary>
        internal static string AvoidCallingProblematicMethodsMessageSystemTypeInvokeMember {
            get {
                return ResourceManager.GetString("AvoidCallingProblematicMethodsMessageSystemTypeInvokeMember", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Avoid calling problematic methods.
        /// </summary>
        internal static string AvoidCallingProblematicMethodsTitle {
            get {
                return ResourceManager.GetString("AvoidCallingProblematicMethodsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Reliability.
        /// </summary>
        internal static string CategoryReliability {
            get {
                return ResourceManager.GetString("CategoryReliability", resourceCulture);
            }
        }
    }
}

<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="de" original="../ApiReviewAnalyzersResources.resx">
    <body>
      <trans-unit id="AvoidCallingProblematicMethodsTitle">
        <source>Avoid calling problematic methods</source>
        <target state="translated">Keine problematischen Methoden aufrufen</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsDescription">
        <source>A member calls a potentially dangerous or problematic method.</source>
        <target state="translated">Ein Member ruft eine möglicherweise gefährliche oder problematische Methode auf.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemGCCollect">
        <source>Remove the call to GC.Collect from {0}. It is usually unnecessary to force garbage collection, and doing so can severely degrade performance.</source>
        <target state="translated">Entfernen Sie den Aufruf von GC.Collect aus "{0}". Normalerweise ist es nicht nötig, die Garbage Collection zu erzwingen. Dies kann zu erheblichen Leistungseinbußen führen.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemThreadingThreadResume">
        <source>Remove the call to Thread.Resume from {0}. Suspending and resuming threads can be dangerous if the system is in the middle of a critical operation such as executing a class constructor of an important system type or resolving security for a shared assembly.</source>
        <target state="translated">Entfernen Sie den Aufruf von Thread.Resume aus "{0}". Das Anhalten und Fortsetzen von Threads kann gefährlich sein, wenn das System gerade einen kritischen Vorgang ausführt. Dazu gehört beispielsweise die Ausführung eines Klassenkonstruktors eines wichtigen Systemtyps oder die Auflösung der Sicherheit für eine freigegebene Assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemThreadingThreadSuspend">
        <source>Remove the call to Thread.Suspend from {0}. Suspending and resuming threads can be dangerous if the system is in the middle of a critical operation such as executing a class constructor of an important system type or resolving security for a shared assembly.</source>
        <target state="translated">Entfernen Sie den Aufruf von Thread.Suspend aus "{0}". Das Anhalten und Fortsetzen von Threads kann gefährlich sein, wenn das System gerade einen kritischen Vorgang ausführt. Dazu gehört beispielsweise die Ausführung eines Klassenkonstruktors eines wichtigen Systemtyps oder die Auflösung der Sicherheit für eine freigegebene Assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemTypeInvokeMember">
        <source>Remove the call to System.Type.InvokeMember with BindingFlags.NonPublic from {0}. Taking a dependency on a private member increases the chance of a breaking change in the future.</source>
        <target state="translated">Entfernen Sie den Aufruf von System.Type.InvokeMember mit BindingFlags.NonPublic aus "{0}". Durch das Übernehmen einer Abhängigkeit von einem privaten Member erhöht sich das Risiko auf eine zukünftige fehlerhafte Änderung.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageCoInitializeSecurity">
        <source>{0} is a P/Invoke declaration to an OLE32 API that cannot be reliably called after the runtime has been initialized. The workaround is to write an unmanaged shim that will call the routine and then activate and call into managed code. You can do this using an export from a mixed-mode C++ DLL, by registering a managed component for use by COM, or by using the runtime hosting API.</source>
        <target state="translated">"{0}" ist eine P/Invoke-Deklaration für eine OLE32-API, die nach der Initialisierung der Runtime nicht zuverlässig aufgerufen werden kann. The Problemumgehung besteht darin, einen nicht verwalteten Shim zu schreiben, der die Routine aufruft und aktiviert und anschließend im verwalteten Code aufruft. Hierzu können Sie einen Export aus einer C++-DLL im gemischten Modus verwenden, indem Sie eine verwaltete Komponente für die Verwendung durch COM registrieren oder indem Sie die API für das Hosting der Laufzeit verwenden.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageCoSetProxyBlanket">
        <source>{0} is a P/Invoke declaration to an OLE32 API that cannot be reliably called against a runtime callable wrapper (a managed object wrapping a COM object). Runtime callable wrappers dynamically fetch interface pointers so the effect of the call might be arbitrarily lost. Runtime callable wrappers for a given COM object are also shared across an application domain so the call could possibly affect other users. Replace this call with a native wrapper COM object for the interface pointer that does the appropriate CoSetProxyBlanket calls.</source>
        <target state="translated">"{0}" ist eine P/Invoke-Deklaration für eine OLE32-API, die nicht zuverlässig für einen Runtime Callable Wrapper (ein verwaltetes Objekt, das ein COM-Objekt umschließt) aufgerufen werden kann. Runtime Callable Wrapper rufen Schnittstellenzeiger dynamisch ab, sodass die Wirkung des Aufrufs willkürlich verloren gehen kann. Runtime Callable Wrapper für ein bestimmtes COM-Objekt werden auch in der gesamten Anwendungsdomäne freigegeben, sodass der Aufruf sich auch auf andere Benutzer auswirken kann. Ersetzen Sie diesen Aufruf durch ein COM-Objekt mit einem nativen Wrapper für den Schnittstellenzeiger, der die geeigneten CoSetProxyBlanket-Aufrufe ausführt.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemRuntimeInteropServicesSafeHandleDangerousGetHandle">
        <source>Remove the call to SafeHandle.DangerousGetHandle from {0}.</source>
        <target state="translated">Entfernen Sie den Aufruf von SafeHandle.DangerousGetHandle aus "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemReflectionAssemblyLoadFrom">
        <source>Remove the call to Assembly.LoadFrom from {0}.</source>
        <target state="translated">Entfernen Sie den Aufruf von Assembly.LoadFrom aus "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemReflectionAssemblyLoadFile">
        <source>Remove the call to Assembly.LoadFile from {0}.</source>
        <target state="translated">Entfernen Sie den Aufruf von Assembly.LoadFile aus "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemReflectionAssemblyLoadWithPartialName">
        <source>Remove the call to Assembly.LoadWithPartialName from {0}.</source>
        <target state="translated">Entfernen Sie den Aufruf von Assembly.LoadWithPartialName aus "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="CategoryReliability">
        <source>Reliability</source>
        <target state="translated">Zuverlässigkeit</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
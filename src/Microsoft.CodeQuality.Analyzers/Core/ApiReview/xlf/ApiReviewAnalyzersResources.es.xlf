<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="es" original="../ApiReviewAnalyzersResources.resx">
    <body>
      <trans-unit id="AvoidCallingProblematicMethodsTitle">
        <source>Avoid calling problematic methods</source>
        <target state="translated">Evitar llamar a métodos problemáticos</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsDescription">
        <source>A member calls a potentially dangerous or problematic method.</source>
        <target state="translated">Un miembro llama a un método potencialmente peligroso o problemático.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemGCCollect">
        <source>Remove the call to GC.Collect from {0}. It is usually unnecessary to force garbage collection, and doing so can severely degrade performance.</source>
        <target state="translated">Quite la llamada a GC.Collect de {0}. Normalmente no es necesario forzar la recolección de elementos no utilizados y, si lo hace, puede degradar considerablemente el rendimiento.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemThreadingThreadResume">
        <source>Remove the call to Thread.Resume from {0}. Suspending and resuming threads can be dangerous if the system is in the middle of a critical operation such as executing a class constructor of an important system type or resolving security for a shared assembly.</source>
        <target state="translated">Quite la llamada a Thread.Resume de {0}. Suspender y reanudar subprocesos puede ser peligroso si el sistema está en medio de una operación crítica como, por ejemplo, ejecutar un constructor de clases de un tipo de sistema importante o resolver la seguridad de un ensamblado compartido.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemThreadingThreadSuspend">
        <source>Remove the call to Thread.Suspend from {0}. Suspending and resuming threads can be dangerous if the system is in the middle of a critical operation such as executing a class constructor of an important system type or resolving security for a shared assembly.</source>
        <target state="translated">Quite la llamada a Thread.Suspend de {0}. Suspender y reanudar subprocesos puede ser peligroso si el sistema está en medio de una operación crítica como, por ejemplo, ejecutar un constructor de clases de un tipo de sistema importante o resolver la seguridad de un ensamblado compartido.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemTypeInvokeMember">
        <source>Remove the call to System.Type.InvokeMember with BindingFlags.NonPublic from {0}. Taking a dependency on a private member increases the chance of a breaking change in the future.</source>
        <target state="translated">Quite la llamada a System.Type.InvokeMember con BindingFlags.NonPublic de {0}. Tomar una dependencia en un miembro privado aumenta la posibilidad de que se produzca un cambio drástico en el futuro.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageCoInitializeSecurity">
        <source>{0} is a P/Invoke declaration to an OLE32 API that cannot be reliably called after the runtime has been initialized. The workaround is to write an unmanaged shim that will call the routine and then activate and call into managed code. You can do this using an export from a mixed-mode C++ DLL, by registering a managed component for use by COM, or by using the runtime hosting API.</source>
        <target state="translated">{0} es una declaración P/Invoke a una API OLE32 a la que no se puede llamar de forma confiable una vez inicializado el entorno de ejecución. La solución es escribir correcciones de compatibilidad (shim) no administradas que llamen a la rutina y, después, activen y llamen a código administrado. Para ello, use una exportación de una DLL de C++ en modo mixto, registre un componente administrado para que lo use COM o utilice la API de hospedaje del entorno de ejecución.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageCoSetProxyBlanket">
        <source>{0} is a P/Invoke declaration to an OLE32 API that cannot be reliably called against a runtime callable wrapper (a managed object wrapping a COM object). Runtime callable wrappers dynamically fetch interface pointers so the effect of the call might be arbitrarily lost. Runtime callable wrappers for a given COM object are also shared across an application domain so the call could possibly affect other users. Replace this call with a native wrapper COM object for the interface pointer that does the appropriate CoSetProxyBlanket calls.</source>
        <target state="translated">{0} es una declaración P/Invoke a una API OLE32 a la que no se puede llamar de forma confiable respecto a un contenedor RCW (objeto administrado que contiene un objeto COM). Los contenedores RCW capturan punteros de interfaz de forma dinámica; por tanto, el efecto de la llamada se puede perder de forma arbitraria. Los contenedores RCW de un objeto COM dado se comparten también en el dominio de una aplicación, de forma que la llamada podría afectar a otros usuarios. Reemplace esta llamada por un objeto COM contenedor nativo para el puntero de interfaz que realiza las llamadas a CoSetProxyBlanket correspondientes.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemRuntimeInteropServicesSafeHandleDangerousGetHandle">
        <source>Remove the call to SafeHandle.DangerousGetHandle from {0}.</source>
        <target state="translated">Quite la llamada a SafeHandle.DangerousGetHandle de {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemReflectionAssemblyLoadFrom">
        <source>Remove the call to Assembly.LoadFrom from {0}.</source>
        <target state="translated">Quite la llamada a Assembly.LoadFrom de {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemReflectionAssemblyLoadFile">
        <source>Remove the call to Assembly.LoadFile from {0}.</source>
        <target state="translated">Quite la llamada a Assembly.LoadFile de {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemReflectionAssemblyLoadWithPartialName">
        <source>Remove the call to Assembly.LoadWithPartialName from {0}.</source>
        <target state="translated">Quite la llamada a Assembly.LoadWithPartialName de {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="CategoryReliability">
        <source>Reliability</source>
        <target state="translated">Fiabilidad</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
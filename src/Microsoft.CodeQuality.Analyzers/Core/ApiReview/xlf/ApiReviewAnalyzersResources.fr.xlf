<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="fr" original="../ApiReviewAnalyzersResources.resx">
    <body>
      <trans-unit id="AvoidCallingProblematicMethodsTitle">
        <source>Avoid calling problematic methods</source>
        <target state="translated">Éviter d'appeler des méthodes susceptibles de poser des problèmes</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsDescription">
        <source>A member calls a potentially dangerous or problematic method.</source>
        <target state="translated">Un membre appelle une méthode potentiellement dangereuse ou pouvant poser des problèmes.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemGCCollect">
        <source>Remove the call to GC.Collect from {0}. It is usually unnecessary to force garbage collection, and doing so can severely degrade performance.</source>
        <target state="translated">Supprimez l'appel à GC.Collect dans {0}. En règle générale, il n'est pas nécessaire d'imposer un garbage collection. En effet, cela peut sérieusement dégrader les performances.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemThreadingThreadResume">
        <source>Remove the call to Thread.Resume from {0}. Suspending and resuming threads can be dangerous if the system is in the middle of a critical operation such as executing a class constructor of an important system type or resolving security for a shared assembly.</source>
        <target state="translated">Supprimez l'appel à Thread.Resume dans {0}. L'interruption et la reprise de threads peuvent être dangereuses si le système est en train d'effectuer une opération critique, par exemple l'exécution d'un constructeur de classe d'un type système important ou la résolution de la sécurité pour un assembly partagé.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemThreadingThreadSuspend">
        <source>Remove the call to Thread.Suspend from {0}. Suspending and resuming threads can be dangerous if the system is in the middle of a critical operation such as executing a class constructor of an important system type or resolving security for a shared assembly.</source>
        <target state="translated">Supprimez l'appel à Thread.Suspend dans {0}. L'interruption et la reprise de threads peuvent être dangereuses si le système est en train d'effectuer une opération critique, par exemple l'exécution d'un constructeur de classe d'un type système important ou la résolution de la sécurité pour un assembly partagé.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemTypeInvokeMember">
        <source>Remove the call to System.Type.InvokeMember with BindingFlags.NonPublic from {0}. Taking a dependency on a private member increases the chance of a breaking change in the future.</source>
        <target state="translated">Supprimez l'appel à System.Type.InvokeMember avec BindingFlags.NonPublic dans {0}. L'acceptation d'une dépendance pour un membre privé augmente les chances de rupture dans le futur.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageCoInitializeSecurity">
        <source>{0} is a P/Invoke declaration to an OLE32 API that cannot be reliably called after the runtime has been initialized. The workaround is to write an unmanaged shim that will call the routine and then activate and call into managed code. You can do this using an export from a mixed-mode C++ DLL, by registering a managed component for use by COM, or by using the runtime hosting API.</source>
        <target state="translated">{0} est une déclaration P/Invoke à une API OLE32 qui ne peut pas être appelée de manière fiable après l'initialisation du runtime. La solution consiste à écrire un shim non managé qui appelle la routine, puis l'active et l'appelle dans du code managé. Vous pouvez y parvenir en utilisant une exportation d'une DLL C++ en mode mixte, en inscrivant un composant managé à utiliser par COM ou en utilisant l'API d'hébergement du runtime.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageCoSetProxyBlanket">
        <source>{0} is a P/Invoke declaration to an OLE32 API that cannot be reliably called against a runtime callable wrapper (a managed object wrapping a COM object). Runtime callable wrappers dynamically fetch interface pointers so the effect of the call might be arbitrarily lost. Runtime callable wrappers for a given COM object are also shared across an application domain so the call could possibly affect other users. Replace this call with a native wrapper COM object for the interface pointer that does the appropriate CoSetProxyBlanket calls.</source>
        <target state="translated">{0} est une déclaration P/Invoke à une API OLE32 qui ne peut pas être appelée de manière fiable sur un wrapper RCW (objet managé incluant un objet COM dans un wrapper). Dans la mesure où les wrappers RCW récupèrent (fetch) dynamiquement les pointeurs d'interface, l'effet de l'appel peut être arbitrairement perdu. Dans la mesure où les wrappers RCW d'un objet COM donné sont également partagés dans un domaine d'application, l'appel peut affecter d'autres utilisateurs. Remplacez cet appel par un objet COM de wrapper natif pour le pointeur d'interface qui effectue les appels CoSetProxyBlanket appropriés.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemRuntimeInteropServicesSafeHandleDangerousGetHandle">
        <source>Remove the call to SafeHandle.DangerousGetHandle from {0}.</source>
        <target state="translated">Supprimez l'appel à SafeHandle.DangerousGetHandle dans {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemReflectionAssemblyLoadFrom">
        <source>Remove the call to Assembly.LoadFrom from {0}.</source>
        <target state="translated">Supprimez l'appel à Assembly.LoadFrom dans {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemReflectionAssemblyLoadFile">
        <source>Remove the call to Assembly.LoadFile from {0}.</source>
        <target state="translated">Supprimez l'appel à Assembly.LoadFile dans {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemReflectionAssemblyLoadWithPartialName">
        <source>Remove the call to Assembly.LoadWithPartialName from {0}.</source>
        <target state="translated">Supprimez l'appel à Assembly.LoadWithPartialName dans {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="CategoryReliability">
        <source>Reliability</source>
        <target state="translated">Fiabilité</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="it" original="../ApiReviewAnalyzersResources.resx">
    <body>
      <trans-unit id="AvoidCallingProblematicMethodsTitle">
        <source>Avoid calling problematic methods</source>
        <target state="translated">Evitare di chiamare metodi problematici</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsDescription">
        <source>A member calls a potentially dangerous or problematic method.</source>
        <target state="translated">Un membro chiama un metodo potenzialmente pericoloso o problematico.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemGCCollect">
        <source>Remove the call to GC.Collect from {0}. It is usually unnecessary to force garbage collection, and doing so can severely degrade performance.</source>
        <target state="translated">Rimuovere la chiamata a GC.Collect da {0}. Non è necessario forzare la Garbage Collection perché tale operazione può influire molto negativamente sulle prestazioni.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemThreadingThreadResume">
        <source>Remove the call to Thread.Resume from {0}. Suspending and resuming threads can be dangerous if the system is in the middle of a critical operation such as executing a class constructor of an important system type or resolving security for a shared assembly.</source>
        <target state="translated">Rimuovere la chiamata a Thread.Resume da {0}. Può essere pericoloso sospendere e riprendere i thread se il sistema sta eseguendo un'operazione critica, ad esempio durante l'esecuzione di un costruttore di classe di un importante tipo di sistema o la risoluzione della sicurezza per un assembly condiviso.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemThreadingThreadSuspend">
        <source>Remove the call to Thread.Suspend from {0}. Suspending and resuming threads can be dangerous if the system is in the middle of a critical operation such as executing a class constructor of an important system type or resolving security for a shared assembly.</source>
        <target state="translated">Rimuovere la chiamata a Thread.Suspend da {0}. Può essere pericoloso sospendere e riprendere i thread se il sistema sta eseguendo un'operazione critica, ad esempio durante l'esecuzione di un costruttore di classe di un importante tipo di sistema o la risoluzione della sicurezza per un assembly condiviso.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemTypeInvokeMember">
        <source>Remove the call to System.Type.InvokeMember with BindingFlags.NonPublic from {0}. Taking a dependency on a private member increases the chance of a breaking change in the future.</source>
        <target state="translated">Rimuovere la chiamata a System.Type.InvokeMember con BindingFlags.NonPublic da {0}. L'uso di una dipendenza su un membro privato aumenta la possibilità di una modifica importante in futuro.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageCoInitializeSecurity">
        <source>{0} is a P/Invoke declaration to an OLE32 API that cannot be reliably called after the runtime has been initialized. The workaround is to write an unmanaged shim that will call the routine and then activate and call into managed code. You can do this using an export from a mixed-mode C++ DLL, by registering a managed component for use by COM, or by using the runtime hosting API.</source>
        <target state="translated">{0} è una dichiarazione P/Invoke per un'API OLE32 che non può essere chiamata in modo affidabile dopo l'inizializzazione del runtime. Come soluzione alternativa è possibile scrivere uno shim non gestito che chiamerà la routine e quindi la attiverà e la chiamerà nel codice gestito. A questo scopo, è possibile usare un'esportazione da una DLL C++ in modalità mista, registrando un componente gestito per COM o usando l'API di hosting del runtime.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageCoSetProxyBlanket">
        <source>{0} is a P/Invoke declaration to an OLE32 API that cannot be reliably called against a runtime callable wrapper (a managed object wrapping a COM object). Runtime callable wrappers dynamically fetch interface pointers so the effect of the call might be arbitrarily lost. Runtime callable wrappers for a given COM object are also shared across an application domain so the call could possibly affect other users. Replace this call with a native wrapper COM object for the interface pointer that does the appropriate CoSetProxyBlanket calls.</source>
        <target state="translated">{0} è una dichiarazione P/Invoke per un'API OLE32 che non può essere chiamata in modo affidabile su un oggetto Runtime Callable Wrapper, ovvero un oggetto gestito che esegue il wrapping di un oggetto COM. Gli oggetti Runtime Callable Wrapper recuperano dinamicamente i puntatori a interfaccia, quindi l'effetto della chiamata potrebbe andare arbitrariamente perso. Gli oggetti Runtime Callable Wrapper relativi a un determinato oggetto COM sono inoltre condivisi in un dominio dell'applicazione, quindi la chiamata potrebbe interessare altri utenti. Sostituire questa chiamata con un oggetto COM wrapper nativo per il puntatore a interfaccia che effettua le chiamate appropriate a CoSetProxyBlanket.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemRuntimeInteropServicesSafeHandleDangerousGetHandle">
        <source>Remove the call to SafeHandle.DangerousGetHandle from {0}.</source>
        <target state="translated">Rimuovere la chiamata a SafeHandle.DangerousGetHandle da {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemReflectionAssemblyLoadFrom">
        <source>Remove the call to Assembly.LoadFrom from {0}.</source>
        <target state="translated">Rimuovere la chiamata a Assembly.LoadFrom da {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemReflectionAssemblyLoadFile">
        <source>Remove the call to Assembly.LoadFile from {0}.</source>
        <target state="translated">Rimuovere la chiamata a Assembly.LoadFile da {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemReflectionAssemblyLoadWithPartialName">
        <source>Remove the call to Assembly.LoadWithPartialName from {0}.</source>
        <target state="translated">Rimuovere la chiamata a Assembly.LoadWithPartialName da {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="CategoryReliability">
        <source>Reliability</source>
        <target state="translated">Affidabilità</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
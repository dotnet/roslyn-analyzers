<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="pt-BR" original="../ApiReviewAnalyzersResources.resx">
    <body>
      <trans-unit id="AvoidCallingProblematicMethodsTitle">
        <source>Avoid calling problematic methods</source>
        <target state="translated">Evite chamar métodos problemáticos</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsDescription">
        <source>A member calls a potentially dangerous or problematic method.</source>
        <target state="translated">Um membro chama um método problemático ou potencialmente perigoso.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemGCCollect">
        <source>Remove the call to GC.Collect from {0}. It is usually unnecessary to force garbage collection, and doing so can severely degrade performance.</source>
        <target state="translated">Remova a chamada para GC.Collect de {0}. Normalmente, é desnecessário forçar a coleta de lixo. Fazer isso pode impactar severamente o desempenho.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemThreadingThreadResume">
        <source>Remove the call to Thread.Resume from {0}. Suspending and resuming threads can be dangerous if the system is in the middle of a critical operation such as executing a class constructor of an important system type or resolving security for a shared assembly.</source>
        <target state="translated">Remova a chamada para Thread.Resume de {0}. Suspender e resumir threads pode ser perigoso quando o sistema está em meio a uma operação crítica como a execução de um construtor de classe de um tipo de sistema importante ou resolvendo a segurança para um assembly compartilhado.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemThreadingThreadSuspend">
        <source>Remove the call to Thread.Suspend from {0}. Suspending and resuming threads can be dangerous if the system is in the middle of a critical operation such as executing a class constructor of an important system type or resolving security for a shared assembly.</source>
        <target state="translated">Remova a chamada para Thread.Suspend de {0}. Suspender e resumir threads pode ser perigoso quando o sistema está em meio a uma operação crítica como a execução de um construtor de classe de um tipo de sistema importante ou resolvendo a segurança para um assembly compartilhado.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemTypeInvokeMember">
        <source>Remove the call to System.Type.InvokeMember with BindingFlags.NonPublic from {0}. Taking a dependency on a private member increases the chance of a breaking change in the future.</source>
        <target state="translated">Remova a chamada para System.Type.InvokeMember com BindingFlags.NonPublic de {0}. Usar uma dependência em um membro privado aumenta a chance de haver uma alteração interruptiva no futuro.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageCoInitializeSecurity">
        <source>{0} is a P/Invoke declaration to an OLE32 API that cannot be reliably called after the runtime has been initialized. The workaround is to write an unmanaged shim that will call the routine and then activate and call into managed code. You can do this using an export from a mixed-mode C++ DLL, by registering a managed component for use by COM, or by using the runtime hosting API.</source>
        <target state="translated">{0} é uma declaração P/Invoke para uma API OLE32 que não pode ser chamada de forma confiável após a inicialização do tempo de execução. A solução alternativa é gravar um shim não gerenciado que chamará a rotina e ativará e chamará o código gerenciado. É possível fazer isso usando uma exportação de uma DLL C++ de modo misto ao registrar um componente gerenciado para uso pelo COM ou ao usar a API de hospedagem do tempo de execução.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageCoSetProxyBlanket">
        <source>{0} is a P/Invoke declaration to an OLE32 API that cannot be reliably called against a runtime callable wrapper (a managed object wrapping a COM object). Runtime callable wrappers dynamically fetch interface pointers so the effect of the call might be arbitrarily lost. Runtime callable wrappers for a given COM object are also shared across an application domain so the call could possibly affect other users. Replace this call with a native wrapper COM object for the interface pointer that does the appropriate CoSetProxyBlanket calls.</source>
        <target state="translated">{0} é uma declaração P/Invoke para uma API OLE32 que não pode ser chamada de forma confiável com relação a um runtime callable wrapper (um objeto gerenciado que encapsula um objeto COM). Runtime callable wrappers buscam ponteiros de interface dinamicamente, de modo que o efeito da chamada pode ser arbitrariamente perdido. Runtime callable wrappers para um determinado objeto COM também são compartilhados ao longo de um domínio de aplicativos. Assim, a chamada poderia afetar outros usuários. Substitua esta chamada por um objeto COM wrapper nativo para o ponteiro de interface que faz as chamadas CoSetProxyBlanket apropriadas.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemRuntimeInteropServicesSafeHandleDangerousGetHandle">
        <source>Remove the call to SafeHandle.DangerousGetHandle from {0}.</source>
        <target state="translated">Remova a chamada para SafeHandle.DangerousGetHandle de {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemReflectionAssemblyLoadFrom">
        <source>Remove the call to Assembly.LoadFrom from {0}.</source>
        <target state="translated">Remova a chamada para Assembly.LoadFrom de {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemReflectionAssemblyLoadFile">
        <source>Remove the call to Assembly.LoadFile from {0}.</source>
        <target state="translated">Remova a chamada para Assembly.LoadFile de {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidCallingProblematicMethodsMessageSystemReflectionAssemblyLoadWithPartialName">
        <source>Remove the call to Assembly.LoadWithPartialName from {0}.</source>
        <target state="translated">Remova a chamada para Assembly.LoadWithPartialName de {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="CategoryReliability">
        <source>Reliability</source>
        <target state="translated">Confiabilidade</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="VariableNamesShouldNotMatchFieldNamesTitle" xml:space="preserve">
    <value>Variable names should not match field names</value>
  </data>
  <data name="VariableNamesShouldNotMatchFieldNamesDescription" xml:space="preserve">
    <value>An instance method declares a parameter or a local variable whose name matches an instance field of the declaring type, leading to errors.</value>
  </data>
  <data name="VariableNamesShouldNotMatchFieldNamesMessageLocal" xml:space="preserve">
    <value>{0}, a variable declared in {1}, has the same name as an instance field on the type. Change the name of one of these items.</value>
  </data>
  <data name="VariableNamesShouldNotMatchFieldNamesMessageParameter" xml:space="preserve">
    <value>{0}, a parameter declared in {1}, has the same name as an instance field on the type. Change the name of one of these items.</value>
  </data>
  <data name="ReviewUnusedParametersTitle" xml:space="preserve">
    <value>Review unused parameters</value>
  </data>
  <data name="ReviewUnusedParametersDescription" xml:space="preserve">
    <value>A method signature includes a parameter that is not used in the method body.</value>
  </data>
  <data name="ReviewUnusedParametersMessage" xml:space="preserve">
    <value>Parameter {0} of method {1} is never used. Remove the parameter or use it in the method body.</value>
  </data>
  <data name="RemoveUnusedLocalsTitle" xml:space="preserve">
    <value>Remove unused locals</value>
  </data>
  <data name="RemoveUnusedLocalsDescription" xml:space="preserve">
    <value>Unused local variables and unnecessary assignments increase the size of an assembly and decrease performance.</value>
  </data>
  <data name="RemoveUnusedLocalsMessage" xml:space="preserve">
    <value>Remove unused locals</value>
  </data>
  <data name="RemoveUnusedParameterMessage" xml:space="preserve">
    <value>Remove unused parameter</value>
  </data>
  <data name="DoNotIgnoreMethodResultsTitle" xml:space="preserve">
    <value>Do not ignore method results</value>
  </data>
  <data name="DoNotIgnoreMethodResultsDescription" xml:space="preserve">
    <value>A new object is created but never used; or a method that creates and returns a new string is called and the new string is never used; or a COM or P/Invoke method returns an HRESULT or error code that is never used.</value>
  </data>
  <data name="DoNotIgnoreMethodResultsMessageObjectCreation" xml:space="preserve">
    <value>{0} creates a new instance of {1} which is never used. Pass the instance as an argument to another method, assign the instance to a variable, or remove the object creation if it is unnecessary.</value>
  </data>
  <data name="DoNotIgnoreMethodResultsMessageStringCreation" xml:space="preserve">
    <value>{0} calls {1} but does not use the new string instance that the method returns. Pass the instance as an argument to another method, assign the instance to a variable, or remove the call if it is unnecessary.</value>
  </data>
  <data name="DoNotIgnoreMethodResultsMessageHResultOrErrorCode" xml:space="preserve">
    <value>{0} calls {1} but does not use the HRESULT or error code that the method returns. This could lead to unexpected behavior in error conditions or low-resource situations. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</value>
  </data>
  <data name="DoNotIgnoreMethodResultsMessageTryParse" xml:space="preserve">
    <value>{0} calls {1} but does not explicitly check whether the conversion succeeded. Either use the return value in a conditional statement or verify that the call site expects that the out argument will be set to the default value when the conversion fails.</value>
  </data>
  <data name="AvoidUninstantiatedInternalClassesTitle" xml:space="preserve">
    <value>Avoid uninstantiated internal classes</value>
  </data>
  <data name="AvoidUninstantiatedInternalClassesDescription" xml:space="preserve">
    <value>An instance of an assembly-level type is not created by code in the assembly.</value>
  </data>
  <data name="AvoidUninstantiatedInternalClassesMessage" xml:space="preserve">
    <value>{0} is an internal class that is apparently never instantiated. If so, remove the code from the assembly. If this class is intended to contain only static members, make it static (Shared in Visual Basic).</value>
  </data>
  <data name="AvoidUnusedPrivateFieldsTitle" xml:space="preserve">
    <value>Avoid unused private fields</value>
  </data>
  <data name="AvoidUnusedPrivateFieldsDescription" xml:space="preserve">
    <value>Private fields were detected that do not appear to be accessed in the assembly.</value>
  </data>
  <data name="AvoidUnusedPrivateFieldsMessage" xml:space="preserve">
    <value>Unused field '{0}'.</value>
  </data>
  <data name="DoNotIgnoreMethodResultsMessagePureMethod" xml:space="preserve">
    <value>{0} calls {1} but does not use the value the method returns. Because {1} is marked as a Pure method, it cannot have side effects. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</value>
  </data>
  <data name="UseNameOfInPlaceOfStringDescription" xml:space="preserve">
    <value>Using nameof helps keep your code valid when refactoring.</value>
  </data>
  <data name="UseNameOfInPlaceOfStringMessage" xml:space="preserve">
    <value>Use nameof in place of string literal '{0}'</value>
  </data>
  <data name="UseNameOfInPlaceOfStringTitle" xml:space="preserve">
    <value>Use nameof to express symbol names</value>
  </data>
</root>
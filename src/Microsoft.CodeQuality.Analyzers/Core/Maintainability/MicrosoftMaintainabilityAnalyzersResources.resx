<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="VariableNamesShouldNotMatchFieldNamesTitle" xml:space="preserve">
    <value>Variable names should not match field names</value>
  </data>
  <data name="VariableNamesShouldNotMatchFieldNamesDescription" xml:space="preserve">
    <value>An instance method declares a parameter or a local variable whose name matches an instance field of the declaring type, leading to errors.</value>
  </data>
  <data name="VariableNamesShouldNotMatchFieldNamesMessageLocal" xml:space="preserve">
    <value>{0}, a variable declared in {1}, has the same name as an instance field on the type. Change the name of one of these items.</value>
  </data>
  <data name="VariableNamesShouldNotMatchFieldNamesMessageParameter" xml:space="preserve">
    <value>{0}, a parameter declared in {1}, has the same name as an instance field on the type. Change the name of one of these items.</value>
  </data>
  <data name="ReviewUnusedParametersTitle" xml:space="preserve">
    <value>Review unused parameters</value>
  </data>
  <data name="ReviewUnusedParametersDescription" xml:space="preserve">
    <value>Avoid unused paramereters in your code. If the parameter cannot be removed, then change its name so it starts with an underscore and is optionally followed by an integer, such as '_', '_1', '_2', etc. These are treated as special discard symbol names.</value>
  </data>
  <data name="ReviewUnusedParametersMessage" xml:space="preserve">
    <value>Parameter {0} of method {1} is never used. Remove the parameter or use it in the method body.</value>
  </data>
  <data name="RemoveUnusedParameterMessage" xml:space="preserve">
    <value>Remove unused parameter</value>
  </data>
  <data name="DoNotIgnoreMethodResultsTitle" xml:space="preserve">
    <value>Do not ignore method results</value>
  </data>
  <data name="DoNotIgnoreMethodResultsDescription" xml:space="preserve">
    <value>A new object is created but never used; or a method that creates and returns a new string is called and the new string is never used; or a COM or P/Invoke method returns an HRESULT or error code that is never used.</value>
  </data>
  <data name="DoNotIgnoreMethodResultsMessageObjectCreation" xml:space="preserve">
    <value>{0} creates a new instance of {1} which is never used. Pass the instance as an argument to another method, assign the instance to a variable, or remove the object creation if it is unnecessary.</value>
  </data>
  <data name="DoNotIgnoreMethodResultsMessageStringCreation" xml:space="preserve">
    <value>{0} calls {1} but does not use the new string instance that the method returns. Pass the instance as an argument to another method, assign the instance to a variable, or remove the call if it is unnecessary.</value>
  </data>
  <data name="DoNotIgnoreMethodResultsMessageHResultOrErrorCode" xml:space="preserve">
    <value>{0} calls {1} but does not use the HRESULT or error code that the method returns. This could lead to unexpected behavior in error conditions or low-resource situations. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</value>
  </data>
  <data name="DoNotIgnoreMethodResultsMessageTryParse" xml:space="preserve">
    <value>{0} calls {1} but does not explicitly check whether the conversion succeeded. Either use the return value in a conditional statement or verify that the call site expects that the out argument will be set to the default value when the conversion fails.</value>
  </data>
  <data name="AvoidUninstantiatedInternalClassesTitle" xml:space="preserve">
    <value>Avoid uninstantiated internal classes</value>
  </data>
  <data name="AvoidUninstantiatedInternalClassesDescription" xml:space="preserve">
    <value>An instance of an assembly-level type is not created by code in the assembly.</value>
  </data>
  <data name="AvoidUninstantiatedInternalClassesMessage" xml:space="preserve">
    <value>{0} is an internal class that is apparently never instantiated. If so, remove the code from the assembly. If this class is intended to contain only static members, make it static (Shared in Visual Basic).</value>
  </data>
  <data name="AvoidUnusedPrivateFieldsTitle" xml:space="preserve">
    <value>Avoid unused private fields</value>
  </data>
  <data name="AvoidUnusedPrivateFieldsDescription" xml:space="preserve">
    <value>Private fields were detected that do not appear to be accessed in the assembly.</value>
  </data>
  <data name="AvoidUnusedPrivateFieldsMessage" xml:space="preserve">
    <value>Unused field '{0}'.</value>
  </data>
  <data name="DoNotIgnoreMethodResultsMessagePureMethod" xml:space="preserve">
    <value>{0} calls {1} but does not use the value the method returns. Because {1} is marked as a Pure method, it cannot have side effects. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</value>
  </data>
  <data name="UseNameOfInPlaceOfStringDescription" xml:space="preserve">
    <value>Using nameof helps keep your code valid when refactoring.</value>
  </data>
  <data name="UseNameOfInPlaceOfStringMessage" xml:space="preserve">
    <value>Use nameof in place of string literal '{0}'</value>
  </data>
  <data name="UseNameOfInPlaceOfStringTitle" xml:space="preserve">
    <value>Use nameof to express symbol names</value>
  </data>
  <data name="AvoidDeadConditionalCodeAlwaysTruFalseOrNullMessage" xml:space="preserve">
    <value>'{0}' is always '{1}'. Remove or refactor the condition(s) to avoid dead code.</value>
  </data>
  <data name="AvoidDeadConditionalCodeNeverNullMessage" xml:space="preserve">
    <value>'{0}' is never '{1}'. Remove or refactor the condition(s) to avoid dead code.</value>
  </data>
  <data name="AvoidDeadConditionalCodeTitle" xml:space="preserve">
    <value>Avoid dead conditional code</value>
  </data>
  <data name="AvoidExcessiveClassCouplingDescription" xml:space="preserve">
    <value>This rule measures class coupling by counting the number of unique type references that a symbol contains. Symbols that have a high degree of class coupling can be difficult to maintain. It is a good practice to have types and methods that exhibit low coupling and high cohesion. To fix this violation, try to redesign the code to reduce the number of types to which it is coupled.</value>
  </data>
  <data name="AvoidExcessiveClassCouplingMessage" xml:space="preserve">
    <value>'{0}' is coupled with '{1}' different types from '{2}' different namespaces. Rewrite or refactor the code to decrease its class coupling below '{3}'.</value>
  </data>
  <data name="AvoidExcessiveClassCouplingTitle" xml:space="preserve">
    <value>Avoid excessive class coupling</value>
  </data>
  <data name="AvoidExcessiveComplexityDescription" xml:space="preserve">
    <value>Cyclomatic complexity measures the number of linearly independent paths through the method, which is determined by the number and complexity of conditional branches. A low cyclomatic complexity generally indicates a method that is easy to understand, test, and maintain. The cyclomatic complexity is calculated from a control flow graph of the method and is given as follows: `cyclomatic complexity = the number of edges - the number of nodes + 1`, where a node represents a logic branch point and an edge represents a line between nodes.</value>
  </data>
  <data name="AvoidExcessiveComplexityMessage" xml:space="preserve">
    <value>'{0}' has a cyclomatic complexity of '{1}'. Rewrite or refactor the code to decrease its complexity below '{2}'.</value>
  </data>
  <data name="AvoidExcessiveComplexityTitle" xml:space="preserve">
    <value>Avoid excessive complexity</value>
  </data>
  <data name="AvoidExcessiveInheritanceDescription" xml:space="preserve">
    <value>Deeply nested type hierarchies can be difficult to follow, understand, and maintain. This rule limits analysis to hierarchies in the same module. To fix a violation of this rule, derive the type from a base type that is less deep in the inheritance hierarchy or eliminate some of the intermediate base types.</value>
  </data>
  <data name="AvoidExcessiveInheritanceMessage" xml:space="preserve">
    <value>'{0}' has an object hierarchy '{1}' levels deep within the defining module. If possible, eliminate base classes within the hierarchy to decrease its hierarchy level below '{2}': '{3}'</value>
  </data>
  <data name="AvoidExcessiveInheritanceTitle" xml:space="preserve">
    <value>Avoid excessive inheritance</value>
  </data>
  <data name="AvoidUnmantainableCodeDescription" xml:space="preserve">
    <value>The maintainability index is calculated by using the following metrics: lines of code, program volume, and cyclomatic complexity. Program volume is a measure of the difficulty of understanding of a symbol that is based on the number of operators and operands in the code. Cyclomatic complexity is a measure of the structural complexity of the type or method. A low maintainability index indicates that code is probably difficult to maintain and would be a good candidate to redesign.</value>
  </data>
  <data name="AvoidUnmantainableCodeMessage" xml:space="preserve">
    <value>'{0}' has a maintainability index of '{1}'. Rewrite or refactor the code to increase its maintainability index (MI) above '{2}'.</value>
  </data>
  <data name="AvoidUnmantainableCodeTitle" xml:space="preserve">
    <value>Avoid unmaintainable code</value>
  </data>
  <data name="InvalidEntryInCodeMetricsConfigFileDescription" xml:space="preserve">
    <value>Invalid entry in code metrics rule specification file</value>
  </data>
  <data name="InvalidEntryInCodeMetricsConfigFileMessage" xml:space="preserve">
    <value>Invalid entry '{0}' in code metrics rule specification file '{1}'</value>
  </data>
  <data name="InvalidEntryInCodeMetricsConfigFileTitle" xml:space="preserve">
    <value>Invalid entry in code metrics rule specification file</value>
  </data>
</root>
<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="cs" original="../MicrosoftMaintainabilityAnalyzersResources.resx">
    <body>
      <trans-unit id="AvoidDeadConditionalCodeAlwaysTruFalseOrNullMessage">
        <source>'{0}' is always '{1}'. Remove or refactor the condition(s) to avoid dead code.</source>
        <target state="new">'{0}' is always '{1}'. Remove or refactor the condition(s) to avoid dead code.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDeadConditionalCodeNeverNullMessage">
        <source>'{0}' is never '{1}'. Remove or refactor the condition(s) to avoid dead code.</source>
        <target state="new">'{0}' is never '{1}'. Remove or refactor the condition(s) to avoid dead code.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDeadConditionalCodeTitle">
        <source>Avoid dead conditional code</source>
        <target state="new">Avoid dead conditional code</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingDescription">
        <source>This rule measures class coupling by counting the number of unique type references that a symbol contains. Symbols that have a high degree of class coupling can be difficult to maintain. It is a good practice to have types and methods that exhibit low coupling and high cohesion. To fix this violation, try to redesign the code to reduce the number of types to which it is coupled.</source>
        <target state="translated">Toto pravidlo měří párování tříd tak, že počítá jedinečné odkazy na typy obsažené v symbolu. Symboly s vysokým stupněm párování tříd může být složité udržovat. Doporučeným postupem je používat typy a metody s nízkým párováním a vysokou kohezí. Pokud chcete porušení tohoto pravidla opravit, zkuste kód přepracovat tak, aby se snížil počet typů, na které se páruje.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingMessage">
        <source>'{0}' is coupled with '{1}' different types from '{2}' different namespaces. Rewrite or refactor the code to decrease its class coupling below '{3}'.</source>
        <target state="translated">{0} se páruje s {1} různými typy z {2} různých oborů názvů. Přepište nebo refaktorujte kód tak, aby se párování tříd snížilo pod {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingTitle">
        <source>Avoid excessive class coupling</source>
        <target state="translated">Vyhněte se nadměrnému párování tříd</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityDescription">
        <source>Cyclomatic complexity measures the number of linearly independent paths through the method, which is determined by the number and complexity of conditional branches. A low cyclomatic complexity generally indicates a method that is easy to understand, test, and maintain. The cyclomatic complexity is calculated from a control flow graph of the method and is given as follows: `cyclomatic complexity = the number of edges - the number of nodes + 1`, where a node represents a logic branch point and an edge represents a line between nodes.</source>
        <target state="needs-review-translation">Cyklomatická složitost měří počet lineárně nezávislých cest skrz metodu, který se určuje podle počtu a složitosti podmínkových větví. Nízká cyklomatická složitost obecně naznačuje, že metodu bude snadné pochopit, testovat a udržovat. Cyklomatická složitost se počítá z grafu toku řízení metody, a to takto:

cyklomatická složitost = počet hran - počet uzlů + 1

kde uzel představuje bod větvení logiky a hrana představuje spojnici mezi uzly.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityMessage">
        <source>'{0}' has a cyclomatic complexity of '{1}'. Rewrite or refactor the code to decrease its complexity below '{2}'.</source>
        <target state="translated">{0} má cyklomatickou složitost na úrovni {1}. Přepište nebo refaktorujte kód tak, aby se složitost snížila pod úroveň {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityTitle">
        <source>Avoid excessive complexity</source>
        <target state="translated">Vyhněte se nadměrné složitosti</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceDescription">
        <source>Deeply nested type hierarchies can be difficult to follow, understand, and maintain. This rule limits analysis to hierarchies in the same module. To fix a violation of this rule, derive the type from a base type that is less deep in the inheritance hierarchy or eliminate some of the intermediate base types.</source>
        <target state="translated">Hluboce vnořené hierarchie typů můžou být složité na sledování, pochopení a údržbu. Toto pravidlo omezuje analýzu na hierarchie ve stejném modulu. Pokud chcete porušení tohoto pravidla opravit, odvoďte typ od základního typu, který je méně hluboko v hierarchii dědičnosti, nebo eliminujte některé z mezilehlých základních typů.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceMessage">
        <source>'{0}' has an object hierarchy '{1}' levels deep within the defining module. If possible, eliminate base classes within the hierarchy to decrease its hierarchy level below '{2}': '{3}'</source>
        <target state="translated">{0} má hierarchii objektů, která v definujícím modulu dosahuje hloubky {1} úrovní. Pokud je to možné, eliminujte v hierarchii základní třídy tak, aby se počet úrovní v hierarchii snížil pod {2}: {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceTitle">
        <source>Avoid excessive inheritance</source>
        <target state="translated">Vyhněte se nadměrné dědičnosti</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeDescription">
        <source>The maintainability index is calculated by using the following metrics: lines of code, program volume, and cyclomatic complexity. Program volume is a measure of the difficulty of understanding of a symbol that is based on the number of operators and operands in the code. Cyclomatic complexity is a measure of the structural complexity of the type or method. A low maintainability index indicates that code is probably difficult to maintain and would be a good candidate to redesign.</source>
        <target state="needs-review-translation">Index udržovatelnosti se počítá za použití následujících metrik: řádky kódu, objem programu a cyklomatická složitost. Objem programu je míra složitosti pochopení symbolu, která je založená na počtu operátorů a operandů v kódu. Cyklomatická složitost je míra strukturální složitosti typu nebo metody.
Nízký index udržovatelnosti naznačuje, že kód bude pravděpodobně složité udržovat a že by bylo vhodné ho přepracovat.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeMessage">
        <source>'{0}' has a maintainability index of '{1}'. Rewrite or refactor the code to increase its maintainability index (MI) above '{2}'.</source>
        <target state="translated">{0} má index udržovatelnosti {1}. Přepište nebo refaktorujte kód tak, aby se index udržovatelnosti zvýšil nad {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeTitle">
        <source>Avoid unmaintainable code</source>
        <target state="translated">Vyhněte se neudržovatelnému kódu</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileDescription">
        <source>Invalid entry in code metrics rule specification file</source>
        <target state="translated">Neplatná položka v souboru specifikace pravidel metrik kódu</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileMessage">
        <source>Invalid entry '{0}' in code metrics rule specification file '{1}'</source>
        <target state="translated">Neplatná položka {0} v souboru specifikace pravidel metrik kódu {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileTitle">
        <source>Invalid entry in code metrics rule specification file</source>
        <target state="translated">Neplatná položka v souboru specifikace pravidel metrik kódu</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesTitle">
        <source>Variable names should not match field names</source>
        <target state="translated">Názvy proměnných se nemají shodovat s názvy polí.</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesDescription">
        <source>An instance method declares a parameter or a local variable whose name matches an instance field of the declaring type, leading to errors.</source>
        <target state="translated">Metoda instance deklaruje parametr nebo lokální proměnnou, jejíž název se shoduje s polem instance deklarujícího typu, což způsobí chyby.</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesMessageLocal">
        <source>{0}, a variable declared in {1}, has the same name as an instance field on the type. Change the name of one of these items.</source>
        <target state="translated">Proměnná {0} deklarovaná v {1} má stejný název jako pole instance u tohoto typu. Změňte název jedné z těchto položek.</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesMessageParameter">
        <source>{0}, a parameter declared in {1}, has the same name as an instance field on the type. Change the name of one of these items.</source>
        <target state="translated">Parametr {0} deklarovaný v {1} má stejný název jako pole instance u tohoto typu. Změňte název jedné z těchto položek.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewUnusedParametersTitle">
        <source>Review unused parameters</source>
        <target state="translated">Zkontrolujte nepoužité parametry.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewUnusedParametersDescription">
        <source>A method signature includes a parameter that is not used in the method body.</source>
        <target state="translated">Podpis metody obsahuje parametr, který se nepoužívá v těle metody.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewUnusedParametersMessage">
        <source>Parameter {0} of method {1} is never used. Remove the parameter or use it in the method body.</source>
        <target state="translated">Parametr {0} metody {1} se vůbec nepoužívá. Odeberte tento parametr nebo ho použijte v těle metody.</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveUnusedParameterMessage">
        <source>Remove unused parameter</source>
        <target state="translated">Odebrat nepoužívaný parametr</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsTitle">
        <source>Do not ignore method results</source>
        <target state="translated">Neignorujte výsledky metod.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsDescription">
        <source>A new object is created but never used; or a method that creates and returns a new string is called and the new string is never used; or a COM or P/Invoke method returns an HRESULT or error code that is never used.</source>
        <target state="translated">Je vytvořený nový objekt, který se vůbec nepoužívá; nebo se volá metoda, která vytváří a vrací nový řetězec, který se vůbec nepoužívá; nebo metoda COM či P/Invoke vrací HRESULT nebo kód chyby, který se vůbec nepoužívá.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageObjectCreation">
        <source>{0} creates a new instance of {1} which is never used. Pass the instance as an argument to another method, assign the instance to a variable, or remove the object creation if it is unnecessary.</source>
        <target state="translated">{0} vytváří novou instanci {1}, která se vůbec nepoužívá. Předejte tuto instanci jako argument jiné metodě, přiřaďte tuto instanci proměnné nebo odeberte vytvoření objektu, pokud je nepotřebný.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageStringCreation">
        <source>{0} calls {1} but does not use the new string instance that the method returns. Pass the instance as an argument to another method, assign the instance to a variable, or remove the call if it is unnecessary.</source>
        <target state="translated">{0} volá {1}, ale nepoužívá novou instanci řetězce, kterou tato metoda vrací. Předejte tuto instanci jako argument jiné metodě, přiřaďte tuto instanci proměnné nebo odeberte volání, pokud je nepotřebné.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageHResultOrErrorCode">
        <source>{0} calls {1} but does not use the HRESULT or error code that the method returns. This could lead to unexpected behavior in error conditions or low-resource situations. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</source>
        <target state="translated">{0} volá {1}, ale nepoužívá HRESULT ani kód chyby, který tato metoda vrací. To může vést k neočekávanému chování při výskytu chyby nebo nedostatku prostředků. Použijte výsledek v podmíněném příkazu, přiřaďte výsledek proměnné nebo ho předejte jako argument jiné metodě.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageTryParse">
        <source>{0} calls {1} but does not explicitly check whether the conversion succeeded. Either use the return value in a conditional statement or verify that the call site expects that the out argument will be set to the default value when the conversion fails.</source>
        <target state="translated">{0} volá {1}, ale explicitně nekontroluje, jestli byl převod úspěšný. Buď použijte návratovou hodnotu v podmíněném příkazu, nebo ověřte, jestli volající web očekává, že se výstupní argument nastaví na výchozí hodnotu, když se převod nepodaří.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesTitle">
        <source>Avoid uninstantiated internal classes</source>
        <target state="translated">Vyhněte se interním třídám bez vytvořené instance.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesDescription">
        <source>An instance of an assembly-level type is not created by code in the assembly.</source>
        <target state="translated">Instance typu na úrovni sestavení není vytvořená kódem v tomto sestavení.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesMessage">
        <source>{0} is an internal class that is apparently never instantiated. If so, remove the code from the assembly. If this class is intended to contain only static members, make it static (Shared in Visual Basic).</source>
        <target state="translated">{0} je interní třída, jejíž instance není zjevně vůbec vytvořená. V takovém případě odeberte tento kód ze sestavení. Pokud má tato třída obsahovat jenom statické členy, nastavte ji jako statickou (sdílenou ve Visual Basicu).</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsTitle">
        <source>Avoid unused private fields</source>
        <target state="translated">Vyhněte se nepoužitým privátním polím.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsDescription">
        <source>Private fields were detected that do not appear to be accessed in the assembly.</source>
        <target state="translated">Byla zjištěna privátní pole, která se podle všeho v tomto sestavení nepoužívají.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsMessage">
        <source>Unused field '{0}'.</source>
        <target state="translated">Nepoužité pole {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessagePureMethod">
        <source>{0} calls {1} but does not use the value the method returns. Because {1} is marked as a Pure method, it cannot have side effects. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</source>
        <target state="translated">{0} volá {1}, ale nepoužívá hodnotu, kterou tato metoda vrací. Protože {1} je označená jako metoda Pure, nemůže mít vedlejší účinky. Použijte výsledek v podmíněném příkazu, přiřaďte výsledek proměnné nebo ho předejte jako argument jiné metodě.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringDescription">
        <source>Using nameof helps keep your code valid when refactoring.</source>
        <target state="translated">Použití nameof pomůže zachovat platnost vašeho kódu při refaktoringu.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringMessage">
        <source>Use nameof in place of string literal '{0}'</source>
        <target state="translated">Namísto řetězcového literálu {0} použijte nameof.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringTitle">
        <source>Use nameof to express symbol names</source>
        <target state="translated">K vyjádření názvů symbolů použijte nameof</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
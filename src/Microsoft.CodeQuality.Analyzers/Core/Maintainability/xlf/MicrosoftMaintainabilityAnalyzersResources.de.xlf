<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="de" original="../MicrosoftMaintainabilityAnalyzersResources.resx">
    <body>
      <trans-unit id="AvoidDeadConditionalCodeAlwaysTruFalseOrNullMessage">
        <source>'{0}' is always '{1}'. Remove or refactor the condition(s) to avoid dead code.</source>
        <target state="new">'{0}' is always '{1}'. Remove or refactor the condition(s) to avoid dead code.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDeadConditionalCodeNeverNullMessage">
        <source>'{0}' is never '{1}'. Remove or refactor the condition(s) to avoid dead code.</source>
        <target state="new">'{0}' is never '{1}'. Remove or refactor the condition(s) to avoid dead code.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDeadConditionalCodeTitle">
        <source>Avoid dead conditional code</source>
        <target state="new">Avoid dead conditional code</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingDescription">
        <source>This rule measures class coupling by counting the number of unique type references that a symbol contains. Symbols that have a high degree of class coupling can be difficult to maintain. It is a good practice to have types and methods that exhibit low coupling and high cohesion. To fix this violation, try to redesign the code to reduce the number of types to which it is coupled.</source>
        <target state="translated">Diese Regel misst die Kopplung zwischen Klassen, indem sie die Anzahl der eindeutigen Typrefenzen in einem Symbol zählt. Es kann schwierig sein, Symbole, bei denen viele Klassen aneinder gekoppelt sind, zu verwalten. Es werden Typen und Methoden empfohlen, die wenige Kopplungen und ein hohes Maß an Kohäsion aufweisen. Wenn Sie diesen Verstoß beheben möchten, gestalten Sie den Code um, um die Anzahl an Typen zu reduzieren, an die dieser gekoppelt ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingMessage">
        <source>'{0}' is coupled with '{1}' different types from '{2}' different namespaces. Rewrite or refactor the code to decrease its class coupling below '{3}'.</source>
        <target state="translated">"{0}" wird mit "{1}" verschiedenen Typen von "{2}" verschiedenen Namespaces verknüpft. Schreiben Sie den Code neu, oder gestalten Sie ihn um, um die Kopplung zwischen Klassen auf einen Wert unter "{3}" zu senken.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingTitle">
        <source>Avoid excessive class coupling</source>
        <target state="translated">Übermäßige Klassenkopplungen vermeiden</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityDescription">
        <source>Cyclomatic complexity measures the number of linearly independent paths through the method, which is determined by the number and complexity of conditional branches. A low cyclomatic complexity generally indicates a method that is easy to understand, test, and maintain. The cyclomatic complexity is calculated from a control flow graph of the method and is given as follows: `cyclomatic complexity = the number of edges - the number of nodes + 1`, where a node represents a logic branch point and an edge represents a line between nodes.</source>
        <target state="needs-review-translation">Die zyklomatische Komplexität misst die Anzahl der linear unabhängigen Pfade über die Methode, die anhand der Anzahl und der Komplexität der Verbindungsverzweigung bestimmt wird. Geringe zyklomatische Komplexität deutet auf eine Methode hin, die einfach zu verstehen, zu testen und zu verwalten ist. Die zyklomatische Komplexität wird wie folgt über ein Diagramm der Methode zur Ablaufsteuerung berechnet:

zyklomatische Komplexität = die Anzahl der Edges – die Anzahl der Knoten + 1

Dabei ist ein Knoten ein logischer Verzweigungspunkt und ein Edge eine Zeile zwischen zwei Knoten.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityMessage">
        <source>'{0}' has a cyclomatic complexity of '{1}'. Rewrite or refactor the code to decrease its complexity below '{2}'.</source>
        <target state="translated">"{0}" weist eine zyklomatische Komplexität von "{1}" auf. Schreiben Sie den Code neu, oder gestalten Sie ihn um, um die Komplexität auf einen Wert unter "{2}" zu senken.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityTitle">
        <source>Avoid excessive complexity</source>
        <target state="translated">Übermäßige Komplexität vermeiden</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceDescription">
        <source>Deeply nested type hierarchies can be difficult to follow, understand, and maintain. This rule limits analysis to hierarchies in the same module. To fix a violation of this rule, derive the type from a base type that is less deep in the inheritance hierarchy or eliminate some of the intermediate base types.</source>
        <target state="translated">Es kann schwierig sein, stark verschachtelte Typhierarchien nachzuverfolgen, nachzuvollziehen und zu verwalten. Diese Regel schränkt Analysen auf Hierarchien im selben Modul ein. Wenn Sie einen Verstoß gegen diese Regel beheben möchten, leiten Sie den Typ von einem Basistypen ab, dessen Vererbungshierarchie weniger stark verschachtelt ist, oder löschen Sie einige der Zwischenbasistypen.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceMessage">
        <source>'{0}' has an object hierarchy '{1}' levels deep within the defining module. If possible, eliminate base classes within the hierarchy to decrease its hierarchy level below '{2}': '{3}'</source>
        <target state="translated">"{0}" weist eine "{1}" Ebenen tiefe Objekthierarchie innerhalb des definierenden Moduls auf. Löschen Sie nach Möglichkeit Basisklassen innerhalb der Hierarchie, um die Hierarchiebene auf einen Wert unter "{2}": "{3}" zu senken</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceTitle">
        <source>Avoid excessive inheritance</source>
        <target state="translated">Übermäßige Vererbung vermeiden</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeDescription">
        <source>The maintainability index is calculated by using the following metrics: lines of code, program volume, and cyclomatic complexity. Program volume is a measure of the difficulty of understanding of a symbol that is based on the number of operators and operands in the code. Cyclomatic complexity is a measure of the structural complexity of the type or method. A low maintainability index indicates that code is probably difficult to maintain and would be a good candidate to redesign.</source>
        <target state="needs-review-translation">Der Wartbarkeitsindex wird anhand der folgenden Metriken bestimmt: Codezeilen, Programmvolumen und zyklomatische Komplexität. Das Programmvolumen stellt eine Kennzahl für den Schwierigkeitsgrad für das Verstehen eines Symbols dar, die auf der Anzahl der Operatoren und Operanden im Code basiert. Die zyklomatische Komplexität ist eine Kennzahl für die Komplexität der Struktur des Typs oder der Methode.
Ein niedriger Wartbarkeitsindex deutet darauf hin, dass der Code wahrscheinlich schwierig zu verwalten ist und umgestaltet werden sollte.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeMessage">
        <source>'{0}' has a maintainability index of '{1}'. Rewrite or refactor the code to increase its maintainability index (MI) above '{2}'.</source>
        <target state="translated">"{0}" hat einen Wartbarkeitsindex von "{1}". Schreiben Sie den Code neu, oder gestalten Sie ihn um, um den Wartbarkeitsindex auf einen Wert über "{2}" zu erhöhen.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeTitle">
        <source>Avoid unmaintainable code</source>
        <target state="translated">Nicht wartbaren Code vermeiden</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileDescription">
        <source>Invalid entry in code metrics rule specification file</source>
        <target state="translated">Ungültiger Eintrag in der Datei zur Spezifikation von Regeln für Codemteriken.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileMessage">
        <source>Invalid entry '{0}' in code metrics rule specification file '{1}'</source>
        <target state="translated">Ungültige Eingabe "{0}" in der Spezifikationsdatei "{1}" für Codemetrikregeln.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileTitle">
        <source>Invalid entry in code metrics rule specification file</source>
        <target state="translated">Ungültiger Eintrag in der Spezifikationsdatei für die Codemetrikregeln.</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesTitle">
        <source>Variable names should not match field names</source>
        <target state="translated">Variablennamen dürfen nicht mit Feldnamen übereinstimmen</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesDescription">
        <source>An instance method declares a parameter or a local variable whose name matches an instance field of the declaring type, leading to errors.</source>
        <target state="translated">Eine Instanzenmethode deklariert einen Parameter oder eine lokale Variable, deren Name mit einem Instanzenfeld des deklarierenden Typs übereinstimmt. Dies führt zu Fehlern.</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesMessageLocal">
        <source>{0}, a variable declared in {1}, has the same name as an instance field on the type. Change the name of one of these items.</source>
        <target state="translated">"{0}", eine in "{1}" deklarierte Variable, besitzt denselben Namen wie ein Instanzenfeld für den Typ. Ändern Sie den Namen eines der Elemente.</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesMessageParameter">
        <source>{0}, a parameter declared in {1}, has the same name as an instance field on the type. Change the name of one of these items.</source>
        <target state="translated">"{0}", ein in "{1}" deklarierter Parameter, besitzt denselben Namen wie ein Instanzenfeld für den Typ. Ändern Sie den Namen eines der Elemente.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewUnusedParametersTitle">
        <source>Review unused parameters</source>
        <target state="translated">Nicht verwendete Parameter überprüfen</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewUnusedParametersDescription">
        <source>A method signature includes a parameter that is not used in the method body.</source>
        <target state="translated">Eine Methodensignatur enthält einen Parameter, der im Methodentext nicht verwendet wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewUnusedParametersMessage">
        <source>Parameter {0} of method {1} is never used. Remove the parameter or use it in the method body.</source>
        <target state="translated">Der Parameter "{0}" der Methode "{1}" wird niemals verwendet. Entfernen Sie den Parameter, oder verwenden Sie ihn im Methodentext.</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveUnusedParameterMessage">
        <source>Remove unused parameter</source>
        <target state="translated">Nicht verwendete Parameter entfernen</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsTitle">
        <source>Do not ignore method results</source>
        <target state="translated">Methodenergebnisse nicht ignorieren</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsDescription">
        <source>A new object is created but never used; or a method that creates and returns a new string is called and the new string is never used; or a COM or P/Invoke method returns an HRESULT or error code that is never used.</source>
        <target state="translated">Ein neues Objekt wird erstellt, aber nicht verwendet, oder eine Methode wird aufgerufen, die eine neue Zeichenfolge erstellt und zurückgibt, aber die neue Zeichenfolge wird niemals verwendet, oder eine COM- oder P/Invoke-Methode gibt einen HRESULT-Wert oder einen Fehlercode zurück, der nicht verwendet wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageObjectCreation">
        <source>{0} creates a new instance of {1} which is never used. Pass the instance as an argument to another method, assign the instance to a variable, or remove the object creation if it is unnecessary.</source>
        <target state="translated">"{0}" erstellt eine neue Instanz von "{1}", die nicht verwendet wird. Übergeben Sie die Instanz als Argument an eine andere Methode, weisen Sie die Instanz einer Variablen zu, oder entfernen Sie die Objekterstellung, sofern sie unnötig ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageStringCreation">
        <source>{0} calls {1} but does not use the new string instance that the method returns. Pass the instance as an argument to another method, assign the instance to a variable, or remove the call if it is unnecessary.</source>
        <target state="translated">"{0}" ruft "{1}" auf, verwendet jedoch nicht die neue Zeichenfolgeninstanz, die von der Methode zurückgegeben wird. Übergeben Sie die Instanz als Argument an eine andere Methode, weisen Sie die Instanz einer Variablen zu, oder entfernen Sie den Aufruf, sofern er unnötig ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageHResultOrErrorCode">
        <source>{0} calls {1} but does not use the HRESULT or error code that the method returns. This could lead to unexpected behavior in error conditions or low-resource situations. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</source>
        <target state="translated">"{0}" ruft "{1}" auf, verwendet jedoch nicht den HRESULT-Wert oder den Fehlercode, der von der Methode zurückgegeben wird. Dies kann zu unerwartetem Verhalten bei Fehlerbedingungen oder in Situationen mit Ressourcenknappheit führen. Verwenden Sie das Ergebnis in einer Bedingungsanweisung, weisen Sie das Ergebnis einer Variablen zu, oder übergeben Sie es als Argument an eine andere Methode.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageTryParse">
        <source>{0} calls {1} but does not explicitly check whether the conversion succeeded. Either use the return value in a conditional statement or verify that the call site expects that the out argument will be set to the default value when the conversion fails.</source>
        <target state="translated">"{0}" ruft "{1}" auf, überprüft aber nicht explizit, ob die Konvertierung erfolgreich verlaufen ist. Verwenden Sie entweder den Rückgabewert in einer Bedingungsanweisung, oder prüfen Sie, ob die Aufrufsite erwartet, dass das ausgehende Argument bei einem Konvertierungsfehler auf den Standardwert festgelegt wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesTitle">
        <source>Avoid uninstantiated internal classes</source>
        <target state="translated">Nicht instanziierte interne Klassen vermeiden</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesDescription">
        <source>An instance of an assembly-level type is not created by code in the assembly.</source>
        <target state="translated">Eine Instanz eines Typs auf Assemblyebene wird nicht von Code in der Assembly erstellt.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesMessage">
        <source>{0} is an internal class that is apparently never instantiated. If so, remove the code from the assembly. If this class is intended to contain only static members, make it static (Shared in Visual Basic).</source>
        <target state="translated">"{0}" ist eine interne Klasse, die offenbar niemals instanziiert wird. Entfernen Sie in diesem Fall den Code aus der Assembly. Wenn diese Klasse nur statische Member enthalten soll, legen Sie sie als "static" fest ("Shared" in Visual Basic).</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsTitle">
        <source>Avoid unused private fields</source>
        <target state="translated">Nicht verwendete private Felder vermeiden</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsDescription">
        <source>Private fields were detected that do not appear to be accessed in the assembly.</source>
        <target state="translated">Private Felder wurden ermittelt, auf die in der Assembly offenbar nicht zugegriffen wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsMessage">
        <source>Unused field '{0}'.</source>
        <target state="translated">Nicht verwendetes Feld "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessagePureMethod">
        <source>{0} calls {1} but does not use the value the method returns. Because {1} is marked as a Pure method, it cannot have side effects. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</source>
        <target state="translated">"{0}" ruft "{1}" auf, verwendet jedoch nicht den von der Methode zurückgegebenen Wert. Weil "{1}" als Pure-Methode markiert ist, kann sie keine Nebeneffekte haben. Verwenden Sie das Ergebnis in einer Bedingungsanweisung, weisen Sie das Ergebnis einer Variablen zu, oder übergeben Sie es als Argument an eine andere Methode.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringDescription">
        <source>Using nameof helps keep your code valid when refactoring.</source>
        <target state="translated">Durch das Verwenden von "nameof" behält Ihr Code beim Refactoring seine Gültigkeit.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringMessage">
        <source>Use nameof in place of string literal '{0}'</source>
        <target state="translated">"nameof" anstelle des Zeichenfolgenliterals "{0}" verwenden</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringTitle">
        <source>Use nameof to express symbol names</source>
        <target state="translated">"nameof" für Symbolnamen verwenden</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
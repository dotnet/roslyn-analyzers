<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="es" original="../MicrosoftMaintainabilityAnalyzersResources.resx">
    <body>
      <trans-unit id="AvoidDeadConditionalCodeAlwaysTruFalseOrNullMessage">
        <source>'{0}' is always '{1}'. Remove or refactor the condition(s) to avoid dead code.</source>
        <target state="translated">"{0}" siempre es "{1}". Quite o refactorice las condiciones para evitar el código no alcanzado.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDeadConditionalCodeNeverNullMessage">
        <source>'{0}' is never '{1}'. Remove or refactor the condition(s) to avoid dead code.</source>
        <target state="translated">"{0}" nunca es "{1}". Quite o refactorice las condiciones para evitar el código no alcanzado.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDeadConditionalCodeTitle">
        <source>Avoid dead conditional code</source>
        <target state="translated">Evitar código condicional no alcanzado</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingDescription">
        <source>This rule measures class coupling by counting the number of unique type references that a symbol contains. Symbols that have a high degree of class coupling can be difficult to maintain. It is a good practice to have types and methods that exhibit low coupling and high cohesion. To fix this violation, try to redesign the code to reduce the number of types to which it is coupled.</source>
        <target state="translated">Esta regla mide el acoplamiento de clase contando el número de referencias de tipo únicas que contiene un símbolo. Los símbolos que tienen un alto grado de acoplamiento de la clase pueden ser difíciles de mantener. Es una buena práctica tener tipos y métodos que exhiben un acoplamiento bajo y una alta cohesión. Para corregir esta infracción, intente rediseñar el código para reducir el número de tipos a los que está acoplado.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingMessage">
        <source>'{0}' is coupled with '{1}' different types from '{2}' different namespaces. Rewrite or refactor the code to decrease its class coupling below '{3}'.</source>
        <target state="translated">"{0}" se combina con "{1}" tipos diferentes de "{2}" diferentes espacios de nombres. Reescriba o refactorice el código para disminuir su acoplamiento de clase por debajo de "{3}".</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingTitle">
        <source>Avoid excessive class coupling</source>
        <target state="translated">Evite el acoplamiento excesivo de clases</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityDescription">
        <source>Cyclomatic complexity measures the number of linearly independent paths through the method, which is determined by the number and complexity of conditional branches. A low cyclomatic complexity generally indicates a method that is easy to understand, test, and maintain. The cyclomatic complexity is calculated from a control flow graph of the method and is given as follows: `cyclomatic complexity = the number of edges - the number of nodes + 1`, where a node represents a logic branch point and an edge represents a line between nodes.</source>
        <target state="translated">La complejidad ciclomática mide el número de rutas de acceso independientes linealmente a través del método, que viene determinado por el número y la complejidad de las ramas condicionales. Una complejidad ciclomática baja indica un método que es fácil de entender, probar y mantener. Dicha complejidad se calcula a partir de un gráfico de flujos de control del método e indica lo siguiente: "complejidad ciclomática = número de bordes - número de nodos + 1", donde un nodo representa un punto de la rama de tipo lógico y un borde representa una línea entre los nodos.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityMessage">
        <source>'{0}' has a cyclomatic complexity of '{1}'. Rewrite or refactor the code to decrease its complexity below '{2}'.</source>
        <target state="translated">"{0}" tiene una complejidad ciclomática de "{1}". Escriba o refactorice el código para reducir su complejidad a continuación "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityTitle">
        <source>Avoid excessive complexity</source>
        <target state="translated">Evite la excesiva complejidad</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceDescription">
        <source>Deeply nested type hierarchies can be difficult to follow, understand, and maintain. This rule limits analysis to hierarchies in the same module. To fix a violation of this rule, derive the type from a base type that is less deep in the inheritance hierarchy or eliminate some of the intermediate base types.</source>
        <target state="translated">Las jerarquías de tipo profundamente anidado pueden ser difíciles de seguir, entender y mantener. Esta regla limita el análisis a las jerarquías en el mismo módulo. Para corregir una infracción de esta regla, derive el tipo de un tipo base que es menos profundo en la jerarquía de herencia o elimine algunos de los tipos base intermedios.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceMessage">
        <source>'{0}' has an object hierarchy '{1}' levels deep within the defining module. If possible, eliminate base classes within the hierarchy to decrease its hierarchy level below '{2}': '{3}'</source>
        <target state="translated">"{0}" tiene un nivel de jerarquía de objetos "{1}" en el interior del módulo de definición. Si es posible, elimine las clases base dentro de la jerarquía para disminuir su nivel de jerarquía por debajo de "{2}": "{3}"</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceTitle">
        <source>Avoid excessive inheritance</source>
        <target state="translated">Evite una herencia excesiva</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeDescription">
        <source>The maintainability index is calculated by using the following metrics: lines of code, program volume, and cyclomatic complexity. Program volume is a measure of the difficulty of understanding of a symbol that is based on the number of operators and operands in the code. Cyclomatic complexity is a measure of the structural complexity of the type or method. A low maintainability index indicates that code is probably difficult to maintain and would be a good candidate to redesign.</source>
        <target state="translated">El índice de mantenimiento se calcula con las métricas siguientes: líneas de código, volumen del programa y complejidad ciclomática. El volumen del programa es una medida de la dificultad para entender un símbolo que se basa en el número de operadores y de operandos en el código. La complejidad ciclomática es una medida de la complejidad estructural del tipo o método. Un índice de mantenimiento bajo indica que el código es probablemente difícil de mantener y sería un buen candidato para rediseñarlo.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeMessage">
        <source>'{0}' has a maintainability index of '{1}'. Rewrite or refactor the code to increase its maintainability index (MI) above '{2}'.</source>
        <target state="translated">"{0}" tiene un índice de mantenimiento de "{1}". Escriba o refactorice el código para aumentar su índice de mantenimiento sobre "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeTitle">
        <source>Avoid unmaintainable code</source>
        <target state="translated">Evite código que no se puede mantener</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileDescription">
        <source>Invalid entry in code metrics rule specification file</source>
        <target state="translated">Entrada no válida en el archivo de especificación de regla de métricas de código</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileMessage">
        <source>Invalid entry '{0}' in code metrics rule specification file '{1}'</source>
        <target state="translated">Entrada no válida "{0}" en el archivo de especificación de la regla de métricas de código "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileTitle">
        <source>Invalid entry in code metrics rule specification file</source>
        <target state="translated">Entrada no válida en el archivo de especificación de regla de métricas de código</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesTitle">
        <source>Variable names should not match field names</source>
        <target state="translated">Los nombres de las variables no deben coincidir con los nombres de los campos</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesDescription">
        <source>An instance method declares a parameter or a local variable whose name matches an instance field of the declaring type, leading to errors.</source>
        <target state="translated">Un método de instancia declara un parámetro o una variable local cuyo nombre coincide con un campo de instancia del tipo declarativo, lo que genera errores.</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesMessageLocal">
        <source>{0}, a variable declared in {1}, has the same name as an instance field on the type. Change the name of one of these items.</source>
        <target state="translated">{0}, una variable declarada en {1}, tiene el mismo nombre que un campo de instancia en el tipo. Cambie el nombre de uno de estos elementos.</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesMessageParameter">
        <source>{0}, a parameter declared in {1}, has the same name as an instance field on the type. Change the name of one of these items.</source>
        <target state="translated">{0}, un parámetro declarado en {1}, tiene el mismo nombre que un campo de instancia en el tipo. Cambie el nombre de uno de estos elementos.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewUnusedParametersTitle">
        <source>Review unused parameters</source>
        <target state="translated">Revisar parámetros sin utilizar</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewUnusedParametersDescription">
        <source>Avoid unused paramereters in your code. If the parameter cannot be removed, then change its name so it starts with an underscore and is optionally followed by an integer, such as '_', '_1', '_2', etc. These are treated as special discard symbol names.</source>
        <target state="needs-review-translation">Una signatura de método incluye un parámetro que no se usa en el cuerpo del método.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewUnusedParametersMessage">
        <source>Parameter {0} of method {1} is never used. Remove the parameter or use it in the method body.</source>
        <target state="translated">El parámetro {0} del método {1} no se usa nunca. Quite el parámetro o úselo en el cuerpo del método.</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveUnusedParameterMessage">
        <source>Remove unused parameter</source>
        <target state="translated">Quitar parámetro no utilizado</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsTitle">
        <source>Do not ignore method results</source>
        <target state="translated">No omitir resultados del método</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsDescription">
        <source>A new object is created but never used; or a method that creates and returns a new string is called and the new string is never used; or a COM or P/Invoke method returns an HRESULT or error code that is never used.</source>
        <target state="translated">Se crea un objeto pero no se usa nunca, se llama a un método que crea y devuelve una cadena nueva la cual no se usa nunca o bien un método P/Invoke o COM devuelve un código de error o HRESULT que no se usa nunca.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageObjectCreation">
        <source>{0} creates a new instance of {1} which is never used. Pass the instance as an argument to another method, assign the instance to a variable, or remove the object creation if it is unnecessary.</source>
        <target state="translated">{0} crea una instancia de {1} que no se usa nunca. Pase la instancia como argumento a otro método, asigne la instancia a una variable o quite la creación del objeto si no es necesaria.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageStringCreation">
        <source>{0} calls {1} but does not use the new string instance that the method returns. Pass the instance as an argument to another method, assign the instance to a variable, or remove the call if it is unnecessary.</source>
        <target state="translated">{0} llama a {1} pero no usa la nueva instancia de cadena que devuelve el método. Pase la instancia como argumento a otro método, asigne la instancia a una variable o quite la llamada si no es necesaria.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageHResultOrErrorCode">
        <source>{0} calls {1} but does not use the HRESULT or error code that the method returns. This could lead to unexpected behavior in error conditions or low-resource situations. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</source>
        <target state="translated">{0} llama a {1} pero no usa el código de error o HRESULT que devuelve el método. Esto puede dar lugar a un comportamiento inesperado en condiciones de error o situaciones de pocos recursos. Use el resultado en una instrucción condicional, asigne el resultado a una variable o páselo como argumento a otro método.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageTryParse">
        <source>{0} calls {1} but does not explicitly check whether the conversion succeeded. Either use the return value in a conditional statement or verify that the call site expects that the out argument will be set to the default value when the conversion fails.</source>
        <target state="translated">{0} llama a {1} pero no comprueba de forma explícita si la conversión se realizó correctamente. Use el valor devuelto en una instrucción condicional o compruebe que el sitio de la llamada espera que el argumento de salida se establezca en el valor predeterminado cuando la conversión no es correcta.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesTitle">
        <source>Avoid uninstantiated internal classes</source>
        <target state="translated">Evitar las clases internas sin instancia</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesDescription">
        <source>An instance of an assembly-level type is not created by code in the assembly.</source>
        <target state="translated">El código no crea ninguna instancia de un tipo de nivel de ensamblado en el ensamblado.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesMessage">
        <source>{0} is an internal class that is apparently never instantiated. If so, remove the code from the assembly. If this class is intended to contain only static members, make it static (Shared in Visual Basic).</source>
        <target state="translated">{0} es una clase interna de la que aparentemente nunca se crea una instancia. Si es así, quite el código del ensamblado. Si esta clase está destinada a contener solo miembros estáticos, conviértala en static (Shared en Visual Basic).</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsTitle">
        <source>Avoid unused private fields</source>
        <target state="translated">Evitar los campos privados sin utilizar</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsDescription">
        <source>Private fields were detected that do not appear to be accessed in the assembly.</source>
        <target state="translated">Se detectaron campos privados a los que no parece que se acceda en el ensamblado</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsMessage">
        <source>Unused field '{0}'.</source>
        <target state="translated">El campo “{0}” no se usa.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessagePureMethod">
        <source>{0} calls {1} but does not use the value the method returns. Because {1} is marked as a Pure method, it cannot have side effects. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</source>
        <target state="translated">{0} llama a {1} pero no usa el valor que el método devuelve. {1} se ha marcado como método Pure, por lo que no puede tener efectos secundarios. Use el resultado en una instrucción condicional, asigne el resultado a una variable o páselo como argumento a otro método.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringDescription">
        <source>Using nameof helps keep your code valid when refactoring.</source>
        <target state="translated">El uso de nameof ayuda a mantener el código válido durante la refactorización.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringMessage">
        <source>Use nameof in place of string literal '{0}'</source>
        <target state="translated">Use nameof en lugar del literal de cadena "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringTitle">
        <source>Use nameof to express symbol names</source>
        <target state="translated">Use nameof para expresar nombres de símbolos</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
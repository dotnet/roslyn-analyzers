<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ko" original="../MicrosoftMaintainabilityAnalyzersResources.resx">
    <body>
      <trans-unit id="AvoidExcessiveClassCouplingDescription">
        <source>This rule measures class coupling by counting the number of unique type references that a symbol contains. Symbols that have a high degree of class coupling can be difficult to maintain. It is a good practice to have types and methods that exhibit low coupling and high cohesion. To fix this violation, try to redesign the code to reduce the number of types to which it is coupled.</source>
        <target state="translated">이 규칙은 기호에 포함된 고유한 unique type references that a symbol contains. Symbols that have a high degree of class coupling can be difficult to maintain. It is a good practice to have types and methods that exhibit low coupling and high cohesion. To fix this violation, try to redesign the code to reduce the number of types to which it is coupled.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingMessage">
        <source>'{0}' is coupled with '{1}' different types from '{2}' different namespaces. Rewrite or refactor the code to decrease its class coupling below '{3}'.</source>
        <target state="translated">'{0}'이(가) '{2}'개의 다른 네임스페이스에 있는 '{1}'개의 다른 형식과 결합되어 있습니다. 코드를 다시 작성하거나 리팩터링하여 클래스 결합 수준을 '{3}' 이하로 낮추세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingTitle">
        <source>Avoid excessive class coupling</source>
        <target state="translated">클래스를 지나치게 많이 결합하지 마십시오.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityDescription">
        <source>Cyclomatic complexity measures the number of linearly independent paths through the method, which is determined by the number and complexity of conditional branches. A low cyclomatic complexity generally indicates a method that is easy to understand, test, and maintain. The cyclomatic complexity is calculated from a control flow graph of the method and is given as follows:

cyclomatic complexity = the number of edges - the number of nodes + 1

where a node represents a logic branch point and an edge represents a line between nodes.</source>
        <target state="translated">순환 복잡도는 메서드를 진행하며 따라가는 독립적인 경로의 개수를 계산하는데, 조건 분기의 개수와 복잡도에 의해 결정됩니다. 일반적으로 순환 복잡도가 낮으면 메서드를 이해하기 쉽고 테스트, 유지하기도 쉽습니다. 순환 복잡도는 메서드 제어 흐름 그래프를 보고 다음과 같이 계산합니다.

순환 복잡도 = 엣지 개수 - 노드 개수 + 1

여기에서 노드는 논리 분기점을 가리키고, 엣지는 노드와 노드 사이의 선을 가리킵니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityMessage">
        <source>'{0}' has a cyclomatic complexity of '{1}'. Rewrite or refactor the code to decrease its complexity below '{2}'.</source>
        <target state="translated">'{0}'의 순환 복잡성이 '{1}'입니다. 코드를 다시 작성하거나 리펙터링하여 복잡성을 '{2}' 이하로 줄이세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityTitle">
        <source>Avoid excessive complexity</source>
        <target state="translated">지나치게 복잡하게 만들지 마십시오.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceDescription">
        <source>Deeply nested type hierarchies can be difficult to follow, understand, and maintain. This rule limits analysis to hierarchies in the same module. To fix a violation of this rule, derive the type from a base type that is less deep in the inheritance hierarchy or eliminate some of the intermediate base types.</source>
        <target state="translated">계층 구조가 많이 중첩된 형식은 추적, 이해 및 유지 관리하기 어려울 수 있습니다. 이 규칙은 분석을 같은 모듈 내의 계층 구조로 제한합니다. 이 규칙의 위반을 해결하려면 상속 계층 구조에서 수준이 낮은 기본 형식에서 형식을 파생하거나 중간 기본 형식 중 일부를 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceMessage">
        <source>'{0}' has an object hierarchy '{1}' levels deep within the defining module. If possible, eliminate base classes within the hierarchy to decrease its hierarchy level below '{2}': '{3}'</source>
        <target state="translated">'{0}'의 개체 계층 구조 '{1}' 수준이 정의 모듈 내에서 깊습니다els deep within the defining module. If possible, eliminate base classes within the hierarchy to decrease its hierarchy level below '{2}': '{3}'</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceTitle">
        <source>Avoid excessive inheritance</source>
        <target state="translated">상속성을 너무 많이 사용하지 마십시오.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeDescription">
        <source>The maintainability index is calculated by using the following metrics: lines of code, program volume, and cyclomatic complexity. Program volume is a measure of the difficulty of understanding of a symbol that is based on the number of operators and operands in the code. Cyclomatic complexity is a measure of the structural complexity of the type or method.
A low maintainability index indicates that code is probably difficult to maintain and would be a good candidate to redesign.</source>
        <target state="translated">유지 관리 인덱스는 코드 줄, 프로그램 볼륨 및 순환 복잡성과 같은 메트릭을 사용하여 계산합니다. 프로그램 볼륨은 코드의 연산자 및 피연산자 수를 기준으로 기호 이해의 문제를 측정합니다. 순환 복잡성은 형식 또는 메서드의 구조 복잡성을 측정합니다.
유지 관리 인덱스가 낮으면 코드가 유지 관리하기 어려울 수 있고 다시 디자인하는 것이 좋습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeMessage">
        <source>'{0}' has a maintainability index of '{1}'. Rewrite or refactor the code to increase its maintainability index (MI) above '{2}'.</source>
        <target state="translated">'{0}'의 유지 관리 인덱스가 '{1}'입니다. 코드를 다시 작성하거나 리펙터링하여 MI(유지 관리 인덱스)를 '{2}' 이상으로 늘리세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeTitle">
        <source>Avoid unmaintainable code</source>
        <target state="translated">유지 관리할 수 없는 코드는 사용하지 마십시오.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileDescription">
        <source>Invalid entry in code metrics rule specification file</source>
        <target state="translated">코드 메트릭 규칙 사양 파일의 잘못된 항목</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileMessage">
        <source>Invalid entry '{0}' in code metrics rule specification file '{1}'</source>
        <target state="translated">코드 메트릭 규칙 사용 파일 '{1}'의 잘못된 항목 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileTitle">
        <source>Invalid entry in code metrics rule specification file</source>
        <target state="translated">코드 메트릭 규착 사양 파일의 잘못된 항목</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesTitle">
        <source>Variable names should not match field names</source>
        <target state="translated">변수 이름과 필드 이름이 일치하지 않아야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesDescription">
        <source>An instance method declares a parameter or a local variable whose name matches an instance field of the declaring type, leading to errors.</source>
        <target state="translated">인스턴스 메서드가 매개 변수 또는 지역 변수를 선언하며 지역 변수의 이름이 선언 형식의 인스턴스 필드와 일치하여 오류가 발생합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesMessageLocal">
        <source>{0}, a variable declared in {1}, has the same name as an instance field on the type. Change the name of one of these items.</source>
        <target state="translated">{1}에서 선언된 변수 {0}의 이름이 이 형식의 인스턴스 필드와 일치합니다. 이 항목 중 하나의 이름을 변경하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesMessageParameter">
        <source>{0}, a parameter declared in {1}, has the same name as an instance field on the type. Change the name of one of these items.</source>
        <target state="translated">{1}에서 선언된 매개 변수 {0}의 이름이 이 형식의 인스턴스 필드와 일치합니다. 이 항목 중 하나의 이름을 변경하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewUnusedParametersTitle">
        <source>Review unused parameters</source>
        <target state="translated">사용하지 않는 매개 변수를 검토하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewUnusedParametersDescription">
        <source>A method signature includes a parameter that is not used in the method body.</source>
        <target state="translated">메서드 시그니처가 메서드 본문에서 사용하지 않는 매개 변수를 포함합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewUnusedParametersMessage">
        <source>Parameter {0} of method {1} is never used. Remove the parameter or use it in the method body.</source>
        <target state="translated">{1} 메서드의 {0} 매개 변수가 사용되지 않았습니다. 매개 변수를 제거하거나 메서드 본문에 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveUnusedParameterMessage">
        <source>Remove unused parameter</source>
        <target state="translated">사용하지 않는 매개 변수를 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsTitle">
        <source>Do not ignore method results</source>
        <target state="translated">메서드 결과를 무시하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsDescription">
        <source>A new object is created but never used; or a method that creates and returns a new string is called and the new string is never used; or a COM or P/Invoke method returns an HRESULT or error code that is never used.</source>
        <target state="translated">새 개체가 만들어졌으나 사용되지 않았습니다. 또는 새 문자열을 만들고 반환한 메서드가 호출되었으며 새 문자열이 사용되지 않았습니다. 또는 COM 또는 P/Invoke가 사용되지 않는 HRESULT 또는 오류 코드를 반환합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageObjectCreation">
        <source>{0} creates a new instance of {1} which is never used. Pass the instance as an argument to another method, assign the instance to a variable, or remove the object creation if it is unnecessary.</source>
        <target state="translated">{0}이(가) 사용되지 않는 {1}의 새 인스턴스를 만듭니다. 인스턴스를 다른 메서드에 인수로 전달하고 변수에 할당하거나 불필요한 경우 개체 만들기를 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageStringCreation">
        <source>{0} calls {1} but does not use the new string instance that the method returns. Pass the instance as an argument to another method, assign the instance to a variable, or remove the call if it is unnecessary.</source>
        <target state="translated">{0}이(가) {1}을(를) 호출하지만 메서드가 반환하는 새 문자열 인스턴스를 사용하지 않습니다. 인스턴스를 다른 메서드에 인수로 전달하고 변수에 할당하거나 불필요한 경우 호출을 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageHResultOrErrorCode">
        <source>{0} calls {1} but does not use the HRESULT or error code that the method returns. This could lead to unexpected behavior in error conditions or low-resource situations. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</source>
        <target state="translated">{0}이(가) {1}을(를) 호출하지만 메서드가 반환하는 HRESULT 또는 오류 코드를 사용하지 않습니다. 이로 인해 오류 상태의 예기치 않은 동작이 발생하거나 리소스가 부족해질 수 있습니다. 결과를 조건문에 사용하거나 변수에 할당하거나 다른 메서드에 인수로 전달하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageTryParse">
        <source>{0} calls {1} but does not explicitly check whether the conversion succeeded. Either use the return value in a conditional statement or verify that the call site expects that the out argument will be set to the default value when the conversion fails.</source>
        <target state="translated">{0}이(가) {1}을(를) 호출하지만 변환 성공 여부를 명시적으로 검사하지 않습니다. 반환 값을 조건문에 사용하거나, 변환에 실패하면 out 인수가 기본값으로 설정되도록 호출 사이트가 지정되어 있는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesTitle">
        <source>Avoid uninstantiated internal classes</source>
        <target state="translated">인스턴스화되지 않는 내부 클래스를 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesDescription">
        <source>An instance of an assembly-level type is not created by code in the assembly.</source>
        <target state="translated">어셈블리 수준 형식의 인스턴스는 어셈블리 코드에서 만들어지지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesMessage">
        <source>{0} is an internal class that is apparently never instantiated. If so, remove the code from the assembly. If this class is intended to contain only static members, make it static (Shared in Visual Basic).</source>
        <target state="translated">{0}은(는) 인스턴스화되지 않는 내부 클래스입니다. 어셈블리에서 해당 코드를 제거하세요. 이 클래스가 정적 멤버만 포함하는 경우 static(Visual Basic의 경우 Shared)으로 설정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsTitle">
        <source>Avoid unused private fields</source>
        <target state="translated">사용하지 않는 전용 필드를 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsDescription">
        <source>Private fields were detected that do not appear to be accessed in the assembly.</source>
        <target state="translated">어셈블리 내부에서 액세스되지 않는 전용 필드가 발견되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsMessage">
        <source>Unused field '{0}'.</source>
        <target state="translated">사용하지 않는 필드 '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessagePureMethod">
        <source>{0} calls {1} but does not use the value the method returns. Because {1} is marked as a Pure method, it cannot have side effects. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</source>
        <target state="translated">{0}이(가) {1}을(를) 호출하지만 메서드가 반환하는 값을 사용하지 않습니다. {1}이(가) 순수 메서드로 표시되어 있으므로 의도하지 않은 결과가 발생하지 않습니다. 결과를 조건문에 사용하거나 변수에 할당하거나 다른 메서드에 인수로 전달하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringDescription">
        <source>Using nameof helps keep your code valid when refactoring.</source>
        <target state="translated">nameof를 사용하면 리팩터링 시 코드를 유효하게 유지할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringMessage">
        <source>Use nameof in place of string literal '{0}'</source>
        <target state="translated">문자열 리터럴 '{0}' 대신 nameof 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringTitle">
        <source>Use nameof to express symbol names</source>
        <target state="translated">기호 이름을 표시하기 위해 nameof 사용</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
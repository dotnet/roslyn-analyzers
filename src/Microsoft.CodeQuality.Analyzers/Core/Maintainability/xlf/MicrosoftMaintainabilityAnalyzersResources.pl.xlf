<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="pl" original="../MicrosoftMaintainabilityAnalyzersResources.resx">
    <body>
      <trans-unit id="AvoidDeadConditionalCodeAlwaysTruFalseOrNullMessage">
        <source>'{0}' is always '{1}'. Remove or refactor the condition(s) to avoid dead code.</source>
        <target state="translated">Element „{0}” ma zawsze wartość „{1}”. Usuń lub zrefaktoryzuj warunki w celu uniknięcia nieaktywnego kodu.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDeadConditionalCodeNeverNullMessage">
        <source>'{0}' is never '{1}'. Remove or refactor the condition(s) to avoid dead code.</source>
        <target state="translated">Element „{0}” nigdy nie ma wartości „{1}”. Usuń lub zrefaktoryzuj warunki w celu uniknięcia nieaktywnego kodu.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDeadConditionalCodeTitle">
        <source>Avoid dead conditional code</source>
        <target state="translated">Unikaj nieaktywnego kodu warunkowego</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingDescription">
        <source>This rule measures class coupling by counting the number of unique type references that a symbol contains. Symbols that have a high degree of class coupling can be difficult to maintain. It is a good practice to have types and methods that exhibit low coupling and high cohesion. To fix this violation, try to redesign the code to reduce the number of types to which it is coupled.</source>
        <target state="translated">Ta reguła mierzy sprzężenie klas, licząc liczbę unikatowych odwołań do typów, które zawiera symbol. Symbole o wysokim stopniu sprzężenia klas mogą być trudne w utrzymaniu. Dobrym rozwiązaniem jest tworzenie typów i metod o niskim sprzężeniu i wysokiej spójności. Aby naprawić to naruszenie, przeprojektuj kod w celu zmniejszenia liczby typów, z którymi jest sprzężony.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingMessage">
        <source>'{0}' is coupled with '{1}' different types from '{2}' different namespaces. Rewrite or refactor the code to decrease its class coupling below '{3}'.</source>
        <target state="translated">Element „{0}” jest sprzężony z „{1}” różnymi typami z „{2}” różnych przestrzeni nazw. Ponownie napisz kod lub refaktoryzuj go w taki sposób, aby sprzężenie klas było niższe niż „{3}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingTitle">
        <source>Avoid excessive class coupling</source>
        <target state="translated">Unikaj nadmiernego sprzężenia klas</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityDescription">
        <source>Cyclomatic complexity measures the number of linearly independent paths through the method, which is determined by the number and complexity of conditional branches. A low cyclomatic complexity generally indicates a method that is easy to understand, test, and maintain. The cyclomatic complexity is calculated from a control flow graph of the method and is given as follows: `cyclomatic complexity = the number of edges - the number of nodes + 1`, where a node represents a logic branch point and an edge represents a line between nodes.</source>
        <target state="translated">Złożoność cyklomatyczna mierzy liczbę liniowo niezależnych ścieżek prowadzących przez metodę, która jest określana przez liczbę i złożoność gałęzi warunkowych. Niska złożoność cyklomatyczna zwykle wskazuje metodę, którą łatwo zrozumieć, testować i utrzymywać. Złożoność cyklomatyczna jest obliczana na podstawie grafu przepływu sterowania metody i podawana w następujący sposób: złożoność cyklomatyczna = liczba granic - liczba węzłów + 1, gdzie węzeł reprezentuje rozgałęzienie logiki, a granica — linię między węzłami.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityMessage">
        <source>'{0}' has a cyclomatic complexity of '{1}'. Rewrite or refactor the code to decrease its complexity below '{2}'.</source>
        <target state="translated">Element „{0}” ma złożoność cyklomatyczną wynoszącą „{1}”. Ponownie napisz kod lub refaktoryzuj go w taki sposób, aby złożoność była niższa niż „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityTitle">
        <source>Avoid excessive complexity</source>
        <target state="translated">Unikaj nadmiernej złożoności</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceDescription">
        <source>Deeply nested type hierarchies can be difficult to follow, understand, and maintain. This rule limits analysis to hierarchies in the same module. To fix a violation of this rule, derive the type from a base type that is less deep in the inheritance hierarchy or eliminate some of the intermediate base types.</source>
        <target state="translated">Głęboko zagnieżdżone hierarchie typów mogą być trudne w zrozumieniu i utrzymaniu. Ta reguła ogranicza analizę do hierarchii w tym samym module. Aby naprawić naruszenie tej reguły, utwórz typ jako pochodny typu podstawowego o mniejszej głębokości w hierarchii dziedziczenia lub wyeliminuj niektóre pośrednie typy podstawowe.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceMessage">
        <source>'{0}' has an object hierarchy '{1}' levels deep within the defining module. If possible, eliminate base classes within the hierarchy to decrease its hierarchy level below '{2}': '{3}'</source>
        <target state="translated">Element „{0}” ma w definiującym module hierarchię obiektów o następującej liczbie poziomów głębokości: „{1}”. Jeśli to możliwe, wyeliminuj klasy podstawowe z hierarchii, aby obniżyć poziom hierarchii poniżej „{2}”: „{3}”</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceTitle">
        <source>Avoid excessive inheritance</source>
        <target state="translated">Unikaj nadmiernego dziedziczenia</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeDescription">
        <source>The maintainability index is calculated by using the following metrics: lines of code, program volume, and cyclomatic complexity. Program volume is a measure of the difficulty of understanding of a symbol that is based on the number of operators and operands in the code. Cyclomatic complexity is a measure of the structural complexity of the type or method. A low maintainability index indicates that code is probably difficult to maintain and would be a good candidate to redesign.</source>
        <target state="translated">Indeks dostępności jest obliczany przy użyciu następujących metryk: wiersze kodu, ilość programu i złożoność cyklomatyczna. Ilość programu to miara trudności w zrozumieniu symbolu oparta na liczbie operatorów i operandów w kodzie. Złożoność cyklomatyczna to miara złożoności strukturalnej typu lub metody. Niski indeks dostępności wskazuje kod, który jest prawdopodobnie trudny w konserwacji. Byłby to dobry kandydat do przeprojektowania.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeMessage">
        <source>'{0}' has a maintainability index of '{1}'. Rewrite or refactor the code to increase its maintainability index (MI) above '{2}'.</source>
        <target state="translated">Element „{0}” ma indeks dostępności „{1}”. Ponownie napisz kod lub refaktoryzuj go w taki sposób, aby indeks dostępności był wyższy niż „{2}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeTitle">
        <source>Avoid unmaintainable code</source>
        <target state="translated">Unikaj kodu trudnego w utrzymaniu</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileDescription">
        <source>Invalid entry in code metrics rule specification file</source>
        <target state="translated">Nieprawidłowy wpis w pliku specyfikacji reguły metryk kodu</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileMessage">
        <source>Invalid entry '{0}' in code metrics rule specification file '{1}'</source>
        <target state="translated">Nieprawidłowy wpis „{0}” w pliku specyfikacji reguły metryk kodu „{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileTitle">
        <source>Invalid entry in code metrics rule specification file</source>
        <target state="translated">Nieprawidłowy wpis w pliku specyfikacji reguły metryk kodu</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesTitle">
        <source>Variable names should not match field names</source>
        <target state="translated">Nazwy zmiennych nie powinny być zgodne z nazwami pól</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesDescription">
        <source>An instance method declares a parameter or a local variable whose name matches an instance field of the declaring type, leading to errors.</source>
        <target state="translated">Metoda wystąpienia deklaruje parametr lub zmienną lokalną, której nazwa jest zgodna z polem wystąpienia deklarującego typu, co prowadzi do błędów.</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesMessageLocal">
        <source>{0}, a variable declared in {1}, has the same name as an instance field on the type. Change the name of one of these items.</source>
        <target state="translated">{0}, zmienna zadeklarowana w elemencie {1}, ma taką samą nazwę jak pole wystąpienia dla typu. Zmień nazwę jednego z tych elementów.</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesMessageParameter">
        <source>{0}, a parameter declared in {1}, has the same name as an instance field on the type. Change the name of one of these items.</source>
        <target state="translated">{0}, parametr zadeklarowany w elemencie {1}, ma taką samą nazwę jak pole wystąpienia dla typu. Zmień nazwę jednego z tych elementów.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewUnusedParametersTitle">
        <source>Review unused parameters</source>
        <target state="translated">Sprawdź nieużywane parametry</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewUnusedParametersDescription">
        <source>A method signature includes a parameter that is not used in the method body.</source>
        <target state="translated">Sygnatura metody zawiera parametr, który nie jest używany w treści metody.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewUnusedParametersMessage">
        <source>Parameter {0} of method {1} is never used. Remove the parameter or use it in the method body.</source>
        <target state="translated">Parametr {0} metody {1} nie jest nigdy używany. Usuń parametr lub użyj go w treści metody.</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveUnusedParameterMessage">
        <source>Remove unused parameter</source>
        <target state="translated">Usuń nieużywany parametr</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsTitle">
        <source>Do not ignore method results</source>
        <target state="translated">Nie ignoruj wyników metody</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsDescription">
        <source>A new object is created but never used; or a method that creates and returns a new string is called and the new string is never used; or a COM or P/Invoke method returns an HRESULT or error code that is never used.</source>
        <target state="translated">Nowy obiekt został utworzony, ale nigdy nie został użyty, została wywołana metoda tworząca i zwracająca nowy ciąg, a nowy ciąg nigdy nie został użyty lub metoda COM albo P/Invoke zwraca wartość HRESULT lub kod błędu, który nigdy nie został użyty.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageObjectCreation">
        <source>{0} creates a new instance of {1} which is never used. Pass the instance as an argument to another method, assign the instance to a variable, or remove the object creation if it is unnecessary.</source>
        <target state="translated">Element {0} tworzy nowe wystąpienie elementu {1}, które nigdy nie zostało użyte. Przekaż wystąpienie jako argument do innej metody, przypisz wystąpienie do zmiennej lub usuń tworzenie obiektu, jeśli jest zbędne.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageStringCreation">
        <source>{0} calls {1} but does not use the new string instance that the method returns. Pass the instance as an argument to another method, assign the instance to a variable, or remove the call if it is unnecessary.</source>
        <target state="translated">Element {0} wywołuje element {1}, ale nie używa wystąpienia nowego ciągu zwracanego przez metodę. Przekaż wystąpienie jako argument do innej metody, przypisz wystąpienie do zmiennej lub usuń wywołanie, jeśli jest zbędne.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageHResultOrErrorCode">
        <source>{0} calls {1} but does not use the HRESULT or error code that the method returns. This could lead to unexpected behavior in error conditions or low-resource situations. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</source>
        <target state="translated">Element {0} wywołuje element {1}, ale nie używa wartości HRESULT ani kodu błędu zwracanego przez metodę. Może to doprowadzić do nieoczekiwanego zachowania w warunkach błędu lub sytuacjach małej ilości zasobów. Użyj wyniku w instrukcji warunkowej, przypisz wynik do zmiennej lub przekaż go jako argument do innej metody.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageTryParse">
        <source>{0} calls {1} but does not explicitly check whether the conversion succeeded. Either use the return value in a conditional statement or verify that the call site expects that the out argument will be set to the default value when the conversion fails.</source>
        <target state="translated">Element {0} wywołuje element {1}, ale nie sprawdza jawnie, czy konwersja się udała. Użyj wartości zwracanej w instrukcji warunkowej lub zweryfikuj, czy lokacja wywołania oczekuje, że argument wychodzący zostanie ustawiony na wartość domyślną w razie niepowodzenia konwersji.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesTitle">
        <source>Avoid uninstantiated internal classes</source>
        <target state="translated">Unikaj klas wewnętrznych bez wystąpień</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesDescription">
        <source>An instance of an assembly-level type is not created by code in the assembly.</source>
        <target state="translated">Wystąpienie typu na poziomie zestawu nie zostało utworzone przez kod w zestawie.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesMessage">
        <source>{0} is an internal class that is apparently never instantiated. If so, remove the code from the assembly. If this class is intended to contain only static members, make it static (Shared in Visual Basic).</source>
        <target state="translated">Element {0} jest klasą wewnętrzną, która najwyraźniej nigdy nie miała wystąpień. Jeśli tak, usuń kod z zestawu. Jeśli ta klasa w założeniu ma zawierać tylko statyczne składowe, zmień ją na statyczną (udostępnianą w języku Visual Basic).</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsTitle">
        <source>Avoid unused private fields</source>
        <target state="translated">Unikaj nieużywanych pól prywatnych</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsDescription">
        <source>Private fields were detected that do not appear to be accessed in the assembly.</source>
        <target state="translated">Zostały wykryte pola prywatne, dostęp do których prawdopodobnie nie będzie występował w zestawie.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsMessage">
        <source>Unused field '{0}'.</source>
        <target state="translated">Nieużywane pole „{0}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessagePureMethod">
        <source>{0} calls {1} but does not use the value the method returns. Because {1} is marked as a Pure method, it cannot have side effects. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</source>
        <target state="translated">Element {0} wywołuje element {1}, ale nie używa wartości zwracanej przez metodę. Ponieważ metoda {1} jest oznaczona jako metoda Pure, nie może ona mieć efektów ubocznych. Użyj wyniku w instrukcji warunkowej, przypisz wynik do zmiennej lub przekaż go jako argument do innej metody.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringDescription">
        <source>Using nameof helps keep your code valid when refactoring.</source>
        <target state="translated">Korzystanie z operatora pomaga zachować poprawność kodu przy refaktoryzacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringMessage">
        <source>Use nameof in place of string literal '{0}'</source>
        <target state="translated">Użyj operatora nameof zamiast literału ciągu „{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringTitle">
        <source>Use nameof to express symbol names</source>
        <target state="translated">Używaj operatora nameof, aby wyrażać nazwy symboli</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
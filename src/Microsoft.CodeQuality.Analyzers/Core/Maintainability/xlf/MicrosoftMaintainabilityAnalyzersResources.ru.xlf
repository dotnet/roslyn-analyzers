<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ru" original="../MicrosoftMaintainabilityAnalyzersResources.resx">
    <body>
      <trans-unit id="AvoidDeadConditionalCodeAlwaysTruFalseOrNullMessage">
        <source>'{0}' is always '{1}'. Remove or refactor the condition(s) to avoid dead code.</source>
        <target state="translated">"{0}" всегда является "{1}". Удалите эти условия или выполните их рефакторинг, чтобы избежать появления неиспользуемого кода.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDeadConditionalCodeNeverNullMessage">
        <source>'{0}' is never '{1}'. Remove or refactor the condition(s) to avoid dead code.</source>
        <target state="translated">"{0}" никогда не является "{1}". Удалите эти условия или выполните их рефакторинг, чтобы избежать появления неиспользуемого кода.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDeadConditionalCodeTitle">
        <source>Avoid dead conditional code</source>
        <target state="translated">Предотвращение появления неиспользуемого условного кода</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingDescription">
        <source>This rule measures class coupling by counting the number of unique type references that a symbol contains. Symbols that have a high degree of class coupling can be difficult to maintain. It is a good practice to have types and methods that exhibit low coupling and high cohesion. To fix this violation, try to redesign the code to reduce the number of types to which it is coupled.</source>
        <target state="translated">Это правило измеряет взаимозависимость классов посредством подсчета количества уникальных ссылок на типы, которые содержат символ. Символы, которые имеют высокую степень взаимозависимости классов, может быть трудно поддерживать. Рекомендуется иметь типы и методы, которые обладают низкой взаимозависимостью и высокой связностью. Чтобы устранить это нарушение, попробуйте реорганизовать код, чтобы уменьшить число типов, которые участвуют в формировании взаимозависимости.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingMessage">
        <source>'{0}' is coupled with '{1}' different types from '{2}' different namespaces. Rewrite or refactor the code to decrease its class coupling below '{3}'.</source>
        <target state="translated">'{0}' связан с различными типами ('{1}') из различных пространств имен ('{2}'). Перепишите или оптимизируйте код, чтобы уменьшить степень взаимозависимости классов ниже '{3}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingTitle">
        <source>Avoid excessive class coupling</source>
        <target state="translated">Избегать чрезмерной взаимозависимости классов</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityDescription">
        <source>Cyclomatic complexity measures the number of linearly independent paths through the method, which is determined by the number and complexity of conditional branches. A low cyclomatic complexity generally indicates a method that is easy to understand, test, and maintain. The cyclomatic complexity is calculated from a control flow graph of the method and is given as follows: `cyclomatic complexity = the number of edges - the number of nodes + 1`, where a node represents a logic branch point and an edge represents a line between nodes.</source>
        <target state="translated">Цикломатическая сложность измеряет число линейно-независимых путей через метод, что определяется числом и сложностью условных ветвлений. Низкая цикломатическая сложность обычно указывает на метод, который легко понять, тестировать и обслуживать. Цикломатическая сложность вычисляется по графу потока управления по следующей формуле: "цикломатическая сложность = число краев – число узлов + 1", где узел представляет логическую точку ветвления, а край — линию между узлами.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityMessage">
        <source>'{0}' has a cyclomatic complexity of '{1}'. Rewrite or refactor the code to decrease its complexity below '{2}'.</source>
        <target state="translated">'{0}' имеет цикломатическую сложность '{1}'. Перепишите или оптимизируйте код, чтобы уменьшить его сложность ниже '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityTitle">
        <source>Avoid excessive complexity</source>
        <target state="translated">Избегать чрезмерной сложности</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceDescription">
        <source>Deeply nested type hierarchies can be difficult to follow, understand, and maintain. This rule limits analysis to hierarchies in the same module. To fix a violation of this rule, derive the type from a base type that is less deep in the inheritance hierarchy or eliminate some of the intermediate base types.</source>
        <target state="translated">Иерархии типов с высоким уровнем вложенности могут представлять сложности в понимании и поддержке. Это правило ограничивает анализ, включая в него только иерархии в том же модуле. Чтобы устранить нарушение этого правила, определите производный тип из базового типа с более низким уровнем вложенности в иерархии наследования или исключите некоторые из промежуточных базовых типов.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceMessage">
        <source>'{0}' has an object hierarchy '{1}' levels deep within the defining module. If possible, eliminate base classes within the hierarchy to decrease its hierarchy level below '{2}': '{3}'</source>
        <target state="translated">'{0}' имеет уровень вложенности иерархии '{1}' в определяющем модуле. Если возможно, исключите базовые классы из иерархии, чтобы уменьшить уровень вложенности иерархии ниже '{2}': '{3}'</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceTitle">
        <source>Avoid excessive inheritance</source>
        <target state="translated">Избегать чрезмерного наследования</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeDescription">
        <source>The maintainability index is calculated by using the following metrics: lines of code, program volume, and cyclomatic complexity. Program volume is a measure of the difficulty of understanding of a symbol that is based on the number of operators and operands in the code. Cyclomatic complexity is a measure of the structural complexity of the type or method. A low maintainability index indicates that code is probably difficult to maintain and would be a good candidate to redesign.</source>
        <target state="translated">Индекс удобства поддержки вычисляется с помощью следующих метрик: строк кода, объема программы и цикломатической сложности. Объем программы — это мера сложности понимания символа, основанная на количестве операторов и операндов в коде. Цикломатическая сложность — это мера структурной сложности типа или метода. Низкий индекс удобства поддержки означает, что код, скорее всего, сложно обслуживать, поэтому следует рассмотреть возможность его переработки.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeMessage">
        <source>'{0}' has a maintainability index of '{1}'. Rewrite or refactor the code to increase its maintainability index (MI) above '{2}'.</source>
        <target state="translated">'{0}' имеет индекс удобства поддержки '{1}'. Перепишите или оптимизируйте код, чтобы уменьшить индекс удобства поддержки ниже '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeTitle">
        <source>Avoid unmaintainable code</source>
        <target state="translated">Разрешить неподдерживаемый код</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileDescription">
        <source>Invalid entry in code metrics rule specification file</source>
        <target state="translated">Недопустимая запись в файле спецификации правила метрик кода</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileMessage">
        <source>Invalid entry '{0}' in code metrics rule specification file '{1}'</source>
        <target state="translated">Недопустимая запись '{0}' в файле спецификации правила метрик кода '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileTitle">
        <source>Invalid entry in code metrics rule specification file</source>
        <target state="translated">Недопустимая запись в файле спецификации правила метрик кода</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesTitle">
        <source>Variable names should not match field names</source>
        <target state="translated">Имена переменных не должны совпадать с именами полей</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesDescription">
        <source>An instance method declares a parameter or a local variable whose name matches an instance field of the declaring type, leading to errors.</source>
        <target state="translated">Метод экземпляра объявляет параметр или локальную переменную с именем, которое соответствует полю экземпляра объявляющего типа, что ведет к ошибкам.</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesMessageLocal">
        <source>{0}, a variable declared in {1}, has the same name as an instance field on the type. Change the name of one of these items.</source>
        <target state="translated">Переменная {0}, объявленная в {1}, и поле экземпляра типа имеют одно и то же имя. Измените имя одного из этих элементов.</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesMessageParameter">
        <source>{0}, a parameter declared in {1}, has the same name as an instance field on the type. Change the name of one of these items.</source>
        <target state="translated">Параметр {0}, объявленный в {1}, и поле экземпляра типа имеют одно и то же имя. Измените имя одного из этих элементов.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewUnusedParametersTitle">
        <source>Review unused parameters</source>
        <target state="translated">Проверьте неиспользуемые параметры</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewUnusedParametersDescription">
        <source>A method signature includes a parameter that is not used in the method body.</source>
        <target state="translated">Сигнатура метода содержит параметр, который не используется в теле метода.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewUnusedParametersMessage">
        <source>Parameter {0} of method {1} is never used. Remove the parameter or use it in the method body.</source>
        <target state="translated">Параметр {0} метода {1} не используется. Удалите этот параметр или используйте его в теле метода.</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveUnusedParameterMessage">
        <source>Remove unused parameter</source>
        <target state="translated">Удалите неиспользуемый параметр</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsTitle">
        <source>Do not ignore method results</source>
        <target state="translated">Не игнорируйте результаты метода</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsDescription">
        <source>A new object is created but never used; or a method that creates and returns a new string is called and the new string is never used; or a COM or P/Invoke method returns an HRESULT or error code that is never used.</source>
        <target state="translated">Созданный объект не используется, вызван метод, создающий и возвращающий строку, которая не используется, либо метод COM или P/Invoke возвращает результат HRESULT или код ошибки, который не используется.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageObjectCreation">
        <source>{0} creates a new instance of {1} which is never used. Pass the instance as an argument to another method, assign the instance to a variable, or remove the object creation if it is unnecessary.</source>
        <target state="translated">{0} создает экземпляр {1}, который не используется. Передайте этот экземпляр в качестве аргумента другому методу, присвойте экземпляр переменной, или удалите создание объекта, если он не нужен.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageStringCreation">
        <source>{0} calls {1} but does not use the new string instance that the method returns. Pass the instance as an argument to another method, assign the instance to a variable, or remove the call if it is unnecessary.</source>
        <target state="translated">{0} вызывает {1}, но не использует новый экземпляр строки, возвращаемый методом. Передайте этот экземпляр в качестве аргумента другому методу, присвойте экземпляр переменной или удалите вызов, если он не нужен.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageHResultOrErrorCode">
        <source>{0} calls {1} but does not use the HRESULT or error code that the method returns. This could lead to unexpected behavior in error conditions or low-resource situations. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</source>
        <target state="translated">{0} вызывает {1}, но не использует HRESULT или код ошибки, возвращаемые методом. Это может привести к непредвиденному поведению при возникновении ошибок или нехватке ресурсов. Используйте результат в условном операторе, присвойте его переменной или передайте его в качестве аргумента другому методу.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageTryParse">
        <source>{0} calls {1} but does not explicitly check whether the conversion succeeded. Either use the return value in a conditional statement or verify that the call site expects that the out argument will be set to the default value when the conversion fails.</source>
        <target state="translated">{0} вызывает {1}, но явно не проверяет успешность преобразования. Либо используйте возвращаемое значение в условном операторе, либо проверьте, что источник вызова предполагает, что при ошибке преобразования для аргумента out будет установлено значение по умолчанию.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesTitle">
        <source>Avoid uninstantiated internal classes</source>
        <target state="translated">Избегайте внутренних классов, не имеющих экземпляры</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesDescription">
        <source>An instance of an assembly-level type is not created by code in the assembly.</source>
        <target state="translated">В этой сборке код не создает экземпляр типа на уровне сборки.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesMessage">
        <source>{0} is an internal class that is apparently never instantiated. If so, remove the code from the assembly. If this class is intended to contain only static members, make it static (Shared in Visual Basic).</source>
        <target state="translated">{0} является внутренним классом, экземпляр которого никогда не создается. Если это так, удалите код из сборки. Если этот класс должен содержать только статические методы, сделайте его статическим (Shared в Visual Basic).</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsTitle">
        <source>Avoid unused private fields</source>
        <target state="translated">Избегайте неиспользуемых частных полей</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsDescription">
        <source>Private fields were detected that do not appear to be accessed in the assembly.</source>
        <target state="translated">В сборке обнаружены частные поля, к которым не осуществляется доступ.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsMessage">
        <source>Unused field '{0}'.</source>
        <target state="translated">Неиспользуемое поле "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessagePureMethod">
        <source>{0} calls {1} but does not use the value the method returns. Because {1} is marked as a Pure method, it cannot have side effects. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</source>
        <target state="translated">{0} вызывает {1}, но не использует значение, возвращаемое методом. Так как {1} помечен как метод Pure, он не может иметь побочные эффекты. Используйте результат в условном операторе, присвойте его переменной или передайте его в качестве аргумента другому методу.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringDescription">
        <source>Using nameof helps keep your code valid when refactoring.</source>
        <target state="translated">Использование nameof позволяет обеспечить работоспособность кода при рефакторинге.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringMessage">
        <source>Use nameof in place of string literal '{0}'</source>
        <target state="translated">Используйте nameof вместо строкового литерала "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringTitle">
        <source>Use nameof to express symbol names</source>
        <target state="translated">Используйте nameof для выражения имен символов</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
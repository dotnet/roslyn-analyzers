<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="tr" original="../MicrosoftMaintainabilityAnalyzersResources.resx">
    <body>
      <trans-unit id="AvoidExcessiveClassCouplingDescription">
        <source>This rule measures class coupling by counting the number of unique type references that a symbol contains. Symbols that have a high degree of class coupling can be difficult to maintain. It is a good practice to have types and methods that exhibit low coupling and high cohesion. To fix this violation, try to redesign the code to reduce the number of types to which it is coupled.</source>
        <target state="translated">Bu kural, bir sembolün içerdiği benzersiz tür başvurularını sayarak sınıf bağlantılarını ölçer. Yüksek düzeyde sınıf bağlantısı içeren sembollerin bakımının yapılması zor olabilir. Düşük bağlantı düzeyine ve yüksek uyuma sahip türler ve metotlar kullanılması iyi bir uygulamadır. Bu ihlali düzeltmek için kodu yeniden tasarlayarak kodun bağlı olduğu tür sayısını azaltmayı deneyin.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingMessage">
        <source>'{0}' is coupled with '{1}' different types from '{2}' different namespaces. Rewrite or refactor the code to decrease its class coupling below '{3}'.</source>
        <target state="translated">'{0}', '{2}' farklı ad alanından '{1}' farklı türe bağlı. Kodu yeniden yazarak veya yeniden düzenleyerek sınıf bağlantısını '{3}' düzeyinin altına düşürün.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveClassCouplingTitle">
        <source>Avoid excessive class coupling</source>
        <target state="translated">Aşırı miktarda sınıf bağlantısından kaçının</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityDescription">
        <source>Cyclomatic complexity measures the number of linearly independent paths through the method, which is determined by the number and complexity of conditional branches. A low cyclomatic complexity generally indicates a method that is easy to understand, test, and maintain. The cyclomatic complexity is calculated from a control flow graph of the method and is given as follows:

cyclomatic complexity = the number of edges - the number of nodes + 1

where a node represents a logic branch point and an edge represents a line between nodes.</source>
        <target state="translated">Döngüsel karmaşıklık, metot aracılığıyla oluşturulmuş, doğrusal olarak bağımsız yol sayısını ölçer ve bu sayı, koşullu dalların sayısı ve karmaşıklığına göre belirlenir. Döngüsel karmaşıklığın düşük olması genellikle metodu anlamanın, test etmenin ve metoda bakım uygulamanın kolay olduğu anlamına gelir. Döngüsel karmaşıklık, metodun denetim akışı grafiğinden hesaplanır ve aşağıdaki formülle elde edilir:

döngüsel karmaşıklık = uç sayısı - düğüm sayısı + 1

burada her düğüm bir mantık dalı noktasını temsil ederken, her uç düğümler arası bir hattı temsil eder.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityMessage">
        <source>'{0}' has a cyclomatic complexity of '{1}'. Rewrite or refactor the code to decrease its complexity below '{2}'.</source>
        <target state="translated">'{0}', '{1}' düzeyinde döngüsel karmaşıklığa sahip. Kodu yeniden yazarak veya yeniden düzenleyerek karmaşıklığı '{2}' düzeyinin altına düşürün.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveComplexityTitle">
        <source>Avoid excessive complexity</source>
        <target state="translated">Aşırı karmaşıklıktan kaçının</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceDescription">
        <source>Deeply nested type hierarchies can be difficult to follow, understand, and maintain. This rule limits analysis to hierarchies in the same module. To fix a violation of this rule, derive the type from a base type that is less deep in the inheritance hierarchy or eliminate some of the intermediate base types.</source>
        <target state="translated">Çok fazla iç içe girmiş tür hiyerarşileri izlemeyi, anlamayı ve bakım yapmayı zorlaştırabilir. Bu kural, analizi aynı modül içindeki hiyerarşilerle sınırlı tutar. Bu kuralın ihlal edildiği bir durumu düzeltmek için türü devralınan hiyerarşiden daha az iç içe geçmiş bir hiyerarşiden alın veya ara taban türlerin bir kısmını kaldırın.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceMessage">
        <source>'{0}' has an object hierarchy '{1}' levels deep within the defining module. If possible, eliminate base classes within the hierarchy to decrease its hierarchy level below '{2}': '{3}'</source>
        <target state="translated">'{0}', tanımlama modülü içinde '{1}' düzey derinliğinde bir nesne hiyerarşisine sahip. Mümkünse hiyerarşideki temel sınıfları ortadan kaldırarak hiyerarşi düzeyini '{2}': '{3}' seviyesinin altına düşürün</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidExcessiveInheritanceTitle">
        <source>Avoid excessive inheritance</source>
        <target state="translated">Aşırı devralmadan kaçının</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeDescription">
        <source>The maintainability index is calculated by using the following metrics: lines of code, program volume, and cyclomatic complexity. Program volume is a measure of the difficulty of understanding of a symbol that is based on the number of operators and operands in the code. Cyclomatic complexity is a measure of the structural complexity of the type or method.
A low maintainability index indicates that code is probably difficult to maintain and would be a good candidate to redesign.</source>
        <target state="translated">Bakım endeksi şu ölçümler kullanılarak hesaplanır: kod satırı sayısı, program hacmi ve döngüsel karmaşıklık. Program hacmi, koddaki işleçler ve işlenenlerden yola çıkılarak bir sembolün anlaşılmasının ne kadar zor olduğunu gösteren bir ölçüdür. Döngüsel karmaşıklık, tür veya metodun yapısal karmaşıklığını gösteren bir ölçüdür.
Bakım endeksinin düşük olması, koda bakım uygulamanın zor olabileceğini ve kodun yeniden tasarlanmasının uygun olduğunu gösterir.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeMessage">
        <source>'{0}' has a maintainability index of '{1}'. Rewrite or refactor the code to increase its maintainability index (MI) above '{2}'.</source>
        <target state="translated">'{0}' öğesinin bakım endeksi '{1}'. Kodu yeniden yazarak veya yeniden düzenleyerek bakım endeksini (MI) '{2}' düzeyinin üstüne çıkarın.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnmantainableCodeTitle">
        <source>Avoid unmaintainable code</source>
        <target state="translated">Avoid unmaintainable code</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileDescription">
        <source>Invalid entry in code metrics rule specification file</source>
        <target state="translated">Kod ölçümleri kural belirtimi dosyasında geçersiz giriş</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileMessage">
        <source>Invalid entry '{0}' in code metrics rule specification file '{1}'</source>
        <target state="translated">'{1}' adlı kod ölçümleri kural belirtimi dosyasındaki '{0}' girişi geçersiz</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidEntryInCodeMetricsConfigFileTitle">
        <source>Invalid entry in code metrics rule specification file</source>
        <target state="translated">Ölçüm kuralı belirtim dosyasında geçersiz giriş</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesTitle">
        <source>Variable names should not match field names</source>
        <target state="translated">Değişken adları alan adlarıyla eşleşmemelidir</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesDescription">
        <source>An instance method declares a parameter or a local variable whose name matches an instance field of the declaring type, leading to errors.</source>
        <target state="translated">Bir örnek yöntemi, adı bildiren türün bir örnek alanıyla eşleşen bir parametre veya yerel değişken bildirerek hatalara neden oluyor.</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesMessageLocal">
        <source>{0}, a variable declared in {1}, has the same name as an instance field on the type. Change the name of one of these items.</source>
        <target state="translated">{0} {1} içinde tanımlanmış bir değişkendir ve tür üzerindeki bir örnek alanıyla aynı ada sahiptir. Bu öğelerden birinin adını değiştirin.</target>
        <note />
      </trans-unit>
      <trans-unit id="VariableNamesShouldNotMatchFieldNamesMessageParameter">
        <source>{0}, a parameter declared in {1}, has the same name as an instance field on the type. Change the name of one of these items.</source>
        <target state="translated">{0} {1} içinde tanımlanmış bir parametredir ve tür üzerindeki bir örnek alanıyla aynı ada sahiptir. Bu öğelerden birinin adını değiştirin.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewUnusedParametersTitle">
        <source>Review unused parameters</source>
        <target state="translated">Kullanılmayan parametreleri gözden geçirin</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewUnusedParametersDescription">
        <source>A method signature includes a parameter that is not used in the method body.</source>
        <target state="translated">Yöntem imzası yöntem gövdesinde kullanılmayan bir parametre içeriyor.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewUnusedParametersMessage">
        <source>Parameter {0} of method {1} is never used. Remove the parameter or use it in the method body.</source>
        <target state="translated">{1} yönteminin {0} parametresi hiçbir zaman kullanılmıyor. Parametreyi kaldırın veya yöntem gövdesinde kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveUnusedParameterMessage">
        <source>Remove unused parameter</source>
        <target state="translated">Kullanılmayan parametreyi kaldırma</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsTitle">
        <source>Do not ignore method results</source>
        <target state="translated">Yöntem sonuçlarını yoksaymayın</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsDescription">
        <source>A new object is created but never used; or a method that creates and returns a new string is called and the new string is never used; or a COM or P/Invoke method returns an HRESULT or error code that is never used.</source>
        <target state="translated">Yeni bir nesne oluşturulur ancak hiçbir zaman kullanılmaz; veya yeni bir dize oluşturup döndüren bir yöntem çağrılır ve yeni dize hiçbir zaman kullanılmaz; veya bir COM ya da P/Invoke yöntemi hiçbir zaman kullanılmayan bir HRESULT veya hata kodu döndürür.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageObjectCreation">
        <source>{0} creates a new instance of {1} which is never used. Pass the instance as an argument to another method, assign the instance to a variable, or remove the object creation if it is unnecessary.</source>
        <target state="translated">{0} hiçbir zaman kullanılmayan yeni bir {1} örneği oluşturuyor. Örneği bir bağımsız değişken olarak başka yönteme geçirin, örneği bir değişkene atayın ya da gereksizse nesne oluşturmayı kaldırın.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageStringCreation">
        <source>{0} calls {1} but does not use the new string instance that the method returns. Pass the instance as an argument to another method, assign the instance to a variable, or remove the call if it is unnecessary.</source>
        <target state="translated">{0}, {1} çağırıyor ancak yöntemin döndürdüğü yeni dize örneğini kullanmıyor. Örneği bir bağımsız değişken olarak başka yönteme geçirin, örneği bir değişkene atayın ya da gereksizse çağrıyı kaldırın.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageHResultOrErrorCode">
        <source>{0} calls {1} but does not use the HRESULT or error code that the method returns. This could lead to unexpected behavior in error conditions or low-resource situations. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</source>
        <target state="translated">{0}, {1} çağırıyor ancak yöntemin döndürdüğü HRESULT veya hata kodunu kullanmıyor. Bu, hata koşullarında ya da düşük kaynak durumlarında beklenmedik davranışlara neden olabilir. Bir koşullu ifadedeki sonucu kullanın, sonucu bir değişkene atayın veya bir bağımsız değişken olarak başka bir yönteme geçirin.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessageTryParse">
        <source>{0} calls {1} but does not explicitly check whether the conversion succeeded. Either use the return value in a conditional statement or verify that the call site expects that the out argument will be set to the default value when the conversion fails.</source>
        <target state="translated">{0}, {1} çağırıyor ancak dönüşümün başarılı olup olmadığını açıkça denetlemiyor. Dönüş değerini koşullu bir ifadede kullanın veya çağırma sitesinin çıkış değerinin dönüşüm başarısız olduğunda varsayılan değere ayarlanmasını beklediğini doğrulayın.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesTitle">
        <source>Avoid uninstantiated internal classes</source>
        <target state="translated">Örneklendirilmemiş iç sınıflardan kaçının</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesDescription">
        <source>An instance of an assembly-level type is not created by code in the assembly.</source>
        <target state="translated">Derleme düzeyi bir türün örneği derlemede kod tarafından oluşturulmaz.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUninstantiatedInternalClassesMessage">
        <source>{0} is an internal class that is apparently never instantiated. If so, remove the code from the assembly. If this class is intended to contain only static members, make it static (Shared in Visual Basic).</source>
        <target state="translated">{0} hiç örneklenmemiş gibi görünen bir iç sınıftır. Öyleyse, kodu derlemeden kaldırın. Bu sınıfın yalnızca statik üyeler içermesi gerekiyorsa, statik yapın (Visual Basic’te Shared).</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsTitle">
        <source>Avoid unused private fields</source>
        <target state="translated">Kullanılmayan özel alanlardan kaçının</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsDescription">
        <source>Private fields were detected that do not appear to be accessed in the assembly.</source>
        <target state="translated">Derleme içerisinde erişilmeyen özel alanlar algılandı.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnusedPrivateFieldsMessage">
        <source>Unused field '{0}'.</source>
        <target state="translated">Kullanılmayan alan '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreMethodResultsMessagePureMethod">
        <source>{0} calls {1} but does not use the value the method returns. Because {1} is marked as a Pure method, it cannot have side effects. Use the result in a conditional statement, assign the result to a variable, or pass it as an argument to another method.</source>
        <target state="translated">{0} {1} çağırıyor ancak yöntemin döndürdüğü değeri kullanmıyor. {1} Saf yöntem olarak işaretlendiğinden yan etkilere sahip olamaz. Bir koşullu ifadedeki sonucu kullanın, sonucu bir değişkene atayın veya bir bağımsız değişken olarak başka bir yönteme geçirin.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringDescription">
        <source>Using nameof helps keep your code valid when refactoring.</source>
        <target state="translated">Nameof kullanmak yeniden düzenlerken kodunuzun geçerli kalmasına yardımcı olur.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringMessage">
        <source>Use nameof in place of string literal '{0}'</source>
        <target state="translated">Dize sabiti '{0}' yerine nameof kullanın</target>
        <note />
      </trans-unit>
      <trans-unit id="UseNameOfInPlaceOfStringTitle">
        <source>Use nameof to express symbol names</source>
        <target state="translated">Sembol adlarını ifade etmek için nameof kullanın</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
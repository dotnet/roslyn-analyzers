<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="UseLiteralsWhereAppropriateTitle" xml:space="preserve">
    <value>Use literals where appropriate</value>
  </data>
  <data name="UseLiteralsWhereAppropriateDescription" xml:space="preserve">
    <value>A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized by using a value that is computable at compile time. Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic) field so that the value is computed at compile time instead of at run?time.</value>
  </data>
  <data name="UseLiteralsWhereAppropriateMessageDefault" xml:space="preserve">
    <value>Field '{0}' is declared as 'static readonly' but is initialized with a constant value. Mark this field as 'const' instead.</value>
  </data>
  <data name="UseLiteralsWhereAppropriateMessageEmptyString" xml:space="preserve">
    <value>Field '{0}' is declared as 'static readonly' but is initialized with an empty string (""). Mark this field as 'const' instead.</value>
  </data>
  <data name="DoNotInitializeUnnecessarilyTitle" xml:space="preserve">
    <value>Do not initialize unnecessarily</value>
  </data>
  <data name="DoNotInitializeUnnecessarilyDescription" xml:space="preserve">
    <value>The common language runtime initializes all fields to their default values before running the constructor. In most cases, initializing a field to its default value in a constructor is redundant, which degrades performance and adds to maintenance costs. One case where it is not redundant occurs when the constructor calls another constructor of the same class or a base class constructor and that constructor initializes the field to a non-default value. In this case, changing the value of the field back to its default value can be appropriate.</value>
  </data>
  <data name="DoNotInitializeUnnecessarilyMessage" xml:space="preserve">
    <value>Do not initialize unnecessarily</value>
  </data>
  <data name="PreferJaggedArraysOverMultidimensionalTitle" xml:space="preserve">
    <value>Prefer jagged arrays over multidimensional</value>
  </data>
  <data name="PreferJaggedArraysOverMultidimensionalDescription" xml:space="preserve">
    <value>A jagged array is an array whose elements are arrays. The arrays that make up the elements can be of different sizes, leading to less wasted space for some sets of data.</value>
  </data>
  <data name="PreferJaggedArraysOverMultidimensionalMessageDefault" xml:space="preserve">
    <value>{0} is a multidimensional array. Replace it with a jagged array if possible.</value>
  </data>
  <data name="PreferJaggedArraysOverMultidimensionalMessageReturn" xml:space="preserve">
    <value>{0} returns a multidimensional array of {1}. Replace it with a jagged array if possible.</value>
  </data>
  <data name="PreferJaggedArraysOverMultidimensionalMessageBody" xml:space="preserve">
    <value>{0} uses a multidimensional array of {1}. Replace it with a jagged array if possible.</value>
  </data>
  <data name="MarkMembersAsStaticTitle" xml:space="preserve">
    <value>Mark members as static</value>
  </data>
  <data name="MarkMembersAsStaticDescription" xml:space="preserve">
    <value>Members that do not access instance data or call instance methods can be marked as static (Shared in Visual Basic). After you mark the methods as static, the compiler will emit nonvirtual call sites to these members. This can give you a measurable performance gain for performance-sensitive code.</value>
  </data>
  <data name="MarkMembersAsStaticMessage" xml:space="preserve">
    <value>Member {0} does not access instance data and can be marked as static (Shared in VisualBasic)</value>
  </data>
  <data name="ReviewVisibleEventHandlersTitle" xml:space="preserve">
    <value>Review visible event handlers</value>
  </data>
  <data name="ReviewVisibleEventHandlersDescription" xml:space="preserve">
    <value>A public or protected event-handling method was detected. Event-handling methods should not be exposed unless absolutely necessary.</value>
  </data>
  <data name="ReviewVisibleEventHandlersMessageSecurity" xml:space="preserve">
    <value>Consider making {0} not externally visible or ensure that it is benign code.</value>
  </data>
  <data name="ReviewVisibleEventHandlersMessageDefault" xml:space="preserve">
    <value>Consider making {0} not externally visible.</value>
  </data>
  <data name="SealMethodsThatSatisfyPrivateInterfacesTitle" xml:space="preserve">
    <value>Seal methods that satisfy private interfaces</value>
  </data>
  <data name="SealMethodsThatSatisfyPrivateInterfacesDescription" xml:space="preserve">
    <value>An inheritable public type provides an overridable method implementation of an internal (Friend in Visual Basic) interface. To fix a violation of this rule, prevent the method from being overridden outside the assembly.</value>
  </data>
  <data name="SealMethodsThatSatisfyPrivateInterfacesMessage" xml:space="preserve">
    <value>Seal methods that satisfy private interfaces</value>
  </data>
  <data name="RemoveEmptyFinalizers" xml:space="preserve">
    <value>Remove empty Finalizers</value>
  </data>
  <data name="RemoveEmptyFinalizersDescription" xml:space="preserve">
    <value>Finalizers should be avoided where possible, to avoid the additional performance overhead involved in tracking object lifetime.</value>
  </data>
  <data name="DoNotCallOverridableMethodsInConstructors" xml:space="preserve">
    <value>Do not call overridable methods in constructors</value>
  </data>
  <data name="DoNotCallOverridableMethodsInConstructorsDescription" xml:space="preserve">
    <value>Virtual methods defined on the class should not be called from constructors. If a derived class has overridden the method, the derived class version will be called (before the derived class constructor is called).</value>
  </data>
  <data name="RethrowToPreserveStackDetailsMessage" xml:space="preserve">
    <value>Re-throwing caught exception changes stack information.</value>
  </data>
  <data name="RethrowToPreserveStackDetailsTitle" xml:space="preserve">
    <value>Rethrow to preserve stack details.</value>
  </data>
  <data name="MakeDeclaringTypeInternal" xml:space="preserve">
    <value>Make declaring type internal.</value>
  </data>
  <data name="MakeDeclaringTypeSealed" xml:space="preserve">
    <value>Make declaring type sealed.</value>
  </data>
  <data name="MakeMemberNotOverridable" xml:space="preserve">
    <value>Make member not overridable.</value>
  </data>
  <data name="DoNotRaiseExceptionsInExceptionClausesDescription" xml:space="preserve">
    <value>When an exception is raised in a finally clause, the new exception hides the active exception. This makes the original error difficult to detect and debug.</value>
  </data>
  <data name="DoNotRaiseExceptionsInExceptionClausesMessageFinally" xml:space="preserve">
    <value>Do not raise an exception from within a finally clause. </value>
  </data>
  <data name="DoNotRaiseExceptionsInExceptionClausesTitle" xml:space="preserve">
    <value>Do not raise exceptions in finally clauses</value>
  </data>
  <data name="UseLiteralsWhereAppropriateCodeActionTitle" xml:space="preserve">
    <value>Change to constant</value>
  </data>
  <data name="AvoidDuplicateElementInitializationDescription" xml:space="preserve">
    <value>Indexed elements in objects initializers must initialize unique elements. A duplicate index might overwrite a previous element initialization.</value>
  </data>
  <data name="AvoidDuplicateElementInitializationMessage" xml:space="preserve">
    <value>The element at index [{0}] has already been initialized. Previous initializations of this element may be overwritten.</value>
  </data>
  <data name="AvoidDuplicateElementInitializationTitle" xml:space="preserve">
    <value>Do not duplicate indexed element initializations</value>
  </data>
  <data name="ValidateArgumentsOfPublicMethodsDescription" xml:space="preserve">
    <value>An externally visible method dereferences one of its reference arguments without verifying whether that argument is null (Nothing in Visual Basic). All reference arguments that are passed to externally visible methods should be checked against null. If appropriate, throw an ArgumentNullException when the argument is null or add a Code Contract precondition asserting non-null argument. If the method is designed to be called only by known assemblies, you should make the method internal.</value>
  </data>
  <data name="ValidateArgumentsOfPublicMethodsMessage" xml:space="preserve">
    <value>In externally visible method '{0}', validate parameter '{1}' is non-null before using it. If appropriate, throw an ArgumentNullException when the argument is null or add a Code Contract precondition asserting non-null argument.</value>
  </data>
  <data name="ValidateArgumentsOfPublicMethodsTitle" xml:space="preserve">
    <value>Validate arguments of public methods</value>
  </data>
  <data name="MarkMembersAsStaticCodeFix" xml:space="preserve">
    <value>Make static</value>
  </data>
  <data name="MarkMembersAsStaticCodeFix_WarningAnnotation" xml:space="preserve">
    <value>Some references to '{0}' could not be fixed, they should be fixed manually.</value>
  </data>
  <data name="AvoidPropertySelfAssignmentTitle" xml:space="preserve">
    <value>Do not assign a property to itself.</value>
  </data>
  <data name="AvoidPropertySelfAssignmentMessage" xml:space="preserve">
    <value>The property {0} should not be assigned to itself.</value>
  </data>
  <data name="ReferencingAndReassigningObjectInSameStatementMessage" xml:space="preserve">
    <value>Object '{0}' is referenced and reassigned in the same statement. You are at risk of referring to unintended object.</value>
  </data>
  <data name="ReferencingAndReassigningObjectInSameStatementTitle" xml:space="preserve">
    <value>Referring to object and reassigning it in the same statement.</value>
  </data>
  <data name="ReferencingAndReassigningObjectInSameStatementDescription" xml:space="preserve">
    <value>When you go through the assignment chain right to left, firstly, reference in object '{0}' will be changed, but when you reffer to this object second time, since it's still the same statement, it will be pointing to it's old value. So if old value of '{0}' isn't saved elsewhere, result of the latter assignment will be lost.</value>
  </data>
</root>
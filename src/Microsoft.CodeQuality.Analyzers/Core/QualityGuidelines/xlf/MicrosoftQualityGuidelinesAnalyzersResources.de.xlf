<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="de" original="../MicrosoftQualityGuidelinesAnalyzersResources.resx">
    <body>
      <trans-unit id="AvoidPropertySelfAssignmentMessage">
        <source>The property {0} should not be assigned to itself.</source>
        <target state="translated">Die Eigenschaft "{0}" darf nicht sich selbst zugewiesen werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidPropertySelfAssignmentTitle">
        <source>Do not assign a property to itself.</source>
        <target state="translated">Weisen Sie eine Eigenschaft nicht sich selbst zu.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticCodeFix">
        <source>Make static</source>
        <target state="translated">Als statisch festlegen</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticCodeFix_WarningAnnotation">
        <source>Some references to '{0}' could not be fixed, they should be fixed manually.</source>
        <target state="translated">Einige Verweise auf "{0}" konnten nicht korrigiert werden. Korrigieren Sie sie manuell.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferringToObjectAndReassigningItInTheSameStatementDescription">
        <source>When you go through the assignment chain right to left, firstly, reference in object '{0}' will be changed, but when you reffer to this object second time, since it's still the same statement, it will be pointing to it's old value. So if old value of '{0}' isn't saved elsewhere, result of the later assignment will be lost.</source>
        <target state="new">When you go through the assignment chain right to left, firstly, reference in object '{0}' will be changed, but when you reffer to this object second time, since it's still the same statement, it will be pointing to it's old value. So if old value of '{0}' isn't saved elsewhere, result of the later assignment will be lost.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferringToObjectAndReassigningItInTheSameStatementMessage">
        <source>Object '{0}' is referenced and reassigned in the same statement. You are at risk of referring to unintended object.</source>
        <target state="new">Object '{0}' is referenced and reassigned in the same statement. You are at risk of referring to unintended object.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferringToObjectAndReassigningItInTheSameStatementTitle">
        <source>Referring to object and reassigning it in the same statement.</source>
        <target state="new">Referring to object and reassigning it in the same statement.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateTitle">
        <source>Use literals where appropriate</source>
        <target state="translated">Nach Möglichkeit Literale verwenden</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateDescription">
        <source>A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized by using a value that is computable at compile time. Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic) field so that the value is computed at compile time instead of at run?time.</source>
        <target state="translated">Ein Feld wird als "static" und "read-only" ("Shared" und "ReadOnly" in Visual Basic) deklariert und anhand eines Werts initialisiert, der zur Kompilierzeit berechnet werden kann. Da der dem Zielfeld zugewiesene Wert zur Kompilierzeit berechnet werden kann, ändern Sie die Deklaration in ein const-Feld (Const in Visual Basic), sodass der Wert statt zur Laufzeit zur Kompilierzeit berechnet wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateMessageDefault">
        <source>Field '{0}' is declared as 'static readonly' but is initialized with a constant value. Mark this field as 'const' instead.</source>
        <target state="translated">Das Feld "{0}" wird als "static readonly" deklariert, wird jedoch mit einem konstanten Wert initialisiert. Markieren Sie dieses Feld stattdessen als "const".</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateMessageEmptyString">
        <source>Field '{0}' is declared as 'static readonly' but is initialized with an empty string (""). Mark this field as 'const' instead.</source>
        <target state="translated">Das Feld "{0}" wird als "static readonly" deklariert, wird jedoch mit einer leeren Zeichenfolge ("") initialisiert. Markieren Sie dieses Feld stattdessen als "const".</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyTitle">
        <source>Do not initialize unnecessarily</source>
        <target state="translated">Keine unnötige Initialisierung</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyDescription">
        <source>The common language runtime initializes all fields to their default values before running the constructor. In most cases, initializing a field to its default value in a constructor is redundant, which degrades performance and adds to maintenance costs. One case where it is not redundant occurs when the constructor calls another constructor of the same class or a base class constructor and that constructor initializes the field to a non-default value. In this case, changing the value of the field back to its default value can be appropriate.</source>
        <target state="translated">Die Common Language Runtime initialisiert alle Felder mit ihren Standardwerten, bevor der Konstruktor ausgeführt wird. In den meisten Fällen ist das Initialisieren eines Felds mit seinem Standardwert redundant und führt zu einer Leistungsminderung und zusätzlichen Wartungskosten. Ein Fall, in dem es nicht redundant ist, tritt ein, wenn der Konstruktor einen anderen Konstruktor derselben Klasse oder einen Basisklassenkonstruktor aufruft und wenn dieser Konstruktor das Feld mit einem anderen als dem Standardwert initialisiert. In diesem Fall kann das Ändern des Feldwerts auf den Standardwert sinnvoll sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyMessage">
        <source>Do not initialize unnecessarily</source>
        <target state="translated">Keine unnötige Initialisierung</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalTitle">
        <source>Prefer jagged arrays over multidimensional</source>
        <target state="translated">Jagged Arrays mehrdimensionalen Arrays vorziehen</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalDescription">
        <source>A jagged array is an array whose elements are arrays. The arrays that make up the elements can be of different sizes, leading to less wasted space for some sets of data.</source>
        <target state="translated">Ein Jagged Array ist ein Array, dessen Elemente ebenfalls Arrays sind. Diese Arrayelemente können verschiedene Größen aufweisen, sodass für einige Datenmengen weniger Platz vergeudet wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageDefault">
        <source>{0} is a multidimensional array. Replace it with a jagged array if possible.</source>
        <target state="translated">"{0}" ist ein mehrdimensionales Array. Ersetzen Sie es nach Möglichkeit durch ein Jagged Array.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageReturn">
        <source>{0} returns a multidimensional array of {1}. Replace it with a jagged array if possible.</source>
        <target state="translated">"{0}" gibt ein mehrdimensionales Array von "{1}" zurück. Ersetzen Sie es nach Möglichkeit durch ein Jagged Array.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageBody">
        <source>{0} uses a multidimensional array of {1}. Replace it with a jagged array if possible.</source>
        <target state="translated">"{0}" verwendet ein mehrdimensionales Array von "{1}". Ersetzen Sie es nach Möglichkeit durch ein Jagged Array.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticTitle">
        <source>Mark members as static</source>
        <target state="translated">Member als statisch markieren</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticDescription">
        <source>Members that do not access instance data or call instance methods can be marked as static (Shared in Visual Basic). After you mark the methods as static, the compiler will emit nonvirtual call sites to these members. This can give you a measurable performance gain for performance-sensitive code.</source>
        <target state="translated">Member, die nicht auf Instanzdaten zugreifen oder Instanzmethoden aufrufen, können als "static" markiert werden ("Shared" in Visual Basic). Nachdem Sie die Methoden als statisch markiert haben, gibt der Compiler nicht virtuelle Aufrufsites an diese Member aus. Dadurch kann sich für leistungsabhängigen Code eine spürbare Leistungssteigerung ergeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticMessage">
        <source>Member {0} does not access instance data and can be marked as static (Shared in VisualBasic)</source>
        <target state="translated">Der Member "{0}" greift nicht auf Instanzdaten zu und kann als "static" markiert werden ("Shared" in VisualBasic).</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersTitle">
        <source>Review visible event handlers</source>
        <target state="translated">Sichtbare Ereignishandler überprüfen</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersDescription">
        <source>A public or protected event-handling method was detected. Event-handling methods should not be exposed unless absolutely necessary.</source>
        <target state="translated">Es wurde eine öffentliche oder geschützte Methode zum Ereignishandling ermittelt. Methoden zum Ereignishandling dürfen nur verfügbar gemacht werden, wenn es absolut erforderlich ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersMessageSecurity">
        <source>Consider making {0} not externally visible or ensure that it is benign code.</source>
        <target state="translated">Ziehen Sie in Betracht, "{0}" nicht extern sichtbar zu machen, oder stellen Sie sicher, dass es sich um gutartigen Code handelt.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersMessageDefault">
        <source>Consider making {0} not externally visible.</source>
        <target state="translated">Ziehen Sie in Betracht, "{0}" nicht extern sichtbar zu machen.</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesTitle">
        <source>Seal methods that satisfy private interfaces</source>
        <target state="translated">Methoden versiegeln, die die Bedingungen privater Schnittstellen erfüllen</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesDescription">
        <source>An inheritable public type provides an overridable method implementation of an internal (Friend in Visual Basic) interface. To fix a violation of this rule, prevent the method from being overridden outside the assembly.</source>
        <target state="translated">Ein vererbbarer öffentlicher Typ stellt eine überschreibbare Methodenimplementierung einer internal-Schnittstelle bereit ("Friend" in Visual Basic). Um einen Verstoß gegen diese Regel zu korrigieren, verhindern Sie ein Außerkraftsetzen der Methode außerhalb der Assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesMessage">
        <source>Seal methods that satisfy private interfaces</source>
        <target state="translated">Methoden versiegeln, die die Bedingungen privater Schnittstellen erfüllen</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveEmptyFinalizers">
        <source>Remove empty Finalizers</source>
        <target state="translated">Leere Finalizer entfernen</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveEmptyFinalizersDescription">
        <source>Finalizers should be avoided where possible, to avoid the additional performance overhead involved in tracking object lifetime.</source>
        <target state="translated">Finalizer sollten nach Möglichkeit vermieden werden, um den zusätzlichen Leistungsaufwand zum Nachverfolgen der Objektlebensdauer zu vermeiden.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructors">
        <source>Do not call overridable methods in constructors</source>
        <target state="translated">Überschreibbare Methoden in Konstruktoren nicht aufrufen</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructorsDescription">
        <source>Virtual methods defined on the class should not be called from constructors. If a derived class has overridden the method, the derived class version will be called (before the derived class constructor is called).</source>
        <target state="translated">Für die Klasse definierte virtuelle Methoden dürfen von Konstruktoren nicht aufgerufen werden. Wenn die Methode durch eine abgeleitete Klasse außer Kraft gesetzt wurde, wird die abgeleitete Klassenversion aufgerufen (bevor der Konstruktor der abgeleiteten Klasse aufgerufen wird).</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsMessage">
        <source>Re-throwing caught exception changes stack information.</source>
        <target state="translated">Durch ein erneutes Auslösen einer abgefangenen Ausnahme werden die Stapelinformationen geändert.</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsTitle">
        <source>Rethrow to preserve stack details.</source>
        <target state="translated">Erneut ausführen, um Stapeldetails beizubehalten</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeDeclaringTypeInternal">
        <source>Make declaring type internal.</source>
        <target state="translated">Legen Sie den deklarierenden Typ als intern fest.</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeDeclaringTypeSealed">
        <source>Make declaring type sealed.</source>
        <target state="translated">Legen Sie den deklarierenden Typ als versiegelt fest.</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeMemberNotOverridable">
        <source>Make member not overridable.</source>
        <target state="translated">Legen Sie den Member als nicht überschreibbar fest.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesDescription">
        <source>When an exception is raised in a finally clause, the new exception hides the active exception. This makes the original error difficult to detect and debug.</source>
        <target state="translated">Wenn eine Ausnahme in einer finally-Klausel ausgelöst wird, wird die aktive Ausnahme durch die neue Ausnahme verborgen. Dadurch ist der ursprüngliche Fehler schwierig zu erkennen und zu debuggen.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesMessageFinally">
        <source>Do not raise an exception from within a finally clause. </source>
        <target state="translated">Lösen Sie keine Ausnahme innerhalb einer finally-Klausel aus. </target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesTitle">
        <source>Do not raise exceptions in finally clauses</source>
        <target state="translated">Keine Ausnahmen in finally-Klauseln auslösen</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateCodeActionTitle">
        <source>Change to constant</source>
        <target state="translated">In Konstante ändern</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationDescription">
        <source>Indexed elements in objects initializers must initialize unique elements. A duplicate index might overwrite a previous element initialization.</source>
        <target state="translated">Indizierte Elemente in Objektinitialisierern müssen eindeutige Elemente initialisieren. Durch einen doppelten Index kann eine vorherige Elementinitialisierung überschrieben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationMessage">
        <source>The element at index [{0}] has already been initialized. Previous initializations of this element may be overwritten.</source>
        <target state="translated">Das Element bei Index [{0}] wurde bereits initialisiert. Vorherige Initialisierungen dieses Elements werden möglicherweise überschrieben.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationTitle">
        <source>Do not duplicate indexed element initializations</source>
        <target state="translated">Keine Initialisierungen indizierter Elemente duplizieren</target>
        <note />
      </trans-unit>
      <trans-unit id="ValidateArgumentsOfPublicMethodsDescription">
        <source>An externally visible method dereferences one of its reference arguments without verifying whether that argument is null (Nothing in Visual Basic). All reference arguments that are passed to externally visible methods should be checked against null. If appropriate, throw an ArgumentNullException when the argument is null or add a Code Contract precondition asserting non-null argument. If the method is designed to be called only by known assemblies, you should make the method internal.</source>
        <target state="translated">Eine extern sichtbare Methode dereferenziert eines der zugehörigen Verweisargumente, ohne dass geprüft wird, ob das Argument NULL ist ("Nothing" in Visual Basic). Alle Verweisargumente, die an extern sichtbare Methoden übergeben werden, müssen auf NULL überprüft werden. Lösen Sie gegebenenfalls eine ArgumentNullException aus, wenn das Argument NULL ist, oder fügen Sie eine Codevertragsvorbedingung hinzu, die ein Nicht-NULL-Argument durchsetzt. Wenn die Methode darauf ausgelegt ist, nur von bekannten Assemblys aufgerufen zu werden, müssen Sie die Methode als intern festlegen.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValidateArgumentsOfPublicMethodsMessage">
        <source>In externally visible method '{0}', validate parameter '{1}' is non-null before using it. If appropriate, throw an ArgumentNullException when the argument is null or add a Code Contract precondition asserting non-null argument.</source>
        <target state="translated">Überprüfen Sie in der extern sichtbaren Methode "{0}", dass der Parameter "{1}" ungleich NULL ist, bevor Sie ihn verwenden. Lösen Sie gegebenenfalls eine ArgumentNullException aus, wenn das Argument NULL ist, oder fügen Sie eine Codevertragsvorbedingung hinzu, die ein Nicht-NULL-Argument durchsetzt.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValidateArgumentsOfPublicMethodsTitle">
        <source>Validate arguments of public methods</source>
        <target state="translated">Argumente von öffentlichen Methoden validieren</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
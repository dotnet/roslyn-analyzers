<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="fr" original="../MicrosoftQualityGuidelinesAnalyzersResources.resx">
    <body>
      <trans-unit id="AvoidPropertySelfAssignmentMessage">
        <source>The property {0} should not be assigned to itself.</source>
        <target state="new">The property {0} should not be assigned to itself.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidPropertySelfAssignmentTitle">
        <source>Do not assign a property to itself.</source>
        <target state="new">Do not assign a property to itself.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticCodeFix">
        <source>Make static</source>
        <target state="translated">Rendre statique</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticCodeFix_WarningAnnotation">
        <source>Some references to '{0}' could not be fixed, they should be fixed manually.</source>
        <target state="translated">Des références à '{0}' n'ont pas pu être corrigées, elles doivent être corrigées manuellement.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateTitle">
        <source>Use literals where appropriate</source>
        <target state="translated">Utiliser des littéraux quand cela est approprié</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateDescription">
        <source>A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized by using a value that is computable at compile time. Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic) field so that the value is computed at compile time instead of at run?time.</source>
        <target state="translated">Un champ est déclaré comme étant static et en lecture seule (Shared et ReadOnly en Visual Basic), et est initialisé à l'aide d'une valeur calculable au moment de la compilation. Dans la mesure où la valeur assignée au champ ciblé est calculable au moment de la compilation, changez la déclaration en la remplaçant par un champ const (Const en Visual Basic) pour que la valeur soit calculée au moment de la compilation et non au moment de l'exécution.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateMessageDefault">
        <source>Field '{0}' is declared as 'static readonly' but is initialized with a constant value. Mark this field as 'const' instead.</source>
        <target state="translated">Le champ '{0}' est déclaré comme étant 'static readonly' mais il est initialisé avec une valeur de constante. À la place, marquez ce champ comme étant un champ 'const'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateMessageEmptyString">
        <source>Field '{0}' is declared as 'static readonly' but is initialized with an empty string (""). Mark this field as 'const' instead.</source>
        <target state="translated">Le champ '{0}' est déclaré comme étant 'static readonly' mais il est initialisé avec une chaîne vide (""). À la place, marquez ce champ comme étant un champ 'const'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyTitle">
        <source>Do not initialize unnecessarily</source>
        <target state="translated">Ne pas effectuer d'initialisation inutilement</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyDescription">
        <source>The common language runtime initializes all fields to their default values before running the constructor. In most cases, initializing a field to its default value in a constructor is redundant, which degrades performance and adds to maintenance costs. One case where it is not redundant occurs when the constructor calls another constructor of the same class or a base class constructor and that constructor initializes the field to a non-default value. In this case, changing the value of the field back to its default value can be appropriate.</source>
        <target state="translated">Le Common Language Runtime initialise tous les champs en fonction de leurs valeurs par défaut avant d'exécuter le constructeur. Dans la plupart des cas, l'initialisation d'un champ en fonction de sa valeur par défaut dans un constructeur est redondante, ce qui entraîne une dégradation des performances et une augmentation des coûts de maintenance. Il n'existe pas de redondance quand le constructeur appelle un autre constructeur de même classe ou un constructeur de classe de base, et que le constructeur initialise le champ en fonction d'une autre valeur que la valeur par défaut. Dans ce cas, il peut s'avérer approprié de changer la valeur du champ en le remplaçant par sa valeur par défaut.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyMessage">
        <source>Do not initialize unnecessarily</source>
        <target state="translated">Ne pas effectuer d'initialisation inutilement</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalTitle">
        <source>Prefer jagged arrays over multidimensional</source>
        <target state="translated">Préférer les tableaux en escalier aux tableaux multidimensionnels</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalDescription">
        <source>A jagged array is an array whose elements are arrays. The arrays that make up the elements can be of different sizes, leading to less wasted space for some sets of data.</source>
        <target state="translated">Un tableau en escalier est un tableau dont les éléments sont des tableaux. Les tableaux qui composent les éléments peuvent être de tailles distinctes, ce qui réduit l'espace perdu pour certains jeux de données.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageDefault">
        <source>{0} is a multidimensional array. Replace it with a jagged array if possible.</source>
        <target state="translated">{0} est un tableau multidimensionnel. Remplacez-le, si possible, par un tableau en escalier.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageReturn">
        <source>{0} returns a multidimensional array of {1}. Replace it with a jagged array if possible.</source>
        <target state="translated">{0} retourne un tableau multidimensionnel de {1}. Remplacez-le, si possible, par un tableau en escalier.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageBody">
        <source>{0} uses a multidimensional array of {1}. Replace it with a jagged array if possible.</source>
        <target state="translated">{0} utilise un tableau multidimensionnel de {1}. Remplacez-le, si possible, par un tableau en escalier.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticTitle">
        <source>Mark members as static</source>
        <target state="translated">Marquer les membres comme étant static</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticDescription">
        <source>Members that do not access instance data or call instance methods can be marked as static (Shared in Visual Basic). After you mark the methods as static, the compiler will emit nonvirtual call sites to these members. This can give you a measurable performance gain for performance-sensitive code.</source>
        <target state="translated">Les membres qui n'accèdent pas aux données d'instance ou qui n'appellent pas de méthodes d'instance peuvent être marqués comme étant static (Shared en Visual Basic). Une fois que vous avez marqué les méthodes comme étant static, le compilateur émet des sites d'appel non virtuels pour ces membres. Cela peut apporter un gain de performances mesurable pour le code qui en dépend.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticMessage">
        <source>Member {0} does not access instance data and can be marked as static (Shared in VisualBasic)</source>
        <target state="translated">Le membre {0} n'accède pas aux données d'instance et peut être marqué comme étant static (Shared en Visual Basic)</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersTitle">
        <source>Review visible event handlers</source>
        <target state="translated">Passer en revue les gestionnaires d'événements visibles</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersDescription">
        <source>A public or protected event-handling method was detected. Event-handling methods should not be exposed unless absolutely necessary.</source>
        <target state="translated">Une méthode publique ou protégée de gestion des événements a été détectée. Les méthodes de gestion des événements ne doivent pas être exposées sauf en cas d'absolue nécessité.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersMessageSecurity">
        <source>Consider making {0} not externally visible or ensure that it is benign code.</source>
        <target state="translated">Rendez {0} non visible de manière externe, ou vérifiez qu'il s'agit d'un code bénin.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersMessageDefault">
        <source>Consider making {0} not externally visible.</source>
        <target state="translated">Rendez {0} non visible de manière externe.</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesTitle">
        <source>Seal methods that satisfy private interfaces</source>
        <target state="translated">Sceller les méthodes qui satisfont les interfaces privées</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesDescription">
        <source>An inheritable public type provides an overridable method implementation of an internal (Friend in Visual Basic) interface. To fix a violation of this rule, prevent the method from being overridden outside the assembly.</source>
        <target state="translated">Un type public héritable fournit une implémentation de méthode substituable d'une interface internal (Friend en Visual Basic). Pour corriger une violation de cette règle, empêchez le remplacement de la méthode en dehors de l'assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesMessage">
        <source>Seal methods that satisfy private interfaces</source>
        <target state="translated">Sceller les méthodes qui satisfont les interfaces privées</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveEmptyFinalizers">
        <source>Remove empty Finalizers</source>
        <target state="translated">Supprimer les finaliseurs vides</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveEmptyFinalizersDescription">
        <source>Finalizers should be avoided where possible, to avoid the additional performance overhead involved in tracking object lifetime.</source>
        <target state="translated">Si possible, évitez d'utiliser les finaliseurs. Vous éviterez ainsi la surcharge de performances qu'implique le suivi de la durée de vie des objets.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructors">
        <source>Do not call overridable methods in constructors</source>
        <target state="translated">N'appelez pas de méthodes substituables dans les constructeurs</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructorsDescription">
        <source>Virtual methods defined on the class should not be called from constructors. If a derived class has overridden the method, the derived class version will be called (before the derived class constructor is called).</source>
        <target state="translated">Les méthodes virtuelles définies sur la classe ne doivent pas être appelées à partir de constructeurs. Si une classe dérivée a remplacé la méthode, la version de la classe dérivée est appelée (avant que le constructeur de la classe dérivée ne soit appelé).</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsMessage">
        <source>Re-throwing caught exception changes stack information.</source>
        <target state="translated">Quand une exception interceptée est levée à nouveau, cela entraîne un changement des informations de la pile.</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsTitle">
        <source>Rethrow to preserve stack details.</source>
        <target state="translated">Levez à nouveau une exception pour conserver les détails de la pile.</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeDeclaringTypeInternal">
        <source>Make declaring type internal.</source>
        <target state="translated">Rendez le type déclarant interne.</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeDeclaringTypeSealed">
        <source>Make declaring type sealed.</source>
        <target state="translated">Rendez le type déclarant sealed.</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeMemberNotOverridable">
        <source>Make member not overridable.</source>
        <target state="translated">Rendez le membre non substituable.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesDescription">
        <source>When an exception is raised in a finally clause, the new exception hides the active exception. This makes the original error difficult to detect and debug.</source>
        <target state="translated">Quand une exception est levée dans une clause finally, la nouvelle exception masque l'exception active. Cela rend l'erreur d'origine difficile à détecter et à corriger.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesMessageFinally">
        <source>Do not raise an exception from within a finally clause. </source>
        <target state="translated">Ne levez pas une exception à partir d'une clause finally. </target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesTitle">
        <source>Do not raise exceptions in finally clauses</source>
        <target state="translated">Ne pas lever d'exceptions dans les clauses finally</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateCodeActionTitle">
        <source>Change to constant</source>
        <target state="translated">Changer en constante</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationDescription">
        <source>Indexed elements in objects initializers must initialize unique elements. A duplicate index might overwrite a previous element initialization.</source>
        <target state="translated">Les éléments indexés dans des initialiseurs d'objets doivent initialiser des éléments uniques. Un index dupliqué peut remplacer une précédente initialisation d'éléments.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationMessage">
        <source>The element at index [{0}] has already been initialized. Previous initializations of this element may be overwritten.</source>
        <target state="translated">L'élément à l'index [{0}] a déjà été initialisé. Les précédentes initialisations de cet élément peuvent être remplacées.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationTitle">
        <source>Do not duplicate indexed element initializations</source>
        <target state="translated">Ne pas dupliquer les initialisations d'éléments indexés</target>
        <note />
      </trans-unit>
      <trans-unit id="ValidateArgumentsOfPublicMethodsDescription">
        <source>An externally visible method dereferences one of its reference arguments without verifying whether that argument is null (Nothing in Visual Basic). All reference arguments that are passed to externally visible methods should be checked against null. If appropriate, throw an ArgumentNullException when the argument is null or add a Code Contract precondition asserting non-null argument. If the method is designed to be called only by known assemblies, you should make the method internal.</source>
        <target state="translated">Une méthode visible de manière externe déréférence un de ses arguments de référence sans vérifier si cet argument a une valeur null (Nothing en Visual Basic). Tous les arguments de référence passés à des méthodes visibles de manière externe doivent faire l'objet d'une vérification permettant de déterminer s'ils ont une valeur null. Le cas échéant, ArgumentNullException doit être levé quand l'argument a une valeur null, ou vous devez ajouter une condition préalable au contrat de code pour garantir que l'argument a une valeur non null. Si la méthode est conçue pour être appelée uniquement par des assemblys connus, rendez la méthode interne.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValidateArgumentsOfPublicMethodsMessage">
        <source>In externally visible method '{0}', validate parameter '{1}' is non-null before using it. If appropriate, throw an ArgumentNullException when the argument is null or add a Code Contract precondition asserting non-null argument.</source>
        <target state="translated">Dans la méthode '{0}' visible de manière externe, vérifiez que le paramètre '{1}' a une valeur non null avant de l'utiliser. Le cas échéant, ArgumentNullException doit être levé quand l'argument a une valeur null, ou vous devez ajouter une condition préalable au contrat de code pour garantir que l'argument a une valeur non null.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValidateArgumentsOfPublicMethodsTitle">
        <source>Validate arguments of public methods</source>
        <target state="translated">Valider les arguments de méthodes publiques</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
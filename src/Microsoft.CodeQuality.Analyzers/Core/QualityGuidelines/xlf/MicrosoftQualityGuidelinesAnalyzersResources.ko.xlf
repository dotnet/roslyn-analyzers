<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ko" original="../MicrosoftQualityGuidelinesAnalyzersResources.resx">
    <body>
      <trans-unit id="UseLiteralsWhereAppropriateTitle">
        <source>Use literals where appropriate</source>
        <target state="translated">적합한 리터럴을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateDescription">
        <source>A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized by using a value that is computable at compile time. Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic) field so that the value is computed at compile time instead of at run?time.</source>
        <target state="translated">필드가 static 및 읽기 전용(Visual Basic의 경우 Shared 및 ReadOnly)으로 선언되었으며 컴파일 시간에 계산할 수 있는 값을 사용하여 초기화되었습니다. 대상 필드에 할당된 값을 컴파일 시간에 계산할 수 있으므로 이 값이 런타임 대신 컴파일 시간에 계산될 수 있도록 선언을 const(Visual Basic의 경우 Const)로 변경하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateMessageDefault">
        <source>Field '{0}' is declared as 'static readonly' but is initialized with a constant value. Mark this field as 'const' instead.</source>
        <target state="translated">'{0}' 필드가 'static readonly'로 선언되었지만 상수 값으로 초기화되었습니다. 이 필드를 'const'로 표시하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateMessageEmptyString">
        <source>Field '{0}' is declared as 'static readonly' but is initialized with an empty string (""). Mark this field as 'const' instead.</source>
        <target state="translated">'{0}' 필드가 'static readonly'로 선언되었지만 빈 문자열("")로 초기화되었습니다. 이 필드를 'const'로 표시하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyTitle">
        <source>Do not initialize unnecessarily</source>
        <target state="translated">불필요한 초기화를 수행하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyDescription">
        <source>The common language runtime initializes all fields to their default values before running the constructor. In most cases, initializing a field to its default value in a constructor is redundant, which degrades performance and adds to maintenance costs. One case where it is not redundant occurs when the constructor calls another constructor of the same class or a base class constructor and that constructor initializes the field to a non-default value. In this case, changing the value of the field back to its default value can be appropriate.</source>
        <target state="translated">공용 언어 런타임은 생성자를 실행하기 전에 모든 필드를 기본값으로 초기화합니다. 대부분의 경우 생성자에서 필드를 기본값으로 초기화하는 것은 중복되는 작업이며 이로 인해 성능이 저하되고 유지 관리 비용이 추가로 발생합니다. 생성자가 동일한 클래스의 다른 생성자 또는 기본 클래스 생성자를 호출하고 해당 생성자가 필드를 기본값이 아닌 값으로 초기화하는 경우는 중복되는 작업이 아닙니다. 이 경우 필드 값을 기본값으로 초기화하는 작업이 적합할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyMessage">
        <source>Do not initialize unnecessarily</source>
        <target state="translated">불필요한 초기화를 수행하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalTitle">
        <source>Prefer jagged arrays over multidimensional</source>
        <target state="translated">다차원 배열보다 가변 배열을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalDescription">
        <source>A jagged array is an array whose elements are arrays. The arrays that make up the elements can be of different sizes, leading to less wasted space for some sets of data.</source>
        <target state="translated">요소가 배열인 배열이 가변 배열입니다. 요소를 구성하는 배열의 크기는 다양하기 때문에 일부 데이터 집합의 공간을 절약할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageDefault">
        <source>{0} is a multidimensional array. Replace it with a jagged array if possible.</source>
        <target state="translated">{0}은(는) 다차원 배열입니다. 가능한 경우 가변 배열로 바꾸세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageReturn">
        <source>{0} returns a multidimensional array of {1}. Replace it with a jagged array if possible.</source>
        <target state="translated">{0}이(가) {1}의 다차원 배열을 반환합니다. 가능한 경우 가변 배열로 바꾸세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageBody">
        <source>{0} uses a multidimensional array of {1}. Replace it with a jagged array if possible.</source>
        <target state="translated">{0}이(가) {1}의 다차원 배열을 사용합니다. 가능한 경우 가변 배열로 바꾸세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticTitle">
        <source>Mark members as static</source>
        <target state="translated">멤버를 static으로 표시하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticDescription">
        <source>Members that do not access instance data or call instance methods can be marked as static (Shared in Visual Basic). After you mark the methods as static, the compiler will emit nonvirtual call sites to these members. This can give you a measurable performance gain for performance-sensitive code.</source>
        <target state="translated">인스턴스 데이터에 액세스하지 않거나 인스턴스 메서드를 호출하지 않는 멤버는 static(Visual Basic의 경우 Shared)으로 표시할 수 있습니다. 메서드를 static으로 표시하면 컴파일러가 멤버에 대한 비가상 호출 사이트를 내보냅니다. 따라서 성능에 민감한 코드의 경우 이 방법으로 성능을 크게 향상시킬 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticMessage">
        <source>Member {0} does not access instance data and can be marked as static (Shared in VisualBasic)</source>
        <target state="translated">{0} 멤버가 인스턴스 데이터에 액세스하지 않으며 static(Visual Basic의 경우 Shared)으로 표시될 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeTitle">
        <source>Dispose Objects Before Losing Scope</source>
        <target state="translated">범위를 벗어나기 전에 개체를 삭제하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeDescription">
        <source>Because an exceptional event might occur that will prevent the finalizer of an object from running, the object should be explicitly disposed before all references to it are out of scope.</source>
        <target state="translated">개체 종료자가 실행되지 않는 문제를 일으키는 예외적인 이벤트가 발생할 수 있으므로 개체에 대한 모든 참조가 범위를 벗어나기 전에 개체를 명시적으로 삭제해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeMessage">
        <source>Dispose Objects Before Losing Scope</source>
        <target state="translated">범위를 벗어나기 전에 개체를 삭제하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersTitle">
        <source>Review visible event handlers</source>
        <target state="translated">표시되는 이벤트 처리기를 검토하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersDescription">
        <source>A public or protected event-handling method was detected. Event-handling methods should not be exposed unless absolutely necessary.</source>
        <target state="translated">public 또는 protected 이벤트 처리 메서드가 검색되었습니다. 이벤트 처리 메서드는 필요한 경우에만 표시해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersMessageSecurity">
        <source>Consider making {0} not externally visible or ensure that it is benign code.</source>
        <target state="translated">{0}이(가) 외부에 표시되지 않도록 하거나 심각하지 않은 코드인지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersMessageDefault">
        <source>Consider making {0} not externally visible.</source>
        <target state="translated">{0}이(가) 외부에 표시되지 않도록 하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesTitle">
        <source>Seal methods that satisfy private interfaces</source>
        <target state="translated">private 인터페이스를 만족하는 메서드를 봉인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesDescription">
        <source>An inheritable public type provides an overridable method implementation of an internal (Friend in Visual Basic) interface. To fix a violation of this rule, prevent the method from being overridden outside the assembly.</source>
        <target state="translated">상속 가능한 public 형식은 내부(Visual Basic의 경우 Friend) 인터페이스의 재정의 가능한 메서드 구현을 제공합니다. 이 규칙 위반 문제를 해결하려면 어셈블리 외부에서 메서드가 재정의되지 않도록 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesMessage">
        <source>Seal methods that satisfy private interfaces</source>
        <target state="translated">private 인터페이스를 만족하는 메서드를 봉인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveEmptyFinalizers">
        <source>Remove empty Finalizers</source>
        <target state="translated">빈 종료자를 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveEmptyFinalizersDescription">
        <source>Finalizers should be avoided where possible, to avoid the additional performance overhead involved in tracking object lifetime.</source>
        <target state="translated">개체 수명 추적과 관련된 추가적인 성능 오버헤드를 피하기 위해 가능하면 종료자를 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructors">
        <source>Do not call overridable methods in constructors</source>
        <target state="translated">생성자에서 재정의 가능한 메서드를 호출하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructorsDescription">
        <source>Virtual methods defined on the class should not be called from constructors. If a derived class has overridden the method, the derived class version will be called (before the derived class constructor is called).</source>
        <target state="translated">클래스에 정의된 가상 메서드는 생성자에서 호출하면 안 됩니다. 파생 클래스가 메서드를 재정의하면 파생 클래스 생성자가 호출되기 전에 파생 클래스 버전이 호출됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsMessage">
        <source>Re-throwing caught exception changes stack information.</source>
        <target state="translated">catch한 예외를 다시 throw하면 스택 정보가 변경됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsTitle">
        <source>Rethrow to preserve stack details.</source>
        <target state="translated">스택 정보를 유지하려면 다시 throw하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeDeclaringTypeInternal">
        <source>Make declaring type internal.</source>
        <target state="translated">선언 형식을 internal로 설정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeDeclaringTypeSealed">
        <source>Make declaring type sealed.</source>
        <target state="translated">선언 형식을 sealed로 설정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeMemberNotOverridable">
        <source>Make member not overridable.</source>
        <target state="translated">멤버를 not overridable로 설정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesDescription">
        <source>When an exception is raised in a finally clause, the new exception hides the active exception. This makes the original error difficult to detect and debug.</source>
        <target state="translated">finally 절에서 예외가 발생하는 경우 새로운 예외가 활성 예외를 숨깁니다. 이로 인해 원래 오류를 감지하거나 디버그하기 어려워집니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesMessageFinally">
        <source>Do not raise an exception from within a finally clause. </source>
        <target state="translated">finally 절 내에서 예외를 발생시키지 마세요. </target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesTitle">
        <source>Do not raise exceptions in finally clauses</source>
        <target state="translated">finally 절에서 예외를 발생시키지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateCodeActionTitle">
        <source>Change to constant</source>
        <target state="translated">상수로 변경하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationDescription">
        <source>Indexed elements in objects initializers must initialize unique elements. A duplicate index might overwrite a previous element initialization.</source>
        <target state="new">Indexed elements in objects initializers must initialize unique elements. A duplicate index might overwrite a previous element initialization.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationMessage">
        <source>The element at index [{0}] has already been initialized. Previous initializations of this element may be overwritten.</source>
        <target state="new">The element at index [{0}] has already been initialized. Previous initializations of this element may be overwritten.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationTitle">
        <source>Do not duplicate indexed element initializations</source>
        <target state="new">Do not duplicate indexed element initializations</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
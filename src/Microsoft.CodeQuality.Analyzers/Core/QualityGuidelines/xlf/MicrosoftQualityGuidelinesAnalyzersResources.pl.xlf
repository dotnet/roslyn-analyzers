<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="pl" original="../MicrosoftQualityGuidelinesAnalyzersResources.resx">
    <body>
      <trans-unit id="AvoidPropertySelfAssignmentMessage">
        <source>The property {0} should not be assigned to itself.</source>
        <target state="translated">Właściwość {0} nie powinna być przypisana do samej siebie.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidPropertySelfAssignmentTitle">
        <source>Do not assign a property to itself.</source>
        <target state="translated">Nie przypisuj właściwości do jej samej.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticCodeFix">
        <source>Make static</source>
        <target state="translated">Ustaw jako statyczne</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticCodeFix_WarningAnnotation">
        <source>Some references to '{0}' could not be fixed, they should be fixed manually.</source>
        <target state="translated">Nie można naprawić niektórych odwołań do „{0}”. Należy je naprawić ręcznie.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferringToObjectAndReassigningItInTheSameStatementMessage">
        <source>Object '{0}' is being referred to and reassigned in the same statement. You are at risk of referring to unintended object.</source>
        <target state="new">Object '{0}' is being referred to and reassigned in the same statement. You are at risk of referring to unintended object.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferringToObjectAndReassigningItInTheSameStatementTitle">
        <source>Referring to object and reassigning it in the same statement.</source>
        <target state="new">Referring to object and reassigning it in the same statement.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateTitle">
        <source>Use literals where appropriate</source>
        <target state="translated">Używaj literałów w odpowiednich miejscach</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateDescription">
        <source>A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized by using a value that is computable at compile time. Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic) field so that the value is computed at compile time instead of at run?time.</source>
        <target state="translated">Pole zostało zadeklarowane jako statyczne i tylko do odczytu (Shared i ReadOnly w języku Visual Basic) i zainicjowane przy użyciu wartości obliczanych w czasie kompilacji. Ponieważ wartość przypisana do pola docelowego jest obliczana w czasie kompilacji, należy zmienić deklarację na pole wartości stałej (Const w języku Visual Basic), aby wartość była obliczana w czasie kompilacji, a nie w czasie wykonywania.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateMessageDefault">
        <source>Field '{0}' is declared as 'static readonly' but is initialized with a constant value. Mark this field as 'const' instead.</source>
        <target state="translated">Pole „{0}” zostało zadeklarowane jako statyczne pole tylko do odczytu, ale zainicjowano je za pomocą wartości stałej. Zamiast tego oznacz to pole jako pole wartości stałej.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateMessageEmptyString">
        <source>Field '{0}' is declared as 'static readonly' but is initialized with an empty string (""). Mark this field as 'const' instead.</source>
        <target state="translated">Pole „{0}” zostało zadeklarowane jako statyczne pole tylko do odczytu, ale zainicjowano je za pomocą pustego ciągu (""). Zamiast tego oznacz to pole jako pole wartości stałej.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyTitle">
        <source>Do not initialize unnecessarily</source>
        <target state="translated">Nie inicjuj niepotrzebnie</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyDescription">
        <source>The common language runtime initializes all fields to their default values before running the constructor. In most cases, initializing a field to its default value in a constructor is redundant, which degrades performance and adds to maintenance costs. One case where it is not redundant occurs when the constructor calls another constructor of the same class or a base class constructor and that constructor initializes the field to a non-default value. In this case, changing the value of the field back to its default value can be appropriate.</source>
        <target state="translated">Środowisko uruchomieniowe CLR inicjuje wszystkie pola do ich domyślnych wartości przed uruchomieniem konstruktora. W większości przypadków zainicjowanie pola do jego domyślnej wartości jest zbędne, ponieważ zmniejsza wydajność i zwiększa koszty utrzymania. Jedyny przypadek, gdy nie jest to zbędne, występuje, gdy konstruktor wywołuje inny konstruktor tej samej klasy lub konstruktor klasy podstawowej, a ten konstruktor inicjuje pole do wartości innej niż domyślna. W tym przypadku zmiana wartości pola z powrotem na wartość domyślną może być odpowiednia.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyMessage">
        <source>Do not initialize unnecessarily</source>
        <target state="translated">Nie inicjuj niepotrzebnie</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalTitle">
        <source>Prefer jagged arrays over multidimensional</source>
        <target state="translated">Wybieraj tablice nieregularne zamiast wielowymiarowych</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalDescription">
        <source>A jagged array is an array whose elements are arrays. The arrays that make up the elements can be of different sizes, leading to less wasted space for some sets of data.</source>
        <target state="translated">Tablica nieregularna jest tablicą, której elementami są tablice. Tablice będące elementami mogą mieć różny rozmiar, co sprawia, że w przypadku niektórych zestawów danych marnowane jest mniej miejsca.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageDefault">
        <source>{0} is a multidimensional array. Replace it with a jagged array if possible.</source>
        <target state="translated">{0} jest tablicą wielowymiarową. Należy ją zastąpić tablicą nieregularną, jeśli to możliwe.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageReturn">
        <source>{0} returns a multidimensional array of {1}. Replace it with a jagged array if possible.</source>
        <target state="translated">{0} zwraca tablicę wielowymiarową {1}. Należy ją zastąpić tablicą nieregularną, jeśli to możliwe.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageBody">
        <source>{0} uses a multidimensional array of {1}. Replace it with a jagged array if possible.</source>
        <target state="translated">{0} powoduje użycie tablicy wielowymiarowej {1}. Należy ją zastąpić tablicą nieregularną, jeśli to możliwe.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticTitle">
        <source>Mark members as static</source>
        <target state="translated">Oznaczaj elementy członkowskie jako statyczne</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticDescription">
        <source>Members that do not access instance data or call instance methods can be marked as static (Shared in Visual Basic). After you mark the methods as static, the compiler will emit nonvirtual call sites to these members. This can give you a measurable performance gain for performance-sensitive code.</source>
        <target state="translated">Elementy członkowskie, które nie uzyskują dostępu do danych wystąpienia lub metod wywołania wystąpienia można oznaczyć jako statyczne (Shared w języku Visual Basic). Po oznaczeniu metod jako statyczne kompilator będzie emitować niewirtualne miejsca wywołań do tych elementów członkowskich. Może to spowodować wymierną poprawę wydajności kodu wrażliwego na zmiany wydajności.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticMessage">
        <source>Member {0} does not access instance data and can be marked as static (Shared in VisualBasic)</source>
        <target state="translated">Element członkowski {0} nie uzyskuje dostępu do danych wystąpień i może zostać oznaczony jako statyczny (Shared w języku VisualBasic).</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersTitle">
        <source>Review visible event handlers</source>
        <target state="translated">Przejrzyj widoczne procedury obsługi zdarzeń</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersDescription">
        <source>A public or protected event-handling method was detected. Event-handling methods should not be exposed unless absolutely necessary.</source>
        <target state="translated">Wykryto publiczną lub chronioną metodą obsługi zdarzeń. Nie należy ujawniać metod obsługi zdarzeń, o ile nie jest to absolutnie konieczne.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersMessageSecurity">
        <source>Consider making {0} not externally visible or ensure that it is benign code.</source>
        <target state="translated">Rozważ przekształcenie elementu {0} w zewnętrznie niewidoczny lub upewnij się, że zawiera niezłośliwy kod.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersMessageDefault">
        <source>Consider making {0} not externally visible.</source>
        <target state="translated">Rozważ przekształcenie elementu {0} w zewnętrznie niewidoczny.</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesTitle">
        <source>Seal methods that satisfy private interfaces</source>
        <target state="translated">Pieczętuj metody, które spełniają wymagania interfejsów prywatnych</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesDescription">
        <source>An inheritable public type provides an overridable method implementation of an internal (Friend in Visual Basic) interface. To fix a violation of this rule, prevent the method from being overridden outside the assembly.</source>
        <target state="translated">Typ publiczny podlegający dziedziczeniu zapewnia implementację metody z możliwością przesłonięcia interfejsu (Friend w języku Visual Basic). Aby naprawić naruszenie tej reguły, należy uniemożliwić przesłonięcie tej metody poza zespołem.</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesMessage">
        <source>Seal methods that satisfy private interfaces</source>
        <target state="translated">Pieczętuj metody, które spełniają wymagania interfejsów prywatnych</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveEmptyFinalizers">
        <source>Remove empty Finalizers</source>
        <target state="translated">Usuwaj puste finalizatory</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveEmptyFinalizersDescription">
        <source>Finalizers should be avoided where possible, to avoid the additional performance overhead involved in tracking object lifetime.</source>
        <target state="translated">W miarę możliwości należy unikać finalizatorów, aby nie mnożyć czynników powodujących zmniejszenie wydajności związane ze śledzeniem czasu życia obiektów.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructors">
        <source>Do not call overridable methods in constructors</source>
        <target state="translated">Nie wywołuj w konstruktorach metod, które można przesłaniać</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructorsDescription">
        <source>Virtual methods defined on the class should not be called from constructors. If a derived class has overridden the method, the derived class version will be called (before the derived class constructor is called).</source>
        <target state="translated">Metody wirtualne zdefiniowane dla klasy nie powinny być wywoływane z konstruktorów. Jeśli klasa pochodna przesłoniła metodę, zostanie wywołana wersja klasy pochodnej (przed wywołaniem konstruktora klasy pochodnej).</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsMessage">
        <source>Re-throwing caught exception changes stack information.</source>
        <target state="translated">Ponowne zgłoszenie przechwyconego wyjątku powoduje zmianę informacji o stosie.</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsTitle">
        <source>Rethrow to preserve stack details.</source>
        <target state="translated">Ponowie zgłoś wyjątek, aby zachować szczegóły stosu.</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeDeclaringTypeInternal">
        <source>Make declaring type internal.</source>
        <target state="translated">Ustaw typ deklarujący jako wewnętrzny.</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeDeclaringTypeSealed">
        <source>Make declaring type sealed.</source>
        <target state="translated">Ustaw typ deklarujący jako zapieczętowany.</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeMemberNotOverridable">
        <source>Make member not overridable.</source>
        <target state="translated">Ustaw element członkowski jako niemożliwy do przesłonięcia.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesDescription">
        <source>When an exception is raised in a finally clause, the new exception hides the active exception. This makes the original error difficult to detect and debug.</source>
        <target state="translated">Wyjątek zgłoszony z klauzuli finally ukrywa aktywny wyjątek. Utrudnia to wykrycie i zdebugowanie pierwotnego błędu.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesMessageFinally">
        <source>Do not raise an exception from within a finally clause. </source>
        <target state="translated">Nie zgłaszaj wyjątku z klauzuli finally. </target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesTitle">
        <source>Do not raise exceptions in finally clauses</source>
        <target state="translated">Nie zgłaszaj wyjątków w klauzulach finally</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateCodeActionTitle">
        <source>Change to constant</source>
        <target state="translated">Zmień na stałą</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationDescription">
        <source>Indexed elements in objects initializers must initialize unique elements. A duplicate index might overwrite a previous element initialization.</source>
        <target state="translated">Indeksowane elementy w inicjatorach obiektów muszą inicjować unikatowe elementy. Zduplikowany indeks może powodować zastąpienie wcześniejszego zainicjowania elementu.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationMessage">
        <source>The element at index [{0}] has already been initialized. Previous initializations of this element may be overwritten.</source>
        <target state="translated">Element pod indeksem [{0}] został już zainicjowany. Wcześniejsze inicjowanie tego elementu może zostać zastąpione.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationTitle">
        <source>Do not duplicate indexed element initializations</source>
        <target state="translated">Nie duplikuj inicjowania indeksowanych elementów</target>
        <note />
      </trans-unit>
      <trans-unit id="ValidateArgumentsOfPublicMethodsDescription">
        <source>An externally visible method dereferences one of its reference arguments without verifying whether that argument is null (Nothing in Visual Basic). All reference arguments that are passed to externally visible methods should be checked against null. If appropriate, throw an ArgumentNullException when the argument is null or add a Code Contract precondition asserting non-null argument. If the method is designed to be called only by known assemblies, you should make the method internal.</source>
        <target state="translated">Zewnętrznie widoczna metoda umożliwia wyłuskanie jednego z jej argumentów odwołania bez weryfikowania, czy ten argument ma wartość null (wartość Nothing w języku Visual Basic). Wszystkie argumenty odwołania przekazywane do zewnętrznie widocznych metod powinny być sprawdzane pod kątem wartości null. Jeśli ma to uzasadnienie, należy zgłosić wyjątek ArgumentNullException, gdy argument ma wartość null, lub dodać warunek wstępny kontraktu kodu potwierdzający argument o wartości innej niż null. Jeśli metoda została zaprojektowana do wywoływania jedynie przez znane zestawy, powinna zostać ustawiona jako wewnętrzna.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValidateArgumentsOfPublicMethodsMessage">
        <source>In externally visible method '{0}', validate parameter '{1}' is non-null before using it. If appropriate, throw an ArgumentNullException when the argument is null or add a Code Contract precondition asserting non-null argument.</source>
        <target state="translated">W zewnętrznie widocznej metodzie „{0}” należy zweryfikować, czy parametr „{1}” ma wartość inną niż null przed jego użyciem. Jeśli ma to uzasadnienie, należy zgłosić wyjątek ArgumentNullException, gdy argument ma wartość null, lub dodać warunek wstępny kontraktu kodu potwierdzający argument o wartości innej niż null.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValidateArgumentsOfPublicMethodsTitle">
        <source>Validate arguments of public methods</source>
        <target state="translated">Waliduj argumenty metod publicznych</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
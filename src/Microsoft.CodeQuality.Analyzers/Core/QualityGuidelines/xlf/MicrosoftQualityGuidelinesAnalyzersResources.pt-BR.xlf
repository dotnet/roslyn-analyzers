<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="pt-BR" original="../MicrosoftQualityGuidelinesAnalyzersResources.resx">
    <body>
      <trans-unit id="UseLiteralsWhereAppropriateTitle">
        <source>Use literals where appropriate</source>
        <target state="translated">Usar literais sempre que apropriado</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateDescription">
        <source>A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized by using a value that is computable at compile time. Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic) field so that the value is computed at compile time instead of at run?time.</source>
        <target state="translated">Um campo é declarado como estático e somente leitura (Shared e ReadOnly no Visual Basic) e inicializado usando um valor que pode ser computado no tempo de compilação. Como o valor atribuído ao campo direcionado pode ser computado no tempo de compilação, altere a declaração para um campo const (Const no Visual Basic) para que o valor seja computado no tempo de compilação em vez de no tempo de execução.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateMessageDefault">
        <source>Field '{0}' is declared as 'static readonly' but is initialized with a constant value. Mark this field as 'const' instead.</source>
        <target state="translated">O campo '{0}' é declarado como 'static readonly', mas inicializado com um valor constante. Em vez disso, marque esse campo como 'const'.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateMessageEmptyString">
        <source>Field '{0}' is declared as 'static readonly' but is initialized with an empty string (""). Mark this field as 'const' instead.</source>
        <target state="translated">O campo '{0}' é declarado como 'static readonly', mas inicializado com uma cadeia de caracteres vazia (""). Em vez disso, marque esse campo como 'const'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyTitle">
        <source>Do not initialize unnecessarily</source>
        <target state="translated">Não inicializar desnecessariamente</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyDescription">
        <source>The common language runtime initializes all fields to their default values before running the constructor. In most cases, initializing a field to its default value in a constructor is redundant, which degrades performance and adds to maintenance costs. One case where it is not redundant occurs when the constructor calls another constructor of the same class or a base class constructor and that constructor initializes the field to a non-default value. In this case, changing the value of the field back to its default value can be appropriate.</source>
        <target state="translated">O Common Language Runtime inicializa todos os campos para seus valores padrão antes de executar o construtor. Na maioria dos casos, inicializar um campo para seu valor padrão em um construtor é redundante, o que prejudica o desempenho e aumenta os custos de manutenção. Um caso em que isso não é redundante ocorre quando o construtor chama outro construtor da mesma classe ou um construtor de classe base e esse construtor inicializa o campo para um valor não padrão. Nesse caso, alterar o valor do campo de volta para seu valor padrão pode ser apropriado.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyMessage">
        <source>Do not initialize unnecessarily</source>
        <target state="translated">Não inicializar desnecessariamente</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalTitle">
        <source>Prefer jagged arrays over multidimensional</source>
        <target state="translated">Prefira matrizes denteadas a matrizes multidimensionais</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalDescription">
        <source>A jagged array is an array whose elements are arrays. The arrays that make up the elements can be of different sizes, leading to less wasted space for some sets of data.</source>
        <target state="translated">Uma matriz denteada é uma matriz cujos elementos são matrizes. As matrizes que compõem os elementos podem ser de tamanhos diferentes, levando a menos espaço perdido para alguns conjuntos de dados.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageDefault">
        <source>{0} is a multidimensional array. Replace it with a jagged array if possible.</source>
        <target state="translated">{0} é uma matriz multidimensional. Se possível, substitua-a por uma matriz denteada.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageReturn">
        <source>{0} returns a multidimensional array of {1}. Replace it with a jagged array if possible.</source>
        <target state="translated">{0} retorna uma matriz multidimensional de {1}. Se possível, substitua-a por uma matriz denteada.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageBody">
        <source>{0} uses a multidimensional array of {1}. Replace it with a jagged array if possible.</source>
        <target state="translated">{0} usa uma matriz multidimensional de {1}. Se possível, substitua-a por uma matriz denteada.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticTitle">
        <source>Mark members as static</source>
        <target state="translated">Marcar membros como estáticos</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticDescription">
        <source>Members that do not access instance data or call instance methods can be marked as static (Shared in Visual Basic). After you mark the methods as static, the compiler will emit nonvirtual call sites to these members. This can give you a measurable performance gain for performance-sensitive code.</source>
        <target state="translated">Os membros que não acessam dados de instância ou chamam métodos de instância podem ser marcados como static (Shared no Visual Basic). Depois de marcar os métodos como estáticos, o compilador emitirá locais de chamada não virtuais para esses membros. Isso pode oferecer um ganho de desempenho mensurável para código sensível ao desempenho.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticMessage">
        <source>Member {0} does not access instance data and can be marked as static (Shared in VisualBasic)</source>
        <target state="translated">O membro {0} não acessa dados de instância e pode ser marcado como estático (Shared no VisualBasic)</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeTitle">
        <source>Dispose Objects Before Losing Scope</source>
        <target state="translated">Descartar objetos antes de perder o escopo</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeDescription">
        <source>Because an exceptional event might occur that will prevent the finalizer of an object from running, the object should be explicitly disposed before all references to it are out of scope.</source>
        <target state="translated">Já que poderá ocorrer um evento excepcional que impedirá a execução do finalizador de um objeto, o objeto deverá ser explicitamente descartado antes que todas as referências a ele fiquem fora de escopo.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeMessage">
        <source>Dispose Objects Before Losing Scope</source>
        <target state="translated">Descartar objetos antes de perder o escopo</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersTitle">
        <source>Review visible event handlers</source>
        <target state="translated">Examinar manipuladores de eventos visíveis</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersDescription">
        <source>A public or protected event-handling method was detected. Event-handling methods should not be exposed unless absolutely necessary.</source>
        <target state="translated">Foi detectado um método de manipulação de eventos público ou protegido. Os métodos de manipulação de eventos não devem ser expostos, a menos que absolutamente necessário.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersMessageSecurity">
        <source>Consider making {0} not externally visible or ensure that it is benign code.</source>
        <target state="translated">Considere fazer {0} não visível externamente ou garantir que seja código benigno.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersMessageDefault">
        <source>Consider making {0} not externally visible.</source>
        <target state="translated">Considere tornar {0} não visível externamente.</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesTitle">
        <source>Seal methods that satisfy private interfaces</source>
        <target state="translated">Métodos de lacre que satisfazem interfaces privadas</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesDescription">
        <source>An inheritable public type provides an overridable method implementation of an internal (Friend in Visual Basic) interface. To fix a violation of this rule, prevent the method from being overridden outside the assembly.</source>
        <target state="translated">Um tipo público herdável oferece uma implementação de método substituível de uma interface interna (Friend no Visual Basic). Para corrigir uma violação dessa regra, impeça o método de ser substituído fora do assembly.</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesMessage">
        <source>Seal methods that satisfy private interfaces</source>
        <target state="translated">Métodos de lacre que satisfazem interfaces privadas</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveEmptyFinalizers">
        <source>Remove empty Finalizers</source>
        <target state="translated">Remover finalizadores vazios</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveEmptyFinalizersDescription">
        <source>Finalizers should be avoided where possible, to avoid the additional performance overhead involved in tracking object lifetime.</source>
        <target state="translated">Os finalizadores devem ser evitados sempre que possível, para evitar a sobrecarga adicional de desempenho envolvida no acompanhamento do tempo de vida do objeto.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructors">
        <source>Do not call overridable methods in constructors</source>
        <target state="translated">Não chamar métodos substituíveis em construtores</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructorsDescription">
        <source>Virtual methods defined on the class should not be called from constructors. If a derived class has overridden the method, the derived class version will be called (before the derived class constructor is called).</source>
        <target state="translated">Os métodos virtuais definidos na classe não devem ser chamados de construtores. Se uma classe derivada tiver substituído o método, a versão da classe derivada será chamada (antes que o construtor da classe derivada seja chamado).</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsMessage">
        <source>Re-throwing caught exception changes stack information.</source>
        <target state="translated">Gerar novamente uma exceção detectada altera as informações de pilha.</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsTitle">
        <source>Rethrow to preserve stack details.</source>
        <target state="translated">Gere novamente para preservar os detalhes da pilha.</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeDeclaringTypeInternal">
        <source>Make declaring type internal.</source>
        <target state="translated">Torne o tipo declarativo interno.</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeDeclaringTypeSealed">
        <source>Make declaring type sealed.</source>
        <target state="translated">Torne o tipo declarativo selado.</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeMemberNotOverridable">
        <source>Make member not overridable.</source>
        <target state="translated">Torne o membro não substituível.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesDescription">
        <source>When an exception is raised in a finally clause, the new exception hides the active exception. This makes the original error difficult to detect and debug.</source>
        <target state="translated">Quando uma exceção é gerada em uma cláusula finally, a nova exceção oculta a exceção ativa. Isso torna o erro original difícil de ser detectado e depurado.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesMessageFinally">
        <source>Do not raise an exception from within a finally clause. </source>
        <target state="translated">Não gere uma exceção de dentro de uma cláusula finally. </target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesTitle">
        <source>Do not raise exceptions in finally clauses</source>
        <target state="translated">Não gerar exceções em cláusulas finally</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateCodeActionTitle">
        <source>Change to constant</source>
        <target state="translated">Alterar para constante</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationDescription">
        <source>Indexed elements in objects initializers must initialize unique elements. A duplicate index might overwrite a previous element initialization.</source>
        <target state="new">Indexed elements in objects initializers must initialize unique elements. A duplicate index might overwrite a previous element initialization.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationMessage">
        <source>The element at index [{0}] has already been initialized. Previous initializations of this element may be overwritten.</source>
        <target state="new">The element at index [{0}] has already been initialized. Previous initializations of this element may be overwritten.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationTitle">
        <source>Do not duplicate indexed element initializations</source>
        <target state="new">Do not duplicate indexed element initializations</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
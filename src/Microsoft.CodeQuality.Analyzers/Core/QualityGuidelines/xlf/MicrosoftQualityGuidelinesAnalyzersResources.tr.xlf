<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="tr" original="../MicrosoftQualityGuidelinesAnalyzersResources.resx">
    <body>
      <trans-unit id="AvoidPropertySelfAssignmentMessage">
        <source>The property {0} should not be assigned to itself.</source>
        <target state="translated">{0} özelliği kendisine atanmamalıdır.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidPropertySelfAssignmentTitle">
        <source>Do not assign a property to itself.</source>
        <target state="translated">Bir özelliği kendisine atamayın.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticCodeFix">
        <source>Make static</source>
        <target state="translated">Statik yap</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticCodeFix_WarningAnnotation">
        <source>Some references to '{0}' could not be fixed, they should be fixed manually.</source>
        <target state="translated">Bazı '{0}' başvuruları düzeltilemedi, bunları kendiniz düzeltmelisiniz.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencingAndReassigningObjectInSameStatementDescription">
        <source>When you go through the assignment chain right to left, firstly, reference in object '{0}' will be changed, but when you reffer to this object second time, since it's still the same statement, it will be pointing to it's old value. So if old value of '{0}' isn't saved elsewhere, result of the latter assignment will be lost.</source>
        <target state="new">When you go through the assignment chain right to left, firstly, reference in object '{0}' will be changed, but when you reffer to this object second time, since it's still the same statement, it will be pointing to it's old value. So if old value of '{0}' isn't saved elsewhere, result of the latter assignment will be lost.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencingAndReassigningObjectInSameStatementMessage">
        <source>Object '{0}' is referenced and reassigned in the same statement. You are at risk of referring to unintended object.</source>
        <target state="new">Object '{0}' is referenced and reassigned in the same statement. You are at risk of referring to unintended object.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferencingAndReassigningObjectInSameStatementTitle">
        <source>Referring to object and reassigning it in the same statement.</source>
        <target state="new">Referring to object and reassigning it in the same statement.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateTitle">
        <source>Use literals where appropriate</source>
        <target state="translated">Uygun durumlarda sabit değerler kullanın</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateDescription">
        <source>A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized by using a value that is computable at compile time. Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic) field so that the value is computed at compile time instead of at run?time.</source>
        <target state="translated">Alanlar statik ve salt okunur (Visual Basic’te Shared ve ReadOnly) olarak bildirilir ve derleme zamanında hesaplanabilen bir değer kullanılarak başlatılır. Hedeflenen alana atanmış değer derleme zamanında hesaplanabildiğinden, bir sabit (Visual Basic’te Const) alanına yönelik bildirimi, değerin çalışma zamanı yerine derleme zamanında hesaplanacağı şekilde değiştirin.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateMessageDefault">
        <source>Field '{0}' is declared as 'static readonly' but is initialized with a constant value. Mark this field as 'const' instead.</source>
        <target state="translated">'{0}' alanı 'static readonly' olarak bildirilmiş ama sabit bir değerle başlatılıyor. Bunun yerine, bu alanı 'const' olarak işaretleyin.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateMessageEmptyString">
        <source>Field '{0}' is declared as 'static readonly' but is initialized with an empty string (""). Mark this field as 'const' instead.</source>
        <target state="translated">'{0}' alanı 'static readonly' olarak bildirilmiş ama boş bir dizeyle ("") başlatılıyor. Bunun yerine, bu alanı 'const' olarak işaretleyin.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyTitle">
        <source>Do not initialize unnecessarily</source>
        <target state="translated">Gerekmediği durumlarda başlatmayın</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyDescription">
        <source>The common language runtime initializes all fields to their default values before running the constructor. In most cases, initializing a field to its default value in a constructor is redundant, which degrades performance and adds to maintenance costs. One case where it is not redundant occurs when the constructor calls another constructor of the same class or a base class constructor and that constructor initializes the field to a non-default value. In this case, changing the value of the field back to its default value can be appropriate.</source>
        <target state="translated">Ortak dil çalışma zamanı, oluşturucuyu çalıştırmadan önce tüm alanları varsayılan değerlerinde başlatır. Çoğu durumda, oluşturucuda bir alanın varsayılan değerinde başlatılması gereksizdir ve performansı düşürmesinin yanı sıra ek bakım maliyetleri doğurur. Bunun gereksiz olmadığı bir durum, oluşturucunun aynı sınıftan başka bir oluşturucuyu veya temel sınıf oluşturucusunu çağırdığı ve bu oluşturucunun alanı varsayılan olmayan bir değerde başlattığı durumdur. Bu durumda, alanın değerinin varsayılan değerine döndürülmesi uygun olabilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyMessage">
        <source>Do not initialize unnecessarily</source>
        <target state="translated">Gerekmediği durumlarda başlatmayın</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalTitle">
        <source>Prefer jagged arrays over multidimensional</source>
        <target state="translated">Çok boyutlu yerine düzensiz dizileri tercih edin</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalDescription">
        <source>A jagged array is an array whose elements are arrays. The arrays that make up the elements can be of different sizes, leading to less wasted space for some sets of data.</source>
        <target state="translated">Düzensiz dizi, öğeleri diziler halinde olan bir dizidir. Öğeleri oluşturan diziler farklı boyutlarda olabileceğinden, bazı veri kümeleri için daha az alan israfı sağlar.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageDefault">
        <source>{0} is a multidimensional array. Replace it with a jagged array if possible.</source>
        <target state="translated">{0}, çok boyutlu bir dizi. Mümkünse bunu düzensiz bir diziyle değiştirin.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageReturn">
        <source>{0} returns a multidimensional array of {1}. Replace it with a jagged array if possible.</source>
        <target state="translated">{0}, çok boyutlu {1} dizisini döndürüyor. Mümkünse bunu düzensiz bir diziyle değiştirin.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageBody">
        <source>{0} uses a multidimensional array of {1}. Replace it with a jagged array if possible.</source>
        <target state="translated">{0}, çok boyutlu {1} dizisini kullanıyor. Mümkünse bunu düzensiz bir diziyle değiştirin.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticTitle">
        <source>Mark members as static</source>
        <target state="translated">Üyeleri statik olarak işaretleyin</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticDescription">
        <source>Members that do not access instance data or call instance methods can be marked as static (Shared in Visual Basic). After you mark the methods as static, the compiler will emit nonvirtual call sites to these members. This can give you a measurable performance gain for performance-sensitive code.</source>
        <target state="translated">Örnek verilerine erişmeyen veya örnek yöntemlerini çağırmayan üyeler statik (Visual Basic’te Shared) olarak işaretlenebilir. Yöntemleri statik olarak işaretledikten sonra, derleyici bu üyelere yönelik sanal olmayan çağrı konumlarını gösterir. Bu, performans açısından duyarlı kod için önemli ölçüde performans kazanımı sağlar.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticMessage">
        <source>Member {0} does not access instance data and can be marked as static (Shared in VisualBasic)</source>
        <target state="translated">{0} üyesi örnek verilerine erişmiyor ve statik (Visual Basic’te Shared) olarak işaretlenebilir</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersTitle">
        <source>Review visible event handlers</source>
        <target state="translated">Görünür olay işleyicilerini gözden geçirin</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersDescription">
        <source>A public or protected event-handling method was detected. Event-handling methods should not be exposed unless absolutely necessary.</source>
        <target state="translated">Genel veya korumalı bir olay işleme yöntemi algılandı. Olay işleme yöntemleri kesinlikle gerekli olmadıkça kullanıma sunulmamalıdır.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersMessageSecurity">
        <source>Consider making {0} not externally visible or ensure that it is benign code.</source>
        <target state="translated">{0} öğesini dışarıdan görünmez yapmayı deneyin veya zararsız kod olduğundan emin olun.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersMessageDefault">
        <source>Consider making {0} not externally visible.</source>
        <target state="translated">{0} öğesini dışarıdan görünmez yapmayı deneyin.</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesTitle">
        <source>Seal methods that satisfy private interfaces</source>
        <target state="translated">Özel arabirimleri karşılayan mühürleme yöntemleri</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesDescription">
        <source>An inheritable public type provides an overridable method implementation of an internal (Friend in Visual Basic) interface. To fix a violation of this rule, prevent the method from being overridden outside the assembly.</source>
        <target state="translated">Devralınabilen bir genel tür, bir iç (Visual Basic’te Friend) arabirimin geçersiz kılınabilecek bir yöntem uygulamasını sağlar. Bu kuralın ihlal edildiği bir durumu düzeltmek için yöntemin bütünleştirilmiş kod dışında geçersiz kılınmasını engelleyin.</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesMessage">
        <source>Seal methods that satisfy private interfaces</source>
        <target state="translated">Özel arabirimleri karşılayan mühürleme yöntemleri</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveEmptyFinalizers">
        <source>Remove empty Finalizers</source>
        <target state="translated">Boş Finalizer’ları kaldırın</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveEmptyFinalizersDescription">
        <source>Finalizers should be avoided where possible, to avoid the additional performance overhead involved in tracking object lifetime.</source>
        <target state="translated">Nesne yaşam döngüsünün izlenmesi için gereken performans ek yükünden kaçınmak amacıyla sonlandırıclar mümkün olduğunca kullanılmamalıdır.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructors">
        <source>Do not call overridable methods in constructors</source>
        <target state="translated">Oluşturucularda geçersiz kılınabilen yöntemleri çağırmayın</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructorsDescription">
        <source>Virtual methods defined on the class should not be called from constructors. If a derived class has overridden the method, the derived class version will be called (before the derived class constructor is called).</source>
        <target state="translated">Sınıfta tanımlanan sanal yöntemler oluşturuculardan çağrılmamalıdır. Türetilen bir sınıf yöntemi geçersiz kıldıysa, türetilen sınıf sürümü çağrılır (türetilen sınıf oluşturucusu çağrılmadan önce).</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsMessage">
        <source>Re-throwing caught exception changes stack information.</source>
        <target state="translated">Yakalanan özel durumun yeniden oluşturulması, yığın bilgilerini değiştirir.</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsTitle">
        <source>Rethrow to preserve stack details.</source>
        <target state="translated">Yığın ayrıntılarını korumak için yeniden oluşturun.</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeDeclaringTypeInternal">
        <source>Make declaring type internal.</source>
        <target state="translated">Bildirim türünü dahili yapın.</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeDeclaringTypeSealed">
        <source>Make declaring type sealed.</source>
        <target state="translated">Bildirim türünü mühürlü yapın.</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeMemberNotOverridable">
        <source>Make member not overridable.</source>
        <target state="translated">Üyeyi geçersiz kılınamaz yapın.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesDescription">
        <source>When an exception is raised in a finally clause, the new exception hides the active exception. This makes the original error difficult to detect and debug.</source>
        <target state="translated">Bir finally yan tümcesinde özel durum tetiklenirse yeni özel durum etkin özel durumu gizler. Bu, özgün hatanın algılanmasını ve ayıklanmasını zorlaştırır.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesMessageFinally">
        <source>Do not raise an exception from within a finally clause. </source>
        <target state="translated">Bir finally yan tümcesinin içinden özel durum oluşturmayın. </target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesTitle">
        <source>Do not raise exceptions in finally clauses</source>
        <target state="translated">Finally yan tümcelerinde özel durum oluşturmayın</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateCodeActionTitle">
        <source>Change to constant</source>
        <target state="translated">Sabit olarak değiştirin</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationDescription">
        <source>Indexed elements in objects initializers must initialize unique elements. A duplicate index might overwrite a previous element initialization.</source>
        <target state="translated">Nesne başlatıcılarındaki dizine eklenmiş öğeler, benzersiz öğeleri başlatmalıdır. Yinelenen dizin, önceki öğe başlatmasının üzerine yazabilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationMessage">
        <source>The element at index [{0}] has already been initialized. Previous initializations of this element may be overwritten.</source>
        <target state="translated">[{0}] dizinindeki öğe zaten başlatılmış. Bu öğenin önceki başlatmalarının üzerine yazılabilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationTitle">
        <source>Do not duplicate indexed element initializations</source>
        <target state="translated">Dizine eklenmiş öğe başlatmalarını yineleme</target>
        <note />
      </trans-unit>
      <trans-unit id="ValidateArgumentsOfPublicMethodsDescription">
        <source>An externally visible method dereferences one of its reference arguments without verifying whether that argument is null (Nothing in Visual Basic). All reference arguments that are passed to externally visible methods should be checked against null. If appropriate, throw an ArgumentNullException when the argument is null or add a Code Contract precondition asserting non-null argument. If the method is designed to be called only by known assemblies, you should make the method internal.</source>
        <target state="translated">Dışarıdan görünen metot, bağımsız değişkenin null (Visual Basic’te Nothing) olup olmadığını doğrulamadan başvuru bağımsız değişkenlerinden birine başvurur. Dışarıdan görünen metotlara geçirilen tüm başvuru bağımsız değişkenlerinin null olup olmadığı denetlenmelidir. Uygunsa, bağımsız değişken null olduğunda bir ArgumentNullException oluşturun veya null olmayan bağımsız değişkenleri onaylayan bir Kod Sözleşmesi önkoşulu ekleyin. Metot yalnızca bilinen derlemeler tarafından çağrılacak şekilde tasarlanmışsa metodu içeriden görünen hale getirmeniz gerekir.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValidateArgumentsOfPublicMethodsMessage">
        <source>In externally visible method '{0}', validate parameter '{1}' is non-null before using it. If appropriate, throw an ArgumentNullException when the argument is null or add a Code Contract precondition asserting non-null argument.</source>
        <target state="translated">Dışarıdan görünen '{0}' metodunda '{1}' parametresini kullanmadan önce parametrenin null olmadığını doğrulayın. Uygunsa, bağımsız değişken null olduğunda bir ArgumentNullException oluşturun veya null olmayan bağımsız değişkenleri onaylayan bir Kod Sözleşmesi önkoşulu ekleyin.</target>
        <note />
      </trans-unit>
      <trans-unit id="ValidateArgumentsOfPublicMethodsTitle">
        <source>Validate arguments of public methods</source>
        <target state="translated">Genel yöntemlerin bağımsız değişkenlerini doğrulayın</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="zh-Hans" original="../MicrosoftQualityGuidelinesAnalyzersResources.resx">
    <body>
      <trans-unit id="AvoidPropertySelfAssignmentMessage">
        <source>The property {0} should not be assigned to itself.</source>
        <target state="translated">不得将属性 {0} 分配给其自身。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidPropertySelfAssignmentTitle">
        <source>Do not assign a property to itself.</source>
        <target state="translated">请勿将属性分配给其自身。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticCodeFix">
        <source>Make static</source>
        <target state="translated">设为静态</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticCodeFix_WarningAnnotation">
        <source>Some references to '{0}' could not be fixed, they should be fixed manually.</source>
        <target state="translated">无法修复对“{0}”的部分引用，应手动修复它们。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferingToObjectAndReassigningItInTheSameStatementMessage">
        <source>Object '{0}' is being referred to and reassigned in the same statement. You are at risk of referring to unintended object.</source>
        <target state="new">Object '{0}' is being referred to and reassigned in the same statement. You are at risk of referring to unintended object.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReferingToObjectAndReassigningItInTheSameStatementTitle">
        <source>Refering to object and reassigning it in the same statement.</source>
        <target state="new">Refering to object and reassigning it in the same statement.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateTitle">
        <source>Use literals where appropriate</source>
        <target state="translated">在合适的位置使用文本</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateDescription">
        <source>A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized by using a value that is computable at compile time. Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic) field so that the value is computed at compile time instead of at run?time.</source>
        <target state="translated">字段声明为 static 和 read-only (在 Visual Basic 中为 Shared 和 ReadOnly)，并且使用编译时可计算的值进行初始化。由于分配给目标字段的值在编译时是可计算的，因此将声明更改为常量(在 Visual Basic 中为 Const)，以便在编译时而非运行时计算值。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateMessageDefault">
        <source>Field '{0}' is declared as 'static readonly' but is initialized with a constant value. Mark this field as 'const' instead.</source>
        <target state="translated">虽然字段“{0}”声明为 "static readonly"，但它是用常量值初始化的。请将此字段标记为 "const"。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateMessageEmptyString">
        <source>Field '{0}' is declared as 'static readonly' but is initialized with an empty string (""). Mark this field as 'const' instead.</source>
        <target state="translated">虽然字段“{0}”声明为 "static readonly"，但它是用空字符串 ("") 初始化的。请将此字段标记为 "const"。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyTitle">
        <source>Do not initialize unnecessarily</source>
        <target state="translated">避免进行不必要的初始化</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyDescription">
        <source>The common language runtime initializes all fields to their default values before running the constructor. In most cases, initializing a field to its default value in a constructor is redundant, which degrades performance and adds to maintenance costs. One case where it is not redundant occurs when the constructor calls another constructor of the same class or a base class constructor and that constructor initializes the field to a non-default value. In this case, changing the value of the field back to its default value can be appropriate.</source>
        <target state="translated">在运行构造函数前，公共语言运行时将所有字段都初始化为其默认值。在大多数情况下，在构造函数中将字段初始化为其默认值是多余的行为，这会降低性能并且增加维护成本。但在构造函数调用相同类的另一构造函数或基类构造函数(此构造函数将字段初始化为非默认值)时，不存在多余的情况。在这种情况下，将字段值更改回其默认值是恰当的行为。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInitializeUnnecessarilyMessage">
        <source>Do not initialize unnecessarily</source>
        <target state="translated">避免进行不必要的初始化</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalTitle">
        <source>Prefer jagged arrays over multidimensional</source>
        <target state="translated">与多维数组相比，首选使用交错数组</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalDescription">
        <source>A jagged array is an array whose elements are arrays. The arrays that make up the elements can be of different sizes, leading to less wasted space for some sets of data.</source>
        <target state="translated">交错数组的元素为数组。构成元素的数组可以大小不同，使某些数据集的浪费空间减少。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageDefault">
        <source>{0} is a multidimensional array. Replace it with a jagged array if possible.</source>
        <target state="translated">{0} 是多维数组。如有可能，请使用交错数组来替代它。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageReturn">
        <source>{0} returns a multidimensional array of {1}. Replace it with a jagged array if possible.</source>
        <target state="translated">{0} 返回多维数组 {1}。如有可能，请使用交错数组来替代它。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferJaggedArraysOverMultidimensionalMessageBody">
        <source>{0} uses a multidimensional array of {1}. Replace it with a jagged array if possible.</source>
        <target state="translated">{0} 使用多维数组 {1}。如有可能，请使用交错数组来替代它。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticTitle">
        <source>Mark members as static</source>
        <target state="translated">将成员标记为 static</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticDescription">
        <source>Members that do not access instance data or call instance methods can be marked as static (Shared in Visual Basic). After you mark the methods as static, the compiler will emit nonvirtual call sites to these members. This can give you a measurable performance gain for performance-sensitive code.</source>
        <target state="translated">不访问实例数据或调用实例方法的成员可标记为 static (在 Visual Basic 中为 Shared)。将方法标记为 static 后，编译器将向这些成员发出非虚拟调用站点。这样可以使对性能比较敏感的代码获得显著的性能提升。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkMembersAsStaticMessage">
        <source>Member {0} does not access instance data and can be marked as static (Shared in VisualBasic)</source>
        <target state="translated">成员 {0} 不访问实例数据，可标记为 static (在 Visual Basic 中为 Shared)</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersTitle">
        <source>Review visible event handlers</source>
        <target state="translated">检查可见的事件处理程序</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersDescription">
        <source>A public or protected event-handling method was detected. Event-handling methods should not be exposed unless absolutely necessary.</source>
        <target state="translated">检测到公共或受保护的事件处理方法。除非绝对必要，否则不应公开事件处理方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersMessageSecurity">
        <source>Consider making {0} not externally visible or ensure that it is benign code.</source>
        <target state="translated">请考虑将 {0} 设为对外部不可见或确保它是良性代码。</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewVisibleEventHandlersMessageDefault">
        <source>Consider making {0} not externally visible.</source>
        <target state="translated">请考虑将 {0} 设为对外部不可见。</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesTitle">
        <source>Seal methods that satisfy private interfaces</source>
        <target state="translated">密封满足私有接口的方法</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesDescription">
        <source>An inheritable public type provides an overridable method implementation of an internal (Friend in Visual Basic) interface. To fix a violation of this rule, prevent the method from being overridden outside the assembly.</source>
        <target state="translated">可继承的公共类型提供内部(在 Visual Basic 中为 Friend)接口的可重写方法实现。若要修复与该规则的冲突，请阻止在程序集外部重写该方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="SealMethodsThatSatisfyPrivateInterfacesMessage">
        <source>Seal methods that satisfy private interfaces</source>
        <target state="translated">密封满足私有接口的方法</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveEmptyFinalizers">
        <source>Remove empty Finalizers</source>
        <target state="translated">移除空终结器</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveEmptyFinalizersDescription">
        <source>Finalizers should be avoided where possible, to avoid the additional performance overhead involved in tracking object lifetime.</source>
        <target state="translated">应尽可能避免使用终结器，避免跟踪对象生存期时产生额外的性能开销。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructors">
        <source>Do not call overridable methods in constructors</source>
        <target state="translated">不要在构造函数中调用可重写的方法</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructorsDescription">
        <source>Virtual methods defined on the class should not be called from constructors. If a derived class has overridden the method, the derived class version will be called (before the derived class constructor is called).</source>
        <target state="translated">不应通过构造函数调用类中定义的虚方法。如果某个派生类已重写该虚方法，则将在调用派生类的构造函数前，调用此派生类重写后的方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsMessage">
        <source>Re-throwing caught exception changes stack information.</source>
        <target state="translated">再次引发捕获到的异常会更改堆栈信息。</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsTitle">
        <source>Rethrow to preserve stack details.</source>
        <target state="translated">再次引发以保留堆栈详细信息。</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeDeclaringTypeInternal">
        <source>Make declaring type internal.</source>
        <target state="translated">使声明类型为 internal。</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeDeclaringTypeSealed">
        <source>Make declaring type sealed.</source>
        <target state="translated">使声明类型为密封。</target>
        <note />
      </trans-unit>
      <trans-unit id="MakeMemberNotOverridable">
        <source>Make member not overridable.</source>
        <target state="translated">使成员不可重写。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesDescription">
        <source>When an exception is raised in a finally clause, the new exception hides the active exception. This makes the original error difficult to detect and debug.</source>
        <target state="translated">在 finally 子句中引发异常时，新异常将隐藏活动异常。这样会使原来的错误难以检测和调试。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesMessageFinally">
        <source>Do not raise an exception from within a finally clause. </source>
        <target state="translated">不要在 finally 子句中引发异常。 </target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseExceptionsInExceptionClausesTitle">
        <source>Do not raise exceptions in finally clauses</source>
        <target state="translated">不要在 finally 子句中引发异常</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLiteralsWhereAppropriateCodeActionTitle">
        <source>Change to constant</source>
        <target state="translated">更改为常量</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationDescription">
        <source>Indexed elements in objects initializers must initialize unique elements. A duplicate index might overwrite a previous element initialization.</source>
        <target state="translated">对象初始值设定项中已索引的元素必须初始化唯一元素。重复索引可能覆盖先前的元素初始值设定项。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationMessage">
        <source>The element at index [{0}] has already been initialized. Previous initializations of this element may be overwritten.</source>
        <target state="translated">索引 [{0}] 处的元素已进行初始化。可能覆盖此元素先前的初始值设定项。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateElementInitializationTitle">
        <source>Do not duplicate indexed element initializations</source>
        <target state="translated">不要复制已索引的元素初始值设定项</target>
        <note />
      </trans-unit>
      <trans-unit id="ValidateArgumentsOfPublicMethodsDescription">
        <source>An externally visible method dereferences one of its reference arguments without verifying whether that argument is null (Nothing in Visual Basic). All reference arguments that are passed to externally visible methods should be checked against null. If appropriate, throw an ArgumentNullException when the argument is null or add a Code Contract precondition asserting non-null argument. If the method is designed to be called only by known assemblies, you should make the method internal.</source>
        <target state="translated">外部可见方法在不验证该参数是否为 null (Visual Basic 中为 Nothing)的情况下取消引用其某个引用参数。应检查传递给外部可见方法的所有引用参数中是否有参数为 null。如果适用，在参数为 null 时引发 ArgumentNullException，或添加断言非 null 参数的代码协定前提条件。如果该方法应仅由已知程序集调用，则应将该方法设置为在内部。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValidateArgumentsOfPublicMethodsMessage">
        <source>In externally visible method '{0}', validate parameter '{1}' is non-null before using it. If appropriate, throw an ArgumentNullException when the argument is null or add a Code Contract precondition asserting non-null argument.</source>
        <target state="translated">在外部可见方法“{0}”中，先验证参数“{1}”为非 null，然后再使用。如果适用，在参数为 null 时引发 ArgumentNullException，或添加断言非 null 参数的代码协定前提条件。</target>
        <note />
      </trans-unit>
      <trans-unit id="ValidateArgumentsOfPublicMethodsTitle">
        <source>Validate arguments of public methods</source>
        <target state="translated">验证公共方法的参数</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="es" original="../SystemRuntimeInteropServicesAnalyzersResources.resx">
    <body>
      <trans-unit id="PInvokesShouldNotBeVisibleTitle">
        <source>P/Invokes should not be visible</source>
        <target state="translated">Los elementos P/Invoke no deben estar visibles</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokesShouldNotBeVisibleDescription">
        <source>A public or protected method in a public type has the System.Runtime.InteropServices.DllImportAttribute attribute (also implemented by the Declare keyword in Visual Basic). Such methods should not be exposed.</source>
        <target state="translated">Un método público o protegido en un tipo público tiene el atributo System.Runtime.InteropServices.DllImportAttribute (también se implementa por la palabra clave Declare en Visual Basic). Estos métodos no deben exponerse.</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokesShouldNotBeVisibleMessage">
        <source>P/Invoke method '{0}' should not be visible</source>
        <target state="translated">El método P/Invoke "{0}" no debe ser visible</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokeDeclarationsShouldBePortableTitle">
        <source>PInvoke declarations should be portable</source>
        <target state="translated">Las declaraciones de PInvoke deben ser portables</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokeDeclarationsShouldBePortableDescription">
        <source>This rule evaluates the size of each parameter and the return value of a P/Invoke, and verifies that the size of the parameter is correct when marshaled to unmanaged code on 32-bit and 64-bit operating systems.</source>
        <target state="translated">Esta regla evalúa el tamaño de cada parámetro y el valor devuelto de un PInvoke y comprueba que su tamaño sea correcto al calcular las referencias para su conversión al código no administrado en plataformas de 32 y 64 bits.</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokeDeclarationsShouldBePortableMessageParameter">
        <source>As it is declared in your code, parameter {0} of P/Invoke {1} will be {2} bytes wide on {3} platforms. This is not correct, as the actual native declaration of this API indicates it should be {4} bytes wide on {3} platforms. Consult the MSDN Platform SDK documentation for help determining what data type should be used instead of {5}.</source>
        <target state="translated">Como se declara en el código, el parámetro '{0}' de P/Invoke {1} será de {2} bytes en {3} plataformas. Esto no es correcto, puesto que la declaración nativa actual de API indica que debería ser de {4} bytes en {3} plataformas. Consulte la documentación de Platform SDK de MSDN para obtener ayuda para determinar qué tipo de datos debería utilizarse en lugar de {5}.</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokeDeclarationsShouldBePortableMessageReturn">
        <source>As it is declared in your code, the return type of P/Invoke {0} will be {1} bytes wide on {2} platforms. This is not correct, as the actual native declaration of this API indicates it should be {3} bytes wide on {2} platforms. Consult the MSDN Platform SDK documentation for help determining what data type should be used instead of {4}.</source>
        <target state="translated">Como se declara en el código, el valor devuelto de P/Invoke {0} será de {1} bytes en {2} plataformas. Esto no es correcto puesto que la declaración nativa actual de esta API indica que debería ser de {3} bytes en {2} plataformas. Consulte la documentación de Platform SDK de MSDN para obtener ayuda para determinar qué tipo de datos debería utilizarse en lugar de {4}.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsTitle">
        <source>Specify marshaling for P/Invoke string arguments</source>
        <target state="translated">Especificar cálculo de referencias para argumentos de cadena P/Invoke</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsDescription">
        <source>A platform invoke member allows partially trusted callers, has a string parameter, and does not explicitly marshal the string. This can cause a potential security vulnerability.</source>
        <target state="translated">Un miembro de invocación de plataforma permite llamadores que no son de plena confianza, tiene un parámetro de cadena y no calcula explícitamente las referencias a la cadena. Esto puede provocar una potencial vulnerabilidad de seguridad.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsMessageParameter">
        <source>To reduce security risk, marshal parameter {0} as Unicode, by setting DllImport.CharSet to CharSet.Unicode, or by explicitly marshaling the parameter as UnmanagedType.LPWStr. If you need to marshal this string as ANSI or system-dependent, set BestFitMapping=false; for added security, also set ThrowOnUnmappableChar=true.</source>
        <target state="translated">Para reducir el riesgo de seguridad, calcule las referencias del parámetro {0} como Unicode, estableciendo DllImport.CharSet en CharSet.Unicode, o calculando explícitamente la referencia al parámetro como UnmanagedType.LPWStr. Si necesita calcular la referencia a esta cadena como ANSI o dependiente del sistema, establezca BestFitMapping=false; para una mayor seguridad, establezca también ThrowOnUnmappableChar=true.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsMessageField">
        <source>To reduce security risk, marshal field {0} as Unicode, by setting StructLayout.CharSet on {1} to CharSet.Unicode, or by explicitly marshaling the field as UnmanagedType.LPWStr. If you need to marshal this string as ANSI or system-dependent, use the BestFitMapping attribute to turn best-fit mapping off, and for added security, ensure ThrowOnUnmappableChar is on.</source>
        <target state="translated">Para reducir el riesgo de seguridad, calcule las referencias del campo {0} como Unicode, estableciendo StructLayout.CharSet de {1} en CharSet.Unicode, o calculando explícitamente la referencia al campo como UnmanagedType.LPWStr. Si necesita calcular la referencia a esta cadena como ANSI o dependiente del sistema, utilice el atributo BestFitMapping para desactivar la mejor asignación, y para una mayor seguridad, asegúrese de que ThrowOnUnmappableChar está activado.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsMessageParameterImplicitAnsi">
        <source>To reduce security risk, marshal parameter {0} as Unicode, by setting DllImport.CharSet to CharSet.Unicode, or by explicitly marshaling the parameter as UnmanagedType.LPWStr. If you need to marshal this string as ANSI or system-dependent, specify MarshalAs explicitly, and set BestFitMapping=false; for added security, also set ThrowOnUnmappableChar=true.</source>
        <target state="translated">Para reducir el riesgo de seguridad, calcule las referencias del parámetro {0} como Unicode, estableciendo DllImport.CharSet en CharSet.Unicode, o calculando explícitamente la referencia al parámetro como UnmanagedType.LPWStr. Si necesita calcular la referencia a esta cadena como ANSI o dependiente del sistema, especifique MarshalAs explícitamente, y establezca BestFitMapping=false; para una mayor seguridad, establezca también ThrowOnUnmappableChar=true.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsMessageFieldImplicitAnsi">
        <source>To reduce security risk, marshal field {0} as Unicode, by setting StructLayout.CharSet on {1} to CharSet.Unicode, or by explicitly marshaling the field as UnmanagedType.LPWStr. If you need to marshal this string as ANSI or system-dependent, specify MarshalAs explicitly, use the BestFitMapping attribute to turn best-fit mapping off, and for added security, to turn ThrowOnUnmappableChar on.</source>
        <target state="translated">Para reducir el riesgo de seguridad, calcule las referencias del campo {0} como Unicode, estableciendo StructLayout.CharSet de {1} en CharSet.Unicode, o calculando explícitamente la referencia al campo como UnmanagedType.LPWStr. Si necesita calcular la referencia a esta cadena como ANSI o dependiente del sistema, especifique MarshalAs explícitamente, utilice el atributo BestFitMapping para desactivar la mejor asignación, y para una mayor seguridad, active ThrowOnUnmappableChar.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseManagedEquivalentsOfWin32ApiTitle">
        <source>Use managed equivalents of win32 api</source>
        <target state="translated">Utilizar equivalentes administrados de la API Win32</target>
        <note />
      </trans-unit>
      <trans-unit id="UseManagedEquivalentsOfWin32ApiDescription">
        <source>An operating system invoke method is defined and a method that has the equivalent functionality is located in the .NET Framework class library.</source>
        <target state="translated">Se define un método de invocación de sistema operativo y hay un método con la funcionalidad equivalente en la biblioteca de clases de .NET Framework.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseManagedEquivalentsOfWin32ApiMessage">
        <source>Use managed equivalents of win32 api</source>
        <target state="translated">Utilizar equivalentes administrados de la API Win32</target>
        <note />
      </trans-unit>
      <trans-unit id="AlwaysConsumeTheValueReturnedByMethodsMarkedWithPreserveSigAttributeTitle">
        <source>Always consume the value returned by methods marked with PreserveSigAttribute</source>
        <target state="translated">Consuma siempre el valor devuelto por métodos marcados con PreserveSigAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="AlwaysConsumeTheValueReturnedByMethodsMarkedWithPreserveSigAttributeDescription">
        <source>PreserveSigAttribute indicates that a method will return an HRESULT, rather than throwing an exception. Therefore, it is important to consume the HRESULT returned by the method, so that errors can be detected. Generally, this is done by calling Marshal.ThrowExceptionForHR.</source>
        <target state="translated">PreserveSigAttribute indica que un método devolverá HRESULT, en lugar de generar una excepción. Por lo tanto, es importante utilizar el valor HRESULT devuelto por el método, de manera que se puedan detectar los errores. Por lo general, para ello se llama a Marshal.ThrowExceptionForHR.</target>
        <note />
      </trans-unit>
      <trans-unit id="AlwaysConsumeTheValueReturnedByMethodsMarkedWithPreserveSigAttributeMessage">
        <source>Consume the hresult returned by method '{0}' and call Marshal.ThrowExceptionForHR.</source>
        <target state="translated">Utilice el valor hresult devuelto por el método "{0}" y llame a Marshal.ThrowExceptionForHR.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsTitle">
        <source>Mark boolean PInvoke arguments with MarshalAs</source>
        <target state="translated">Marcar los argumentos booleanos de PInvoke con MarshalAs</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsDescription">
        <source>The Boolean data type has multiple representations in unmanaged code.</source>
        <target state="translated">El tipo de datos booleano tiene múltiples representaciones en código sin administrar.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsMessageDefault">
        <source>Add the MarshalAsAttribute to parameter {0} of P/Invoke {1}. If the corresponding unmanaged parameter is a 4-byte Win32 'BOOL', use [MarshalAs(UnmanagedType.Bool)]. For a 1-byte C++ 'bool', use MarshalAs(UnmanagedType.U1).</source>
        <target state="translated">Agregue el atributo MarshalAsAttribute al parámetro {0} de P/Invoke {1}. Si el correspondiente parámetro sin asignar es un "BOOL" de Win32 de 4 bytes, utilice [MarshalAs(UnmanagedType.Bool)]. Para un valor "bool" de C++ de 1 byte, utilice MarshalAs(UnmanagedType.U1).</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsMessageReturn">
        <source>Add the MarshalAsAttribute to the return type of P/Invoke {0}. If the corresponding unmanaged return type is a 4-byte Win32 'BOOL', use MarshalAs(UnmanagedType.Bool). For a 1-byte C++ 'bool', use MarshalAs(UnmanagedType.U1).</source>
        <target state="translated">Agregue el atributo MarshalAsAttribute al tipo de devolución de P/Invoke {0}. Si el correspondiente tipo de devolución sin asignar es un "BOOL" de Win32 de 4 bytes, utilice [MarshalAs(UnmanagedType.Bool)]. Para un valor "bool" de C++ de 1 byte, utilice MarshalAs(UnmanagedType.U1).</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
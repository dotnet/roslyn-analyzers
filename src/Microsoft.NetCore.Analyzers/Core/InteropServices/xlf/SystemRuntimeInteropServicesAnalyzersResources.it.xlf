<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="it" original="../SystemRuntimeInteropServicesAnalyzersResources.resx">
    <body>
      <trans-unit id="PInvokesShouldNotBeVisibleTitle">
        <source>P/Invokes should not be visible</source>
        <target state="translated">I metodi P/Invoke non devono essere visibili</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokesShouldNotBeVisibleDescription">
        <source>A public or protected method in a public type has the System.Runtime.InteropServices.DllImportAttribute attribute (also implemented by the Declare keyword in Visual Basic). Such methods should not be exposed.</source>
        <target state="translated">Un metodo public o protected in un tipo public contiene l'attributo System.Runtime.InteropServices.DllImportAttribute (implementato anche dalla parola chiave Declare in Visual Basic). Questi metodi non devono essere esposti.</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokesShouldNotBeVisibleMessage">
        <source>P/Invoke method '{0}' should not be visible</source>
        <target state="translated">Il metodo P/Invoke '{0}' non deve essere visibile</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokeDeclarationsShouldBePortableTitle">
        <source>PInvoke declarations should be portable</source>
        <target state="translated">Le dichiarazioni PInvoke devono essere portabili</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokeDeclarationsShouldBePortableDescription">
        <source>This rule evaluates the size of each parameter and the return value of a P/Invoke, and verifies that the size of the parameter is correct when marshaled to unmanaged code on 32-bit and 64-bit operating systems.</source>
        <target state="translated">Questa regola valuta le dimensioni di ogni parametro e il valore restituito di un metodo P/Invoke e verifica che le dimensioni del parametro siano corrette quando viene eseguito il marshalling a codice non gestito in sistemi operativi a 32 e a 64 bit.</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokeDeclarationsShouldBePortableMessageParameter">
        <source>As it is declared in your code, parameter {0} of P/Invoke {1} will be {2} bytes wide on {3} platforms. This is not correct, as the actual native declaration of this API indicates it should be {4} bytes wide on {3} platforms. Consult the MSDN Platform SDK documentation for help determining what data type should be used instead of {5}.</source>
        <target state="translated">Come dichiarato nel codice, il valore del parametro {0} di P/Invoke {1} sarà pari a {2} byte sulle piattaforme {3}. Questo non è corretto perché l'effettiva dichiarazione nativa di questa API indica che deve essere pari a {4} byte sulle piattaforme {3}. Consultare la documentazione di MSDN Platform SDK per informazioni su come determinare il tipo di dati da usare al posto di {5}.</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokeDeclarationsShouldBePortableMessageReturn">
        <source>As it is declared in your code, the return type of P/Invoke {0} will be {1} bytes wide on {2} platforms. This is not correct, as the actual native declaration of this API indicates it should be {3} bytes wide on {2} platforms. Consult the MSDN Platform SDK documentation for help determining what data type should be used instead of {4}.</source>
        <target state="translated">Come dichiarato nel codice, il valore del tipo restituito di P/Invoke {0} sarà pari a {1} byte sulle piattaforme {2}. Questo non è corretto perché l'effettiva dichiarazione nativa di questa API indica che deve essere pari a {3} byte sulle piattaforme {2}. Consultare la documentazione di MSDN Platform SDK per informazioni su come determinare il tipo di dati da usare al posto di {4}.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsTitle">
        <source>Specify marshaling for P/Invoke string arguments</source>
        <target state="translated">Specificare il marshalling per gli argomenti stringa P/Invoke</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsDescription">
        <source>A platform invoke member allows partially trusted callers, has a string parameter, and does not explicitly marshal the string. This can cause a potential security vulnerability.</source>
        <target state="translated">Un membro di platform invoke consente chiamanti parzialmente attendibili, include un parametro di tipo stringa e non esegue il marshalling della stringa. Questo può comportare una potenziale vulnerabilità di sicurezza.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsMessageParameter">
        <source>To reduce security risk, marshal parameter {0} as Unicode, by setting DllImport.CharSet to CharSet.Unicode, or by explicitly marshaling the parameter as UnmanagedType.LPWStr. If you need to marshal this string as ANSI or system-dependent, set BestFitMapping=false; for added security, also set ThrowOnUnmappableChar=true.</source>
        <target state="translated">Per ridurre i problemi di sicurezza, eseguire il marshalling del parametro {0} come Unicode impostando DllImport.CharSet su CharSet.Unicode o eseguendo in modo esplicito il marshalling del parametro come UnmanagedType.LPWStr. Se è necessario eseguire il marshalling della stringa come ANSI o dipendente da sistema, impostare BestFitMapping=false. Per maggiore sicurezza, impostare anche ThrowOnUnmappableChar=true.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsMessageField">
        <source>To reduce security risk, marshal field {0} as Unicode, by setting StructLayout.CharSet on {1} to CharSet.Unicode, or by explicitly marshaling the field as UnmanagedType.LPWStr. If you need to marshal this string as ANSI or system-dependent, use the BestFitMapping attribute to turn best-fit mapping off, and for added security, ensure ThrowOnUnmappableChar is on.</source>
        <target state="translated">Per ridurre i problemi di sicurezza, eseguire il marshalling del campo {0} come Unicode impostando StructLayout.CharSet in {1} su CharSet.Unicode o eseguendo in modo esplicito il marshalling del campo come UnmanagedType.LPWStr. Se è necessario eseguire il marshalling della stringa come ANSI o dipendente da sistema, usare l'attributo BestFitMapping per disattivare il mapping più appropriato. Per maggiore sicurezza, assicurarsi che ThrowOnUnmappableChar sia attivato.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsMessageParameterImplicitAnsi">
        <source>To reduce security risk, marshal parameter {0} as Unicode, by setting DllImport.CharSet to CharSet.Unicode, or by explicitly marshaling the parameter as UnmanagedType.LPWStr. If you need to marshal this string as ANSI or system-dependent, specify MarshalAs explicitly, and set BestFitMapping=false; for added security, also set ThrowOnUnmappableChar=true.</source>
        <target state="translated">Per ridurre i problemi di sicurezza, eseguire il marshalling del parametro {0} come Unicode impostando DllImport.CharSet su CharSet.Unicode o eseguendo in modo esplicito il marshalling del parametro come UnmanagedType.LPWStr. Se è necessario eseguire il marshalling della stringa come ANSI o dipendente da sistema, specificare in modo esplicito MarshalAs e impostare BestFitMapping=false. Per maggiore sicurezza, impostare anche ThrowOnUnmappableChar=true.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsMessageFieldImplicitAnsi">
        <source>To reduce security risk, marshal field {0} as Unicode, by setting StructLayout.CharSet on {1} to CharSet.Unicode, or by explicitly marshaling the field as UnmanagedType.LPWStr. If you need to marshal this string as ANSI or system-dependent, specify MarshalAs explicitly, use the BestFitMapping attribute to turn best-fit mapping off, and for added security, to turn ThrowOnUnmappableChar on.</source>
        <target state="translated">Per ridurre i problemi di sicurezza, eseguire il marshalling del campo {0} come Unicode impostando StructLayout.CharSet in {1} su CharSet.Unicode o eseguendo in modo esplicito il marshalling del campo come UnmanagedType.LPWStr. Per eseguire il marshalling della stringa come ANSI o dipendente da sistema, specificare in modo esplicito MarshalAs, usare l'attributo BestFitMapping per disattivare il mapping più appropriato. Per maggiore sicurezza, assicurarsi che ThrowOnUnmappableChar sia attivato.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseManagedEquivalentsOfWin32ApiTitle">
        <source>Use managed equivalents of win32 api</source>
        <target state="translated">Usare equivalenti gestiti dell'API Win32</target>
        <note />
      </trans-unit>
      <trans-unit id="UseManagedEquivalentsOfWin32ApiDescription">
        <source>An operating system invoke method is defined and a method that has the equivalent functionality is located in the .NET Framework class library.</source>
        <target state="translated">Viene definito un metodo di chiamata del sistema operativo e nella libreria di classi .NET Framework è presente un metodo con funzionalità equivalente.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseManagedEquivalentsOfWin32ApiMessage">
        <source>Use managed equivalents of win32 api</source>
        <target state="translated">Usare equivalenti gestiti dell'API Win32</target>
        <note />
      </trans-unit>
      <trans-unit id="AlwaysConsumeTheValueReturnedByMethodsMarkedWithPreserveSigAttributeTitle">
        <source>Always consume the value returned by methods marked with PreserveSigAttribute</source>
        <target state="translated">Utilizzare sempre il valore restituito da metodi contrassegnati con PreserveSigAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="AlwaysConsumeTheValueReturnedByMethodsMarkedWithPreserveSigAttributeDescription">
        <source>PreserveSigAttribute indicates that a method will return an HRESULT, rather than throwing an exception. Therefore, it is important to consume the HRESULT returned by the method, so that errors can be detected. Generally, this is done by calling Marshal.ThrowExceptionForHR.</source>
        <target state="translated">PreserveSigAttribute indica che un metodo restituirà un HRESULT, invece di generare un'eccezione. È quindi importante utilizzare l'HRESULT restituito dal metodo in modo da consentire il rilevamento degli errori. In genere, per eseguire questa operazione si chiama Marshal.ThrowExceptionForHR.</target>
        <note />
      </trans-unit>
      <trans-unit id="AlwaysConsumeTheValueReturnedByMethodsMarkedWithPreserveSigAttributeMessage">
        <source>Consume the hresult returned by method '{0}' and call Marshal.ThrowExceptionForHR.</source>
        <target state="translated">Utilizzare l'HRESULT restituito dal metodo '{0}' e chiamare Marshal.ThrowExceptionForHR.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsTitle">
        <source>Mark boolean PInvoke arguments with MarshalAs</source>
        <target state="translated">Contrassegnare gli argomenti di PInvoke booleani con MarshalAs</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsDescription">
        <source>The Boolean data type has multiple representations in unmanaged code.</source>
        <target state="translated">Per il tipo di dati booleano sono disponibili più rappresentazioni nel codice non gestito.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsMessageDefault">
        <source>Add the MarshalAsAttribute to parameter {0} of P/Invoke {1}. If the corresponding unmanaged parameter is a 4-byte Win32 'BOOL', use [MarshalAs(UnmanagedType.Bool)]. For a 1-byte C++ 'bool', use MarshalAs(UnmanagedType.U1).</source>
        <target state="translated">Aggiungere MarshalAsAttribute al parametro {0} di P/Invoke {1}. Se il valore del parametro non gestito corrispondente è di tipo 'BOOL' Win32 a 4 byte, usare [MarshalAs(UnmanagedType.Bool)]. Per un valore di tipo 'bool' C++ a 1 byte, usare MarshalAs(UnmanagedType.U1).</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsMessageReturn">
        <source>Add the MarshalAsAttribute to the return type of P/Invoke {0}. If the corresponding unmanaged return type is a 4-byte Win32 'BOOL', use MarshalAs(UnmanagedType.Bool). For a 1-byte C++ 'bool', use MarshalAs(UnmanagedType.U1).</source>
        <target state="translated">Aggiungere MarshalAsAttribute al tipo restituito di P/Invoke {0}. Se il valore del tipo restituito non gestito corrispondente è di tipo 'BOOL' Win32 a 4 byte, usare MarshalAs(UnmanagedType.Bool). Per un valore di tipo 'bool' C++ a 1 byte, usare MarshalAs(UnmanagedType.U1).</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
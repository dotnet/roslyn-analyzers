<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="pl" original="../SystemRuntimeInteropServicesAnalyzersResources.resx">
    <body>
      <trans-unit id="PInvokesShouldNotBeVisibleTitle">
        <source>P/Invokes should not be visible</source>
        <target state="translated">Elementy P/Invoke nie powinny być widoczne</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokesShouldNotBeVisibleDescription">
        <source>A public or protected method in a public type has the System.Runtime.InteropServices.DllImportAttribute attribute (also implemented by the Declare keyword in Visual Basic). Such methods should not be exposed.</source>
        <target state="translated">Metoda publiczna lub chroniona w typie publicznym ma atrybut System.Runtime.InteropServices.DllImportAttribute (implementowany również przez słowo kluczowe Declare w języku Visual Basic). Takie metody nie powinny być ujawniane.</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokesShouldNotBeVisibleMessage">
        <source>P/Invoke method '{0}' should not be visible</source>
        <target state="translated">Metoda P/Invoke {0} nie powinna być widoczna.</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokeDeclarationsShouldBePortableTitle">
        <source>PInvoke declarations should be portable</source>
        <target state="translated">Deklaracje metody PInvoke powinny być przenośne</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokeDeclarationsShouldBePortableDescription">
        <source>This rule evaluates the size of each parameter and the return value of a P/Invoke, and verifies that the size of the parameter is correct when marshaled to unmanaged code on 32-bit and 64-bit operating systems.</source>
        <target state="translated">Ta reguła wylicza rozmiar poszczególnych parametrów i zwraca wartość metody P/Invoke oraz sprawdza, czy rozmiar parametru jest prawidłowy, gdy jest kierowany do kodu niezarządzanego w 32- i 64-bitowych systemach operacyjnych.</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokeDeclarationsShouldBePortableMessageParameter">
        <source>As it is declared in your code, parameter {0} of P/Invoke {1} will be {2} bytes wide on {3} platforms. This is not correct, as the actual native declaration of this API indicates it should be {4} bytes wide on {3} platforms. Consult the MSDN Platform SDK documentation for help determining what data type should be used instead of {5}.</source>
        <target state="translated">Zgodnie z deklaracją w kodzie, parametr {0} metody P/Invoke {1} będzie mieć szerokość {2} bajtów na platformach: {3}. Ta wartość jest niepoprawna, ponieważ rzeczywista natywna deklaracja tego interfejsu API wskazuje, że powinien on mieć szerokość {4} bajtów na platformach {3}. Pomoc dotyczącą określania typu danych, którego należy użyć zamiast {5}, zawiera dokumentacja zestawu SDK platformy MSDN.</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokeDeclarationsShouldBePortableMessageReturn">
        <source>As it is declared in your code, the return type of P/Invoke {0} will be {1} bytes wide on {2} platforms. This is not correct, as the actual native declaration of this API indicates it should be {3} bytes wide on {2} platforms. Consult the MSDN Platform SDK documentation for help determining what data type should be used instead of {4}.</source>
        <target state="translated">Zgodnie z deklaracją w kodzie typ zwracany metody P/Invoke {0} będzie mieć szerokość {1} bajtów na platformach {2}. Ta wartość jest niepoprawna, ponieważ rzeczywista natywna deklaracja tego interfejsu API wskazuje, że powinien on mieć szerokość {3} bajtów na platformach {2}. Pomoc dotyczącą określania typu danych, którego należy użyć zamiast {4}, zawiera dokumentacja zestawu SDK platformy MSDN.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsTitle">
        <source>Specify marshaling for P/Invoke string arguments</source>
        <target state="translated">Określ kierowanie dla argumentów ciągu P/Invoke</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsDescription">
        <source>A platform invoke member allows partially trusted callers, has a string parameter, and does not explicitly marshal the string. This can cause a potential security vulnerability.</source>
        <target state="translated">Element członkowski wywołania platformy zezwala na częściowo zaufany kod wywołujący, ma parametr ciągu i nie kieruje jawnie łańcuchem. Może to być przyczyną potencjalnej luki w zabezpieczeniach.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsMessageParameter">
        <source>To reduce security risk, marshal parameter {0} as Unicode, by setting DllImport.CharSet to CharSet.Unicode, or by explicitly marshaling the parameter as UnmanagedType.LPWStr. If you need to marshal this string as ANSI or system-dependent, set BestFitMapping=false; for added security, also set ThrowOnUnmappableChar=true.</source>
        <target state="translated">Aby ograniczyć ryzyko związane z zabezpieczeniami, kieruj parametr {0} w kodowaniu Unicode przez ustawienie właściwości DllImport.CharSet na wartość CharSet.Unicode lub przez jawne kierowanie parametru jako typu UnmanagedType.LPWStr. Jeśli musisz kierować ten ciąg w kodowaniu ANSI lub zależnym od systemu, ustaw wartość BestFitMapping=false. Aby zwiększyć bezpieczeństwo, ustaw również wartość ThrowOnUnmappableChar=true.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsMessageField">
        <source>To reduce security risk, marshal field {0} as Unicode, by setting StructLayout.CharSet on {1} to CharSet.Unicode, or by explicitly marshaling the field as UnmanagedType.LPWStr. If you need to marshal this string as ANSI or system-dependent, use the BestFitMapping attribute to turn best-fit mapping off, and for added security, ensure ThrowOnUnmappableChar is on.</source>
        <target state="translated">Aby ograniczyć ryzyko związane z zabezpieczeniami, kieruj pole {0} w kodowaniu Unicode przez ustawienie właściwości StructLayout.CharSet w elemencie {1} na wartość CharSet.Unicode lub przez jawne kierowanie pola jako typu UnmanagedType.LPWStr. Jeśli musisz kierować ten ciąg w kodowaniu ANSI lub zależnym od systemu, użyj atrybutu BestFitMapping, aby wyłączyć mapowanie najlepszego dopasowania. Aby zwiększyć bezpieczeństwo, upewnij się również, że właściwość ThrowOnUnmappableChar jest włączona.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsMessageParameterImplicitAnsi">
        <source>To reduce security risk, marshal parameter {0} as Unicode, by setting DllImport.CharSet to CharSet.Unicode, or by explicitly marshaling the parameter as UnmanagedType.LPWStr. If you need to marshal this string as ANSI or system-dependent, specify MarshalAs explicitly, and set BestFitMapping=false; for added security, also set ThrowOnUnmappableChar=true.</source>
        <target state="translated">Aby ograniczyć ryzyko związane z zabezpieczeniami, kieruj parametr {0} w kodowaniu Unicode przez ustawienie właściwości DllImport.CharSet na wartość CharSet.Unicode lub przez jawne kierowanie parametru jako typu UnmanagedType.LPWStr. Jeśli musisz kierować ten ciąg w kodowaniu ANSI lub zależnym od systemu, określ jawnie atrybut MarshalAs i ustaw wartość BestFitMapping=false. Aby zwiększyć bezpieczeństwo, ustaw również wartość ThrowOnUnmappableChar=true.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsMessageFieldImplicitAnsi">
        <source>To reduce security risk, marshal field {0} as Unicode, by setting StructLayout.CharSet on {1} to CharSet.Unicode, or by explicitly marshaling the field as UnmanagedType.LPWStr. If you need to marshal this string as ANSI or system-dependent, specify MarshalAs explicitly, use the BestFitMapping attribute to turn best-fit mapping off, and for added security, to turn ThrowOnUnmappableChar on.</source>
        <target state="translated">Aby ograniczyć ryzyko związane z zabezpieczeniami, kieruj pole {0} w kodowaniu Unicode przez ustawienie właściwości StructLayout.CharSet w elemencie {1} na wartość CharSet.Unicode lub przez jawne kierowanie pola jako typu UnmanagedType.LPWStr. Jeśli musisz kierować ten ciąg w kodowaniu ANSI lub zależnym od systemu, określ jawnie atrybut MarshalAs i użyj atrybutu BestFitMapping, aby wyłączyć mapowanie najlepszego dopasowania. Aby zwiększyć bezpieczeństwo, upewnij się również, że właściwość ThrowOnUnmappableChar jest włączona.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseManagedEquivalentsOfWin32ApiTitle">
        <source>Use managed equivalents of win32 api</source>
        <target state="translated">Używaj zarządzanych odpowiedników funkcji win32 api</target>
        <note />
      </trans-unit>
      <trans-unit id="UseManagedEquivalentsOfWin32ApiDescription">
        <source>An operating system invoke method is defined and a method that has the equivalent functionality is located in the .NET Framework class library.</source>
        <target state="translated">Metoda wywoływania systemu operacyjnego jest zdefiniowana, a metoda mająca odpowiadającą jej funkcję znajduje się w bibliotece klas platformy .NET Framework.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseManagedEquivalentsOfWin32ApiMessage">
        <source>Use managed equivalents of win32 api</source>
        <target state="translated">Używaj zarządzanych odpowiedników funkcji win32 api</target>
        <note />
      </trans-unit>
      <trans-unit id="AlwaysConsumeTheValueReturnedByMethodsMarkedWithPreserveSigAttributeTitle">
        <source>Always consume the value returned by methods marked with PreserveSigAttribute</source>
        <target state="translated">Zawsze używaj wartości zwracanej przez metody oznaczone klasą PreserveSigAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="AlwaysConsumeTheValueReturnedByMethodsMarkedWithPreserveSigAttributeDescription">
        <source>PreserveSigAttribute indicates that a method will return an HRESULT, rather than throwing an exception. Therefore, it is important to consume the HRESULT returned by the method, so that errors can be detected. Generally, this is done by calling Marshal.ThrowExceptionForHR.</source>
        <target state="translated">Klasa PreserveSigAttribute oznacza, że metoda zwróci wartość HRESULT, zamiast zgłosić wyjątek. Dlatego jest istotne, aby używać wartości HRESULT zwracanej przez metodę, aby móc wykrywać błędy. Zwykle można to zrobić, wywołując metodę Marshal.ThrowExceptionForHR.</target>
        <note />
      </trans-unit>
      <trans-unit id="AlwaysConsumeTheValueReturnedByMethodsMarkedWithPreserveSigAttributeMessage">
        <source>Consume the hresult returned by method '{0}' and call Marshal.ThrowExceptionForHR.</source>
        <target state="translated">Użyj wartości hresult zwracanej przez metodę „{0}” i wywołaj metodę Marshal.ThrowExceptionForHR.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsTitle">
        <source>Mark boolean PInvoke arguments with MarshalAs</source>
        <target state="translated">Oznacz argumenty typu boolean elementu PInvoke argumentem MarshalAs</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsDescription">
        <source>The Boolean data type has multiple representations in unmanaged code.</source>
        <target state="translated">Typ danych boolean ma wiele reprezentacji w kodzie niezarządzanym.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsMessageDefault">
        <source>Add the MarshalAsAttribute to parameter {0} of P/Invoke {1}. If the corresponding unmanaged parameter is a 4-byte Win32 'BOOL', use [MarshalAs(UnmanagedType.Bool)]. For a 1-byte C++ 'bool', use MarshalAs(UnmanagedType.U1).</source>
        <target state="translated">Dodaj atrybut MarshalAsAttribute do parametru {0} elementu P/Invoke {1}. Jeśli odpowiadającym parametrem niezarządzanym jest 4-bajtowy typ BOOL środowiska Win32, użyj wartości [MarshalAs(UnmanagedType.Bool)]. W przypadku 1-bajtowego typu bool języka C++ użyj wartości MarshalAs(UnmanagedType.U1).</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsMessageReturn">
        <source>Add the MarshalAsAttribute to the return type of P/Invoke {0}. If the corresponding unmanaged return type is a 4-byte Win32 'BOOL', use MarshalAs(UnmanagedType.Bool). For a 1-byte C++ 'bool', use MarshalAs(UnmanagedType.U1).</source>
        <target state="translated">Dodaj atrybut MarshalAsAttribute do typu zwracanego elementu P/Invoke {0}. Jeśli odpowiadającym niezarządzanym typem zwracanym jest 4-bajtowy typ BOOL środowiska Win32, użyj wartości [MarshalAs(UnmanagedType.Bool)]. W przypadku 1-bajtowego typu bool języka C++ użyj wartości MarshalAs(UnmanagedType.U1).</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
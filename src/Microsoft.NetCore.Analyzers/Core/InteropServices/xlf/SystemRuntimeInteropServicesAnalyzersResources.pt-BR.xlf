<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="pt-BR" original="../SystemRuntimeInteropServicesAnalyzersResources.resx">
    <body>
      <trans-unit id="PInvokesShouldNotBeVisibleTitle">
        <source>P/Invokes should not be visible</source>
        <target state="translated">P/Invokes não deve ser visível</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokesShouldNotBeVisibleDescription">
        <source>A public or protected method in a public type has the System.Runtime.InteropServices.DllImportAttribute attribute (also implemented by the Declare keyword in Visual Basic). Such methods should not be exposed.</source>
        <target state="translated">Um método público ou protegido em um tipo público tem o atributo System.Runtime.InteropServices.DllImportAttribute (implementado também pela palavra-chave Declare no Visual Basic). Esses métodos não devem ser expostos.</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokesShouldNotBeVisibleMessage">
        <source>P/Invoke method '{0}' should not be visible</source>
        <target state="translated">O método P/Invoke '{0}' não deve ser visível</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokeDeclarationsShouldBePortableTitle">
        <source>PInvoke declarations should be portable</source>
        <target state="translated">Declarações PInvoke devem ser portáveis</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokeDeclarationsShouldBePortableDescription">
        <source>This rule evaluates the size of each parameter and the return value of a P/Invoke, and verifies that the size of the parameter is correct when marshaled to unmanaged code on 32-bit and 64-bit operating systems.</source>
        <target state="translated">Essa regra avalia o tamanho de cada parâmetro e o valor retornado de um P/Invoke e verifica se o tamanho do parâmetro está correto quando o marshaling foi realizado no código não gerenciado em sistemas operacionais de 32 bits e 64 bits.</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokeDeclarationsShouldBePortableMessageParameter">
        <source>As it is declared in your code, parameter {0} of P/Invoke {1} will be {2} bytes wide on {3} platforms. This is not correct, as the actual native declaration of this API indicates it should be {4} bytes wide on {3} platforms. Consult the MSDN Platform SDK documentation for help determining what data type should be used instead of {5}.</source>
        <target state="translated">Conforme declarado em seu código, o parâmetro {0} de P/Invoke {1} terá {2} bytes nas plataformas {3}. Isso não está correto, já que a declaração nativa real desta API indica que ele deve ter {4} bytes nas plataformas {3}. Consulte a documentação do SDK da Plataforma MSDN para obter ajuda para determinar que tipo de dados deve ser usado em vez de {5}.</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokeDeclarationsShouldBePortableMessageReturn">
        <source>As it is declared in your code, the return type of P/Invoke {0} will be {1} bytes wide on {2} platforms. This is not correct, as the actual native declaration of this API indicates it should be {3} bytes wide on {2} platforms. Consult the MSDN Platform SDK documentation for help determining what data type should be used instead of {4}.</source>
        <target state="translated">Conforme declarado em seu código, o tipo de retorno de P/Invoke {0} terá {1} bytes nas plataformas {2}. Isso não está correto, já que a declaração nativa real desta API indica que ele deve ter {3} bytes nas plataformas {2}. Consulte a documentação do SDK da Plataforma MSDN para obter ajuda para determinar que tipo de dados deve ser usado em vez de {4}.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsTitle">
        <source>Specify marshaling for P/Invoke string arguments</source>
        <target state="translated">Especificar marshaling para argumentos de cadeias de caracteres P/Invoke</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsDescription">
        <source>A platform invoke member allows partially trusted callers, has a string parameter, and does not explicitly marshal the string. This can cause a potential security vulnerability.</source>
        <target state="translated">Um membro de invocação de plataforma permite chamadores parcialmente confiáveis, tem um parâmetro de cadeia de caracteres e não realiza marshaling da cadeia de caracteres explicitamente. Isso pode causar uma potencial vulnerabilidade de segurança.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsMessageParameter">
        <source>To reduce security risk, marshal parameter {0} as Unicode, by setting DllImport.CharSet to CharSet.Unicode, or by explicitly marshaling the parameter as UnmanagedType.LPWStr. If you need to marshal this string as ANSI or system-dependent, set BestFitMapping=false; for added security, also set ThrowOnUnmappableChar=true.</source>
        <target state="translated">Para reduzir o risco de segurança, realize marshaling do parâmetro {0} como Unicode, definindo DllImport.CharSet como CharSet.Unicode ou realizando marshaling do parâmetro explicitamente como UnmanagedType.LPWStr. Se você precisar realizar marshaling dessa cadeia de caracteres como ANSI ou dependente do sistema, defina BestFitMapping=false; para maior segurança, também defina ThrowOnUnmappableChar=true.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsMessageField">
        <source>To reduce security risk, marshal field {0} as Unicode, by setting StructLayout.CharSet on {1} to CharSet.Unicode, or by explicitly marshaling the field as UnmanagedType.LPWStr. If you need to marshal this string as ANSI or system-dependent, use the BestFitMapping attribute to turn best-fit mapping off, and for added security, ensure ThrowOnUnmappableChar is on.</source>
        <target state="translated">Para reduzir o risco de segurança, realize marshaling do campo {0} como Unicode, definindo StructLayout.CharSet em {1} como CharSet.Unicode ou realizando marshaling do campo explicitamente como UnmanagedType.LPWStr. Se você precisar realizar marshaling dessa cadeia de caracteres como ANSI ou dependente do sistema, use o atributo BestFitMapping para desativar o mapeamento de melhor ajuste e para maior segurança, ative ThrowOnUnmappableChar.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsMessageParameterImplicitAnsi">
        <source>To reduce security risk, marshal parameter {0} as Unicode, by setting DllImport.CharSet to CharSet.Unicode, or by explicitly marshaling the parameter as UnmanagedType.LPWStr. If you need to marshal this string as ANSI or system-dependent, specify MarshalAs explicitly, and set BestFitMapping=false; for added security, also set ThrowOnUnmappableChar=true.</source>
        <target state="translated">Para reduzir o risco de segurança, realize marshaling do parâmetro {0} como Unicode, definindo DllImport.CharSet como CharSet.Unicode ou realizando marshaling do parâmetro explicitamente como UnmanagedType.LPWStr. Se você precisar realizar marshaling dessa cadeia de caracteres como ANSI ou dependente do sistema, especifique MarshalAs explicitamente e defina BestFitMapping=false; para maior segurança, também defina ThrowOnUnmappableChar=true.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsMessageFieldImplicitAnsi">
        <source>To reduce security risk, marshal field {0} as Unicode, by setting StructLayout.CharSet on {1} to CharSet.Unicode, or by explicitly marshaling the field as UnmanagedType.LPWStr. If you need to marshal this string as ANSI or system-dependent, specify MarshalAs explicitly, use the BestFitMapping attribute to turn best-fit mapping off, and for added security, to turn ThrowOnUnmappableChar on.</source>
        <target state="translated">Para reduzir o risco de segurança, realize marshaling do campo {0} como Unicode, definindo StructLayout.CharSet em {1} como CharSet.Unicode ou realizando marshaling do campo explicitamente como UnmanagedType.LPWStr. Se você precisar realizar marshaling dessa cadeia de caracteres como ANSI ou dependente do sistema, especifique MarshalAs explicitamente, use o atributo BestFitMapping para desativar o mapeamento de melhor ajuste e para maior segurança, ative ThrowOnUnmappableChar.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseManagedEquivalentsOfWin32ApiTitle">
        <source>Use managed equivalents of win32 api</source>
        <target state="translated">Usar equivalentes gerenciados da API win32</target>
        <note />
      </trans-unit>
      <trans-unit id="UseManagedEquivalentsOfWin32ApiDescription">
        <source>An operating system invoke method is defined and a method that has the equivalent functionality is located in the .NET Framework class library.</source>
        <target state="translated">Um método de invocação de sistema operacional é definido e um método que tem a funcionalidade equivalente está localizado na biblioteca de classes .NET Framework.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseManagedEquivalentsOfWin32ApiMessage">
        <source>Use managed equivalents of win32 api</source>
        <target state="translated">Usar equivalentes gerenciados da API win32</target>
        <note />
      </trans-unit>
      <trans-unit id="AlwaysConsumeTheValueReturnedByMethodsMarkedWithPreserveSigAttributeTitle">
        <source>Always consume the value returned by methods marked with PreserveSigAttribute</source>
        <target state="translated">Sempre consuma o valor retornado por métodos marcados com PreserveSigAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="AlwaysConsumeTheValueReturnedByMethodsMarkedWithPreserveSigAttributeDescription">
        <source>PreserveSigAttribute indicates that a method will return an HRESULT, rather than throwing an exception. Therefore, it is important to consume the HRESULT returned by the method, so that errors can be detected. Generally, this is done by calling Marshal.ThrowExceptionForHR.</source>
        <target state="translated">PreserveSigAttribute indica que um método retornará um HRESULT, em vez de gerar uma exceção. Portanto, é importante consumir o HRESULT retornado pelo método, para que os erros possam ser detectados. Geralmente, isso é feito chamando Marshal.ThrowExceptionForHR.</target>
        <note />
      </trans-unit>
      <trans-unit id="AlwaysConsumeTheValueReturnedByMethodsMarkedWithPreserveSigAttributeMessage">
        <source>Consume the hresult returned by method '{0}' and call Marshal.ThrowExceptionForHR.</source>
        <target state="translated">Consuma o hresult retornado pelo método '{0}' e chame Marshal.ThrowExceptionForHR.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsTitle">
        <source>Mark boolean PInvoke arguments with MarshalAs</source>
        <target state="translated">Marcar argumentos PInvoke boolianos com MarshalAs</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsDescription">
        <source>The Boolean data type has multiple representations in unmanaged code.</source>
        <target state="translated">O tipo de dados Boolean tem várias representações no código não gerenciado.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsMessageDefault">
        <source>Add the MarshalAsAttribute to parameter {0} of P/Invoke {1}. If the corresponding unmanaged parameter is a 4-byte Win32 'BOOL', use [MarshalAs(UnmanagedType.Bool)]. For a 1-byte C++ 'bool', use MarshalAs(UnmanagedType.U1).</source>
        <target state="translated">Adicione o MarshalAsAttribute ao parâmetro {0} de P/Invoke {1}. Se o parâmetro não gerenciado correspondente for 'BOOL' do Win32 de 4 bytes, use [MarshalAs(UnmanagedType.Bool)]. Para 'bool' do C++ de 1 byte, use MarshalAs(UnmanagedType.U1).</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsMessageReturn">
        <source>Add the MarshalAsAttribute to the return type of P/Invoke {0}. If the corresponding unmanaged return type is a 4-byte Win32 'BOOL', use MarshalAs(UnmanagedType.Bool). For a 1-byte C++ 'bool', use MarshalAs(UnmanagedType.U1).</source>
        <target state="translated">Adicione o MarshalAsAttribute ao tipo de retorno de P/Invoke {0}. Se o tipo de retorno não gerenciado correspondente for 'BOOL' do Win32 de 4 bytes, use MarshalAs(UnmanagedType.Bool). Para 'bool' do C++ de 1 byte, use MarshalAs(UnmanagedType.U1).</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
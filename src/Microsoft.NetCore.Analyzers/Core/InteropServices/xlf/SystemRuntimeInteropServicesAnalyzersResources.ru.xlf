<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ru" original="../SystemRuntimeInteropServicesAnalyzersResources.resx">
    <body>
      <trans-unit id="PInvokesShouldNotBeVisibleTitle">
        <source>P/Invokes should not be visible</source>
        <target state="translated">Методы P/Invoke не должны быть видимыми</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokesShouldNotBeVisibleDescription">
        <source>A public or protected method in a public type has the System.Runtime.InteropServices.DllImportAttribute attribute (also implemented by the Declare keyword in Visual Basic). Such methods should not be exposed.</source>
        <target state="translated">Общий или защищенный метод в общем типе имеет атрибут System.Runtime.InteropServices.DllImportAttribute (также реализуемый ключевым словом Declare в Visual Basic). Предоставлять такие методы не следует.</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokesShouldNotBeVisibleMessage">
        <source>P/Invoke method '{0}' should not be visible</source>
        <target state="translated">Метод P/Invoke "{0}" не должен быть видимым</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokeDeclarationsShouldBePortableTitle">
        <source>PInvoke declarations should be portable</source>
        <target state="translated">Объявления PInvoke должны быть переносимыми</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokeDeclarationsShouldBePortableDescription">
        <source>This rule evaluates the size of each parameter and the return value of a P/Invoke, and verifies that the size of the parameter is correct when marshaled to unmanaged code on 32-bit and 64-bit operating systems.</source>
        <target state="translated">Это правило оценивает каждый параметр и возвращает значение P/Invoke, а затем проверяет правильность размера параметра при маршалировании в неуправляемый код на 32- и 64-разрядных операционных системах.</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokeDeclarationsShouldBePortableMessageParameter">
        <source>As it is declared in your code, parameter {0} of P/Invoke {1} will be {2} bytes wide on {3} platforms. This is not correct, as the actual native declaration of this API indicates it should be {4} bytes wide on {3} platforms. Consult the MSDN Platform SDK documentation for help determining what data type should be used instead of {5}.</source>
        <target state="translated">Как объявлено в вашем коде, параметр {0} для P/Invoke {1} будет иметь размер {2} байт для платформ {3}. Это неправильно, так как текущее объявление в машинном коде для данного API указывает, что его размер должен быть {4} байт для платформ {3}. Обратитесь к документации по пакету SDK для платформы MSDN и выясните, какой тип данных следует использовать вместо {5}.</target>
        <note />
      </trans-unit>
      <trans-unit id="PInvokeDeclarationsShouldBePortableMessageReturn">
        <source>As it is declared in your code, the return type of P/Invoke {0} will be {1} bytes wide on {2} platforms. This is not correct, as the actual native declaration of this API indicates it should be {3} bytes wide on {2} platforms. Consult the MSDN Platform SDK documentation for help determining what data type should be used instead of {4}.</source>
        <target state="translated">Как объявлено в вашем коде, тип возвращаемого значения для P/Invoke {0} будет иметь размер {1} байт для платформ {2}. Это неправильно, так как текущее объявление в машинном коде для данного API указывает, что его размер должен быть {3} байт для платформ {2}. Обратитесь к документации по пакету SDK для платформы MSDN и выясните, какой тип данных следует использовать вместо {4}.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsTitle">
        <source>Specify marshaling for P/Invoke string arguments</source>
        <target state="translated">Укажите маршалинг для строковых аргументов P/Invoke</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsDescription">
        <source>A platform invoke member allows partially trusted callers, has a string parameter, and does not explicitly marshal the string. This can cause a potential security vulnerability.</source>
        <target state="translated">Член вызова неуправляемого кода разрешает вызовы с неполным доверием, имеет строковый параметр и не маршалирует строку явным образом. Это может привести к уязвимости системы безопасности.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsMessageParameter">
        <source>To reduce security risk, marshal parameter {0} as Unicode, by setting DllImport.CharSet to CharSet.Unicode, or by explicitly marshaling the parameter as UnmanagedType.LPWStr. If you need to marshal this string as ANSI or system-dependent, set BestFitMapping=false; for added security, also set ThrowOnUnmappableChar=true.</source>
        <target state="translated">Чтобы уменьшить угрозу безопасности, маршалируйте параметр {0} как Юникод, установив значение CharSet.Unicode для DllImport.CharSet либо явно маршалировав параметр как UnmanagedType.LPWStr. Если необходимо маршалировать эту строку как ANSI или зависящую от системы, установите BestFitMapping=false; для обеспечения дополнительной безопасности также установите ThrowOnUnmappableChar=true.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsMessageField">
        <source>To reduce security risk, marshal field {0} as Unicode, by setting StructLayout.CharSet on {1} to CharSet.Unicode, or by explicitly marshaling the field as UnmanagedType.LPWStr. If you need to marshal this string as ANSI or system-dependent, use the BestFitMapping attribute to turn best-fit mapping off, and for added security, ensure ThrowOnUnmappableChar is on.</source>
        <target state="translated">Чтобы уменьшить угрозу безопасности, маршалируйте поле {0} как Юникод, установив значение StructLayout.CharSet для StructLayout.CharSet в {1} либо явно маршалировав поле как UnmanagedType.LPWStr. Если необходимо маршалировать эту строку как ANSI или зависящую от системы, используйте атрибут BestFitMapping для отключения сопоставления путем автоматического подбора, а также включите параметр ThrowOnUnmappableChar.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsMessageParameterImplicitAnsi">
        <source>To reduce security risk, marshal parameter {0} as Unicode, by setting DllImport.CharSet to CharSet.Unicode, or by explicitly marshaling the parameter as UnmanagedType.LPWStr. If you need to marshal this string as ANSI or system-dependent, specify MarshalAs explicitly, and set BestFitMapping=false; for added security, also set ThrowOnUnmappableChar=true.</source>
        <target state="translated">Чтобы уменьшить угрозу безопасности, маршалируйте параметр {0} как Юникод, установив значение CharSet.Unicode для DllImport.CharSet либо явно маршалировав параметр как UnmanagedType.LPWStr. Если необходимо маршалировать эту строку как ANSI или зависящую от системы, явно укажите MarshalAs и установите BestFitMapping=false; для обеспечения дополнительной безопасности также установите ThrowOnUnmappableChar=true.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMarshalingForPInvokeStringArgumentsMessageFieldImplicitAnsi">
        <source>To reduce security risk, marshal field {0} as Unicode, by setting StructLayout.CharSet on {1} to CharSet.Unicode, or by explicitly marshaling the field as UnmanagedType.LPWStr. If you need to marshal this string as ANSI or system-dependent, specify MarshalAs explicitly, use the BestFitMapping attribute to turn best-fit mapping off, and for added security, to turn ThrowOnUnmappableChar on.</source>
        <target state="translated">Чтобы уменьшить угрозу безопасности, маршалируйте поле {0} как Юникод, установив значение StructLayout.CharSet для StructLayout.CharSet в {1} либо явно маршалировав поле как UnmanagedType.LPWStr. Если необходимо маршалировать эту строку как ANSI или зависящую от системы, явно укажите MarshalAs, используйте атрибут BestFitMapping для отключения сопоставления путем автоматического подбора, а также включите параметр ThrowOnUnmappableChar для обеспечения дополнительной безопасности.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseManagedEquivalentsOfWin32ApiTitle">
        <source>Use managed equivalents of win32 api</source>
        <target state="translated">Используйте управляемые эквиваленты API Win32</target>
        <note />
      </trans-unit>
      <trans-unit id="UseManagedEquivalentsOfWin32ApiDescription">
        <source>An operating system invoke method is defined and a method that has the equivalent functionality is located in the .NET Framework class library.</source>
        <target state="translated">Определен метод вызова операционной системы, а метод с аналогичной функциональностью находится в библиотеке классов платформы .NET Framework.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseManagedEquivalentsOfWin32ApiMessage">
        <source>Use managed equivalents of win32 api</source>
        <target state="translated">Используйте управляемые эквиваленты API Win32</target>
        <note />
      </trans-unit>
      <trans-unit id="AlwaysConsumeTheValueReturnedByMethodsMarkedWithPreserveSigAttributeTitle">
        <source>Always consume the value returned by methods marked with PreserveSigAttribute</source>
        <target state="translated">Всегда используйте значение, которое возвращают методы, помеченные атрибутом PreserveSigAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="AlwaysConsumeTheValueReturnedByMethodsMarkedWithPreserveSigAttributeDescription">
        <source>PreserveSigAttribute indicates that a method will return an HRESULT, rather than throwing an exception. Therefore, it is important to consume the HRESULT returned by the method, so that errors can be detected. Generally, this is done by calling Marshal.ThrowExceptionForHR.</source>
        <target state="translated">PreserveSigAttribute указывает, что метод возвратит HRESULT, а не выдаст исключение. Поэтому важно использовать результат HRESULT, возвращенный этим методом, чтобы можно было обнаружить ошибки. В общем случае для этого служит вызов Marshal.ThrowExceptionForHR.</target>
        <note />
      </trans-unit>
      <trans-unit id="AlwaysConsumeTheValueReturnedByMethodsMarkedWithPreserveSigAttributeMessage">
        <source>Consume the hresult returned by method '{0}' and call Marshal.ThrowExceptionForHR.</source>
        <target state="translated">Используйте HRESULT, возвращенный методом "{0}", и вызовите Marshal.ThrowExceptionForHR.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsTitle">
        <source>Mark boolean PInvoke arguments with MarshalAs</source>
        <target state="translated">Пометьте логические аргументы PInvoke с помощью MarshalAs</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsDescription">
        <source>The Boolean data type has multiple representations in unmanaged code.</source>
        <target state="translated">Логический тип данных имеет несколько представлений в неуправляемом коде.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsMessageDefault">
        <source>Add the MarshalAsAttribute to parameter {0} of P/Invoke {1}. If the corresponding unmanaged parameter is a 4-byte Win32 'BOOL', use [MarshalAs(UnmanagedType.Bool)]. For a 1-byte C++ 'bool', use MarshalAs(UnmanagedType.U1).</source>
        <target state="translated">Добавьте MarshalAsAttribute к параметру {0} P/Invoke {1}. Если соответствующий неуправляемый параметр является 4-байтным Win32 "BOOL", используйте [MarshalAs(UnmanagedType.Bool)]. Для 1-байтного "bool" C++ используйте MarshalAs(UnmanagedType.U1).</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkBooleanPInvokeArgumentsWithMarshalAsMessageReturn">
        <source>Add the MarshalAsAttribute to the return type of P/Invoke {0}. If the corresponding unmanaged return type is a 4-byte Win32 'BOOL', use MarshalAs(UnmanagedType.Bool). For a 1-byte C++ 'bool', use MarshalAs(UnmanagedType.U1).</source>
        <target state="translated">Добавьте MarshalAsAttribute к типу возвращаемого значения P/Invoke {0}. Если соответствующий неуправляемый тип возвращаемого значения является 4-байтным Win32 "BOOL", используйте MarshalAs(UnmanagedType.Bool). Для 1-байтного "bool" C++ используйте MarshalAs(UnmanagedType.U1).</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="cs" original="../SystemRuntimeAnalyzersResources.resx">
    <body>
      <trans-unit id="AddNonSerializedAttributeCodeActionTitle">
        <source>Add the 'NonSerialized' attribute to this field.</source>
        <target state="translated">Přidejte k tomuto poli atribut NonSerialized</target>
        <note />
      </trans-unit>
      <trans-unit id="AddSerializableAttributeCodeActionTitle">
        <source>Add Serializable attribute</source>
        <target state="translated">Přidat atribut Serializable</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeDescription">
        <source>If a disposable object is not explicitly disposed before all references to it are out of scope, the object will be disposed at some indeterminate time when the garbage collector runs the finalizer of the object. Because an exceptional event might occur that will prevent the finalizer of the object from running, the object should be explicitly disposed instead.</source>
        <target state="translated">Pokud uvolnitelný objekt není explicitně uvolněn před tím, než jsou všechny odkazy na něj mimo obor, objekt bude uvolněn v neurčité době, když systém uvolňování paměti spustí finalizační metodu objektu. Protože může dojít k mimořádné události, která zabrání spuštění finalizační metody objektu, měl by být objekt místo toho objekt explicitně uvolněn.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeMayBeDisposedMessage">
        <source>Use recommended dispose pattern to ensure that object created by '{0}' is disposed on all paths. If possible, wrap the creation within a 'using' statement or a 'using' declaration. Otherwise, use a try-finally pattern, with a dedicated local variable declared before the try region and an unconditional Dispose invocation on non-null value in the 'finally' region, say 'x?.Dispose()'. If the object is explicitly disposed within the try region or the dispose ownership is transfered to another object or method, assign 'null' to the local variable just after such an operation to prevent double dispose in 'finally'.</source>
        <target state="translated">Použijte doporučený vzor vyřazení, abyste měli jistotu, že objekt vytvořený pomocí {0} se vyřadí na všech cestách. Pokud je to možné, zabalte vytváření do příkazu nebo deklarace using. Jinak použijte vzor try-finally s vyhrazenou místní proměnnou deklarovanou před oblastí try a nepodmíněným voláním Dispose pro hodnotu, která není null, v oblasti finally, třeba x?.Dispose(). Pokud se objekt explicitně vyřadí v oblasti try nebo se vlastnictví vyřazení převede na jiný objekt nebo metodu, přiřaďte ihned po takové operaci místní proměnné hodnotu null, aby ve finally nedošlo k dvojímu vyřazení.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeMayBeDisposedOnExceptionPathsMessage">
        <source>Use recommended dispose pattern to ensure that object created by '{0}' is disposed on all exception paths. If possible, wrap the creation within a 'using' statement or a 'using' declaration. Otherwise, use a try-finally pattern, with a dedicated local variable declared before the try region and an unconditional Dispose invocation on non-null value in the 'finally' region, say 'x?.Dispose()'. If the object is explicitly disposed within the try region or the dispose ownership is transfered to another object or method, assign 'null' to the local variable just after such an operation to prevent double dispose in 'finally'.</source>
        <target state="translated">Použijte doporučený vzor vyřazení, abyste měli jistotu, že objekt vytvořený pomocí {0} se vyřadí na všech cestách výjimky. Pokud je to možné, zabalte vytváření do příkazu nebo deklarace using. Jinak použijte vzor try-finally s vyhrazenou místní proměnnou deklarovanou před oblastí try a nepodmíněným voláním Dispose pro hodnotu, která není null, v oblasti finally, třeba x?.Dispose(). Pokud se objekt explicitně vyřadí v oblasti try nebo se vlastnictví vyřazení převede na jiný objekt nebo metodu, přiřaďte ihned po takové operaci místní proměnné hodnotu null, aby ve finally nedošlo k dvojímu vyřazení.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeNotDisposedMessage">
        <source>Call System.IDisposable.Dispose on object created by '{0}' before all references to it are out of scope.</source>
        <target state="translated">Zavolejte System.IDisposable.Dispose pro objekt vytvořený pomocí {0} dříve, než budou všechny odkazy na něj mimo obor.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeNotDisposedOnExceptionPathsMessage">
        <source>Object created by '{0}' is not disposed along all exception paths. Call System.IDisposable.Dispose on the object before all references to it are out of scope.</source>
        <target state="translated">Objekt vytvořený pomocí {0} není vyřazený na všech cestách výjimky. Zavolejte System.IDisposable.Dispose pro tento objekt dříve, než budou všechny odkazy na něj mimo obor.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeTitle">
        <source>Dispose objects before losing scope</source>
        <target state="translated">Uvolňujte objekty před ztrátou oboru</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassLiteralsAsLocalizedParametersDescription">
        <source>A method passes a string literal as a parameter to a constructor or method in the .NET Framework class library and that string should be localizable. To fix a violation of this rule, replace the string literal with a string retrieved through an instance of the ResourceManager class.</source>
        <target state="translated">Metoda předává jako parametr do konstruktoru nebo metody v knihovně tříd .NET Framework řetězcový literál, který by měl být lokalizovatelný. Pokud chcete porušení tohoto pravidla opravit, nahraďte řetězcový literál řetězcem načteným přes instanci třídy ResourceManager.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassLiteralsAsLocalizedParametersMessage">
        <source>Method '{0}' passes a literal string as parameter '{1}' of a call to '{2}'. Retrieve the following string(s) from a resource table instead: "{3}".</source>
        <target state="translated">Metoda {0} předává řetězcový literál jako parametr {1} volání {2}. Místo toho načtěte následující řetězce z tabulky prostředků: {3}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassLiteralsAsLocalizedParametersTitle">
        <source>Do not pass literals as localized parameters</source>
        <target state="translated">Nepředávejte literály jako lokalizované parametry</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementISerializableCorrectlyDescription">
        <source>To fix a violation of this rule, make the GetObjectData method visible and overridable, and make sure that all instance fields are included in the serialization process or explicitly marked by using the NonSerializedAttribute attribute.</source>
        <target state="translated">Pokud chcete porušení tohoto pravidla opravit, nastavte metodu GetObjectData jako viditelnou a přepsatelnou a ujistěte se, že všechna pole instance jsou součástí procesu serializace nebo explicitně označená atributem NonSerializedAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementISerializableCorrectlyMessageDefault">
        <source>Add an implementation of GetObjectData to type {0}.</source>
        <target state="translated">Přidejte implementaci GetObjectData k typu {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementISerializableCorrectlyMessageMakeOverridable">
        <source>Make {0}.GetObjectData virtual and overridable.</source>
        <target state="translated">Učiňte {0}.GetObjectData virtuální a přepisovatelnou.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementISerializableCorrectlyMessageMakeVisible">
        <source>Increase the accessibility of {0}.GetObjectData so that it is visible to derived types.</source>
        <target state="translated">Zvýšit přístupnost {0}.GetObjectData tak, že je viditelná pro odvozené typy.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementISerializableCorrectlyTitle">
        <source>Implement ISerializable correctly</source>
        <target state="translated">Implementujte správně ISerializable</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationConstructorsCodeActionTitle">
        <source>Implement Serialization constructor</source>
        <target state="translated">Naimplementovat konstruktor Serialization</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationConstructorsDescription">
        <source>To fix a violation of this rule, implement the serialization constructor. For a sealed class, make the constructor private; otherwise, make it protected.</source>
        <target state="translated">Pokud chcete porušení tohoto pravidla opravit, naimplementujte serializační konstruktor. Pro zapečetěné třídy nastavte konstruktor jako private, jinak jako protected.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationConstructorsMessageCreateMagicConstructor">
        <source>Add a constructor to {0} with the following signature: 'protected {0}(SerializationInfo info, StreamingContext context)'.</source>
        <target state="translated">Přidejte konstruktor k {0} s následující signaturou: 'protected {0}(SerializationInfo info, StreamingContext context)'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationConstructorsMessageMakeSealedMagicConstructorPrivate">
        <source>Declare the serialization constructor of {0}, a sealed type, as private.</source>
        <target state="translated">Deklarujte serializační konstruktor {0}, zapečetěný typ, jako soukromý.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationConstructorsMessageMakeUnsealedMagicConstructorFamily">
        <source>Declare the serialization constructor of {0}, an unsealed type, as protected.</source>
        <target state="translated">Deklarujte serializační konstruktor {0}, zapečetěný typ, jako chráněný.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationConstructorsTitle">
        <source>Implement serialization constructors</source>
        <target state="translated">Implementovat serializační konstruktory</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyDescription">
        <source>A method that handles a serialization event does not have the correct signature, return type, or visibility.</source>
        <target state="translated">Metoda, která zpracovává událost serializace, nemá správnou signaturu, návratový typ nebo viditelnost.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyMessageGeneric">
        <source>Because {0} is marked with OnSerializing, OnSerialized, OnDeserializing, or OnDeserialized, change its signature so that it is no longer generic.</source>
        <target state="translated">Protože {0} je označená pomocí OnSerializing, OnSerialized, OnDeserializing nebo OnDeserialized, změňte její signaturu tak, že již není nadále obecná.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyMessageParameters">
        <source>Because {0} is marked with OnSerializing, OnSerialized, OnDeserializing, or OnDeserialized, change its signature so that it takes a single parameter of type 'System.Runtime.Serialization.StreamingContext'.</source>
        <target state="translated">Protože {0} je označená pomocí OnSerializing, OnSerialized, OnDeserializing nebo OnDeserialized, změňte její signaturu tak, že vyžaduje jeden parametr typu 'System.Runtime.Serialization.StreamingContext'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyMessageReturnType">
        <source>Because {0} is marked with OnSerializing, OnSerialized, OnDeserializing, or OnDeserialized, change its return type from {1} to void (Sub in Visual Basic).</source>
        <target state="translated">Protože {0} je označená pomocí OnSerializing, OnSerialized, OnDeserializing nebo OnDeserialized, změňte její návratový typ z {1} na void (Sub v jazyce Visual Basic).</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyMessageStatic">
        <source>Because {0} is marked with OnSerializing, OnSerialized, OnDeserializing, or OnDeserialized, change it from static (Shared in Visual Basic) to an instance method.</source>
        <target state="translated">Protože {0} je označená pomocí OnSerializing, OnSerialized, OnDeserializing nebo OnDeserialized, změňte ji ze statické (sdílené v jazyce Visual Basic) na instanční metodu.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyMessageVisibility">
        <source>Because {0} is marked with OnSerializing, OnSerialized, OnDeserializing, or OnDeserialized, change its accessibility to private.</source>
        <target state="translated">Protože {0} je označená pomocí OnSerializing, OnSerialized, OnDeserializing nebo OnDeserialized, změňte její přístupnost na soukromou.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyTitle">
        <source>Implement serialization methods correctly</source>
        <target state="translated">Implementujte správně metody serializace</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAllNonSerializableFieldsDescription">
        <source>An instance field of a type that is not serializable is declared in a type that is serializable.</source>
        <target state="translated">Pole instance typu, který se nedá serializovat, je deklarované v typu, který se serializovat dá.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAllNonSerializableFieldsMessage">
        <source>Field {0} is a member of type {1} which is serializable but is of type {2} which is not serializable</source>
        <target state="translated">Pole {0} je členem typu {1}, který je serializovatelný, ale je typu {2}, který serializovatelný není.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAllNonSerializableFieldsTitle">
        <source>Mark all non-serializable fields</source>
        <target state="translated">Označte všechny neserializovatelná pole</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkISerializableTypesWithSerializableDescription">
        <source>To be recognized by the common language runtime as serializable, types must be marked by using the SerializableAttribute attribute even when the type uses a custom serialization routine through implementation of the ISerializable interface.</source>
        <target state="translated">Aby modul CLR (Common Language Runtime) mohl typy rozpoznat jako serializovatelné, musí se tyto typy označit atributem SerializableAttribute, a to i v případě, že typ používá vlastní serializační rutinu prostřednictvím implementace rozhraní ISerializable.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkISerializableTypesWithSerializableMessage">
        <source>Add [Serializable] to {0} as this type implements ISerializable</source>
        <target state="translated">Přidejte [Serializable] k {0}, protože tento typ implementuje ISerializable.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkISerializableTypesWithSerializableTitle">
        <source>Mark ISerializable types with serializable</source>
        <target state="translated">Označit typy ISerializable jako serializable</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideDeserializationMethodsForOptionalFieldsDescription">
        <source>A type has a field that is marked by using the System.Runtime.Serialization.OptionalFieldAttribute attribute, and the type does not provide deserialization event handling methods.</source>
        <target state="translated">Typ má pole, které je označené atributem System.Runtime.Serialization.OptionalFieldAttribute, ale tento typ neposkytuje metody pro zpracování události deserializace.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideDeserializationMethodsForOptionalFieldsMessageOnDeserialized">
        <source>Add a 'private void OnDeserialized(StreamingContext)' method to type {0} and attribute it with the System.Runtime.Serialization.OnDeserializedAttribute.</source>
        <target state="translated">Přidejte metodu 'private void OnDeserialized(StreamingContext)' k typu {0} a označte ji pomocí System.Runtime.Serialization.OnDeserializedAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideDeserializationMethodsForOptionalFieldsMessageOnDeserializing">
        <source>Add a 'private void OnDeserializing(StreamingContext)' method to type {0} and attribute it with the System.Runtime.Serialization.OnDeserializingAttribute.</source>
        <target state="translated">Přidejte metodu 'private void OnDeserializing(StreamingContext)' k typu {0} a označte ji pomocí System.Runtime.Serialization.OnDeserializingAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideDeserializationMethodsForOptionalFieldsTitle">
        <source>Provide deserialization methods for optional fields</source>
        <target state="translated">Poskytujte metody deserializace pro volitelné pole</target>
        <note />
      </trans-unit>
      <trans-unit id="UseIndexer">
        <source>Use indexer</source>
        <target state="translated">Použít indexer</target>
        <note />
      </trans-unit>
      <trans-unit id="UseOrdinalStringComparisonTitle">
        <source>Use ordinal stringcomparison</source>
        <target state="translated">Použijte StringComparison s hodnotou Ordinal</target>
        <note />
      </trans-unit>
      <trans-unit id="UseOrdinalStringComparisonDescription">
        <source>A string comparison operation that is nonlinguistic does not set the StringComparison parameter to either Ordinal or OrdinalIgnoreCase. By explicitly setting the parameter to either StringComparison.Ordinal or StringComparison.OrdinalIgnoreCase, your code often gains speed, becomes more correct, and becomes more reliable.</source>
        <target state="translated">Operace porovnání řetězců, která není jazyková, nenastavuje parametr StringComparison na hodnotu Ordinal nebo OrdinalIgnoreCase. Explicitním nastavením parametru na hodnotu StringComparison.Ordinal nebo StringComparison.OrdinalIgnoreCase se kód často urychlí a bývá správnější a spolehlivější.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseOrdinalStringComparisonMessageStringComparison">
        <source>{0} passes '{1}' as the 'StringComparison' parameter to {2}. To perform a non-linguistic comparison, specify 'StringComparison.Ordinal' or 'StringComparison.OrdinalIgnoreCase' instead.</source>
        <target state="translated">{0} předává {1} jako parametr StringComparison do {2}. Pokud chcete provést jiné než jazykové porovnání, zadejte místo toho StringComparison.Ordinal StringComparison.OrdinalIgnoreCase.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseOrdinalStringComparisonMessageStringComparer">
        <source>{0} passes '{1}' as the 'StringComparer' parameter to {2}. To perform a non-linguistic comparison, specify 'StringComparer.Ordinal' or 'StringComparer.OrdinalIgnoreCase' instead.</source>
        <target state="translated">{0} předává {1} jako parametr StringComparer do {2}. Pokud chcete provést jiné než jazykové porovnání, zadejte místo toho StringComparer.Ordinal StringComparer.OrdinalIgnoreCase.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseTimersThatPreventPowerStateChangesTitle">
        <source>Do not use timers that prevent power state changes</source>
        <target state="translated">Nepoužívejte časovače, které znemožňují změnit stav napájení</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseTimersThatPreventPowerStateChangesDescription">
        <source>Higher-frequency periodic activity will keep the CPU busy and interfere with power-saving idle timers that turn off the display and hard disks.</source>
        <target state="translated">Častější pravidelná aktivita bude zatěžovat procesor a ovlivňovat časovače neaktivity, které šetří energii a vypínají displej a pevné disky.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseTimersThatPreventPowerStateChangesMessage">
        <source>Do not use timers that prevent power state changes</source>
        <target state="translated">Nepoužívejte časovače, které znemožňují změnit stav napájení</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnsealedAttributesTitle">
        <source>Avoid unsealed attributes</source>
        <target state="translated">Vyhněte se nezapečetěným atributům</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnsealedAttributesDescription">
        <source>The .NET Framework class library provides methods for retrieving custom attributes. By default, these methods search the attribute inheritance hierarchy. Sealing the attribute eliminates the search through the inheritance hierarchy and can improve performance.</source>
        <target state="translated">Knihovna tříd .NET Framework poskytuje metody pro načítání vlastních atributů. Ve výchozím nastavení tyto metody prohledávají hierarchii dědičnosti atributů. Zapečetění atributu eliminuje prohledávání hierarchie dědičnosti a může zvýšit výkon.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnsealedAttributesMessage">
        <source>Avoid unsealed attributes</source>
        <target state="translated">Vyhněte se nezapečetěným atributům</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForEmptyStringsUsingStringLengthTitle">
        <source>Test for empty strings using string length</source>
        <target state="translated">Prázdné řetězce testujte pomocí jejich délky</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForEmptyStringsUsingStringLengthDescription">
        <source>Comparing strings by using the String.Length property or the String.IsNullOrEmpty method is significantly faster than using Equals.</source>
        <target state="translated">Porovnávání řetězců pomocí vlastnosti String.Length nebo metody String.IsNullOrEmpty je výrazně rychlejší než pomocí Equals.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForEmptyStringsUsingStringLengthMessage">
        <source>Test for empty strings using 'string.Length' property or 'string.IsNullOrEmpty' method instead of an Equality check.</source>
        <target state="translated">Ke kontrole, jestli jsou řetězce prázdné, použijte namísto kontroly rovnosti vlastnost string.Length nebo metodu string.IsNullOrEmpty.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotLockOnObjectsWithWeakIdentityTitle">
        <source>Do not lock on objects with weak identity</source>
        <target state="translated">Nepoužívejte zámky na objekty se slabou identitou</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotLockOnObjectsWithWeakIdentityDescription">
        <source>An object is said to have a weak identity when it can be directly accessed across application domain boundaries. A thread that tries to acquire a lock on an object that has a weak identity can be blocked by a second thread in a different application domain that has a lock on the same object.</source>
        <target state="translated">Objekt má slabou identitu, když se k němu dá přistoupit přímo přes hranice domény aplikace. Vlákno, které se pokusí získat zámek na objekt se slabou identitou, může být zablokováno jiným vláknem v jiné doméně aplikace, které má zámek na stejný objekt.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotLockOnObjectsWithWeakIdentityMessage">
        <source>Do not lock on objects with weak identity</source>
        <target state="translated">Nepoužívejte zámky na objekty se slabou identitou</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchCorruptedStateExceptionsInGeneralHandlersTitle">
        <source>Do not catch corrupted state exceptions in general handlers.</source>
        <target state="translated">Nezachytávejte v obecných obslužných rutinách výjimky poškozující stav procesu.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchCorruptedStateExceptionsInGeneralHandlersDescription">
        <source>Do not author general catch handlers in code that receives corrupted state exceptions.</source>
        <target state="translated">Nevytvářejte v kódu obecné zachytávací bloky, které přijímají výjimky poškozující stav procesu.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchCorruptedStateExceptionsInGeneralHandlersMessage">
        <source>Do not catch corrupted state exceptions in general handlers.</source>
        <target state="translated">Nezachytávejte v obecných obslužných rutinách výjimky poškozující stav procesu.</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsTitle">
        <source>Rethrow to preserve stack details</source>
        <target state="translated">Vyvolat znovu, aby se zachovaly podrobnosti zásobníku</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsDescription">
        <source>An exception is rethrown and the exception is explicitly specified in the throw statement. If an exception is rethrown by specifying the exception in the throw statement, the list of method calls between the original method that threw the exception and the current method is lost.</source>
        <target state="translated">Výjimka se vyvolá znovu s tím, že se explicitně určí ve výrazu throw. Pokud se výjimka znovu vyvolá tak, že se určí ve výrazu throw, ztratí se seznam volání metod mezi původní metodou, která výjimku vyvolala, a aktuální metodou.</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsMessage">
        <source>Rethrow to preserve stack details</source>
        <target state="translated">Vyvolat znovu, aby se zachovaly podrobnosti zásobníku</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesTitle">
        <source>Do not raise reserved exception types</source>
        <target state="translated">Nevyvolávejte rezervované typy výjimek</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesDescription">
        <source>An exception of type that is not sufficiently specific or reserved by the runtime should never be raised by user code. This makes the original error difficult to detect and debug. If this exception instance might be thrown, use a different exception type.</source>
        <target state="translated">Uživatelský kód by nikdy neměl vyvolat výjimku typu, který není dostatečně konkrétní nebo je rezervovaný modulem runtime. V takovém případě je totiž obtížné zjistit a ladit původní chybu. Pokud může dojít k vyvolání této instance výjimky, použijte jiný typ výjimky.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesMessageTooGeneric">
        <source>Exception type {0} is not sufficiently specific.</source>
        <target state="translated">Výjimka typu {0} není dost konkrétní.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesMessageReserved">
        <source>Exception type {0} is reserved by the runtime.</source>
        <target state="translated">Výjimka typu {0} je rezervovaná modulem runtime.</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeValueTypeStaticFieldsInlineTitle">
        <source>Initialize value type static fields inline</source>
        <target state="translated">Inicializujte statická pole typu hodnot jako vložená</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeReferenceTypeStaticFieldsInlineTitle">
        <source>Initialize reference type static fields inline</source>
        <target state="translated">Inicializujte statická pole typu odkazů jako vložená</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeValueTypeStaticFieldsInlineDescription">
        <source>A value type declares an explicit static constructor. To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor.</source>
        <target state="translated">Typ hodnoty deklaruje explicitní statický konstruktor. Pokud chcete napravit porušení tohoto pravidla, inicializujte všechna statická data při jejich deklaraci a odeberte statický konstruktor.</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeReferenceTypeStaticFieldsInlineDescription">
        <source>A reference type declares an explicit static constructor. To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor.</source>
        <target state="translated">Typ odkazu deklaruje explicitní statický konstruktor. Pokud chcete napravit porušení tohoto pravidla, inicializujte všechna statická data při jejich deklaraci a odeberte statický konstruktor.</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeStaticFieldsInlineMessage">
        <source>Initialize all static fields in '{0}' when those fields are declared and remove the explicit static constructor</source>
        <target state="translated">Inicializujte všechna statická pole v {0} ve chvíli, kdy se tato pole deklarují, a odeberte explicitní statický konstruktor.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableFieldsShouldBeDisposedTitle">
        <source>Disposable fields should be disposed</source>
        <target state="translated">Pole, která se dají uvolnit, by se měla uvolňovat</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableFieldsShouldBeDisposedDescription">
        <source>A type that implements System.IDisposable declares fields that are of types that also implement IDisposable. The Dispose method of the field is not called by the Dispose method of the declaring type. To fix a violation of this rule, call Dispose on fields that are of types that implement IDisposable if you are responsible for allocating and releasing the unmanaged resources held by the field.</source>
        <target state="translated">Typ, který implementuje System.IDisposable, deklaruje pole, která mají typ, který IDisposable implementuje taky. Metoda Dispose deklarujícího typu nevolá metodu Dispose daného pole. Pokud chcete porušení tohoto pravidla opravit a je vaší odpovědností přidělovat a uvolňovat nespravované prostředky, které pole uchovává, zavolejte Dispose pro pole s typy, které implementují IDisposable.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableFieldsShouldBeDisposedMessage">
        <source>'{0}' contains field '{1}' that is of IDisposable type '{2}', but it is never disposed. Change the Dispose method on '{0}' to call Close or Dispose on this field.</source>
        <target state="translated">{0} obsahuje pole {1}, které má typ IDisposable {2}, ale nikdy se nevyřazuje. Změňte metodu Dispose v {0} tak, aby pro toto pole volala Close nebo Dispose.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructorsTitle">
        <source>Do not call overridable methods in constructors</source>
        <target state="translated">Nevolejte přepsatelné metody v konstruktorech</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructorsDescription">
        <source>When a constructor calls a virtual method, the constructor for the instance that invokes the method may not have executed.</source>
        <target state="translated">Když konstruktor zavolá virtuální metodu, konstruktor dané instance, která metodu vyvolala, se nemusí spustit.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructorsMessage">
        <source>Do not call overridable methods in constructors</source>
        <target state="translated">Nevolejte přepsatelné metody v konstruktorech</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeMethodsShouldCallBaseClassDisposeTitle">
        <source>Dispose methods should call base class dispose</source>
        <target state="translated">Metody Dispose by měly volat uvolnění základní třídy</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeMethodsShouldCallBaseClassDisposeDescription">
        <source>A type that implements System.IDisposable inherits from a type that also implements IDisposable. The Dispose method of the inheriting type does not call the Dispose method of the parent type. To fix a violation of this rule, call base.Dispose in your Dispose method.</source>
        <target state="translated">Typ, který implementuje System.IDisposable, dědí z typu, který IDisposable implementuje taky. Metoda Dispose dědícího typu nevolá metodu Dispose nadřazeného typu. Pokud chcete porušení tohoto pravidla opravit, zavolejte ve své metodě Dispose metodu base.Dispose.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeMethodsShouldCallBaseClassDisposeMessage">
        <source>Ensure that method '{0}' calls '{1}' in all possible control flow paths.</source>
        <target state="translated">Zajistěte, aby metoda {0} volala {1} na všech možných cestách toku řízení.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableTypesShouldDeclareFinalizerTitle">
        <source>Disposable types should declare finalizer</source>
        <target state="translated">Uvolnitelné typy by měly deklarovat finalizační metodu</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableTypesShouldDeclareFinalizerDescription">
        <source>A type that implements System.IDisposable and has fields that suggest the use of unmanaged resources does not implement a finalizer, as described by Object.Finalize.</source>
        <target state="translated">Typ, který implementuje System.IDisposable a má pole, která naznačují, že se používají nespravované prostředky, neimplementuje finalizační metodu, jak se popisuje v Object.Finalize.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableTypesShouldDeclareFinalizerMessage">
        <source>Disposable types should declare finalizer</source>
        <target state="translated">Uvolnitelné typy by měly deklarovat finalizační metodu</target>
        <note />
      </trans-unit>
      <trans-unit id="FinalizersShouldCallBaseClassFinalizerTitle">
        <source>Finalizers should call base class finalizer</source>
        <target state="translated">Finalizační metody by měly volat finalizační metodu základní třídy</target>
        <note />
      </trans-unit>
      <trans-unit id="FinalizersShouldCallBaseClassFinalizerDescription">
        <source>Finalization must be propagated through the inheritance hierarchy. To guarantee this, types must call their base class Finalize method in their own Finalize method.</source>
        <target state="translated">Finalizace se musí rozšířit v hierarchii dědičnosti. Aby k tomu došlo, typy musí ve svých vlastních metodách Finalize volat metodu Finalize základní třídy.</target>
        <note />
      </trans-unit>
      <trans-unit id="FinalizersShouldCallBaseClassFinalizerMessage">
        <source>Finalizers should call base class finalizer</source>
        <target state="translated">Finalizační metody by měly volat finalizační metodu základní třídy</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentsToFormattingMethodsTitle">
        <source>Provide correct arguments to formatting methods</source>
        <target state="translated">Poskytněte metodám formátování správné argumenty</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentsToFormattingMethodsDescription">
        <source>The format argument that is passed to System.String.Format does not contain a format item that corresponds to each object argument, or vice versa.</source>
        <target state="translated">Argument formátu, který se předává do System.String.Format, neobsahuje položku formátování, která odpovídá jednotlivým argumentům objektů, nebo naopak.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentsToFormattingMethodsMessage">
        <source>Provide correct arguments to formatting methods</source>
        <target state="translated">Poskytněte metodám formátování správné argumenty</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForNaNCorrectlyTitle">
        <source>Test for NaN correctly</source>
        <target state="translated">Testujte správně hodnotu NaN</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForNaNCorrectlyDescription">
        <source>This expression tests a value against Single.Nan or Double.Nan. Use Single.IsNan(Single) or Double.IsNan(Double) to test the value.</source>
        <target state="translated">Tento výraz otestuje, jestli hodnota není Single.Nan nebo Double.Nan. Otestujte hodnotu pomocí Single.IsNan(Single) nebo Double.IsNan(Double).</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForNaNCorrectlyMessage">
        <source>Test for NaN correctly</source>
        <target state="translated">Testujte správně hodnotu NaN</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyTitle">
        <source>Attribute string literals should parse correctly</source>
        <target state="translated">Literály řetězců atributů by se měly správně parsovat</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyDescription">
        <source>The string literal parameter of an attribute does not parse correctly for a URL, a GUID, or a version.</source>
        <target state="translated">Pro adresu URL, identifikátor GUID nebo verzi se nesprávně parsuje parametr literálu řetězce nějakého atributu.</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyMessageDefault">
        <source>In the constructor of '{0}', change the value of argument '{1}', which is currently "{2}", to something that can be correctly parsed as '{3}'.</source>
        <target state="translated">V konstruktoru {0} změňte hodnotu argumentu {1}, která je aktuálně {2}, na hodnotu, která se dá správně parsovat jako {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyMessageEmpty">
        <source>In the constructor of '{0}', change the value of argument '{1}', which is currently an empty string (""), to something that can be correctly parsed as '{2}'.</source>
        <target state="translated">V konstruktoru {0} změňte hodnotu argumentu {1}, která je aktuálně prázdný řetězec (""), na hodnotu, která se dá správně parsovat jako {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidZeroLengthArrayAllocationsTitle">
        <source>Avoid zero-length array allocations.</source>
        <target state="translated">Vyhněte se alokacím polí s nulovou délkou</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidZeroLengthArrayAllocationsMessage">
        <source>Avoid unnecessary zero-length array allocations.  Use {0} instead.</source>
        <target state="translated">Vyhněte se nepotřebným alokacím polí s nulovou délkou.  Použijte místo toho {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyTitle">
        <source>Do not use Enumerable methods on indexable collections. Instead use the collection directly</source>
        <target state="translated">Nepoužívejte metody Enumerable nebo indexovatelné kolekce. Použijte místo toho kolekci napřímo.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyDescription">
        <source>This collection is directly indexable. Going through LINQ here causes unnecessary allocations and CPU work.</source>
        <target state="translated">Tato kolekce se dá přímo indexovat. Procházení kódu LINQ na tomto místě způsobuje zbytečné alokace a vytížení procesoru.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyMessage">
        <source>Do not use Enumerable methods on indexable collections. Instead use the collection directly</source>
        <target state="translated">Nepoužívejte metody Enumerable nebo indexovatelné kolekce. Použijte místo toho kolekci napřímo.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureInfoTitle">
        <source>Specify CultureInfo</source>
        <target state="translated">Zadejte CultureInfo</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureInfoDescription">
        <source>A method or constructor calls a member that has an overload that accepts a System.Globalization.CultureInfo parameter, and the method or constructor does not call the overload that takes the CultureInfo parameter. When a CultureInfo or System.IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales. If the result will be displayed to the user, specify 'CultureInfo.CurrentCulture' as the 'CultureInfo' parameter. Otherwise, if the result will be stored and accessed by software, such as when it is persisted to disk or to a database, specify 'CultureInfo.InvariantCulture'.</source>
        <target state="translated">Metoda nebo konstruktor volá člen, který je přetížením přijímajícím parametr System.Globalization.CultureInfo, ale metoda nebo konstruktor nevolá přetížení, které přijímá parametr CultureInfo. Když se nezadá CultureInfo ani objekt System.IFormatProvider, výchozí hodnota, kterou poskytuje přetížený člen, nemusí mít ve všech národních prostředích požadovaný účinek. Pokud se výsledek zobrazí uživateli, zadejte jako parametr CultureInfo hodnotu CultureInfo.CurrentCulture. V opačném případě, pokud software výsledek uloží a přistupuje k němu, třeba při jeho trvalém uložení na disk nebo do databáze, zadejte CultureInfo.InvariantCulture.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureInfoMessage">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">Chování {0} se může lišit podle aktuálních nastavení národního prostředí uživatele. Nahraďte toto volání v {1} voláním {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderTitle">
        <source>Specify IFormatProvider</source>
        <target state="translated">Zadejte IFormatProvider</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderDescription">
        <source>A method or constructor calls one or more members that have overloads that accept a System.IFormatProvider parameter, and the method or constructor does not call the overload that takes the IFormatProvider parameter. When a System.Globalization.CultureInfo or IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales. If the result will be based on the input from/output displayed to the user, specify 'CultureInfo.CurrentCulture' as the 'IFormatProvider'. Otherwise, if the result will be stored and accessed by software, such as when it is loaded from disk/database and when it is persisted to disk/database, specify 'CultureInfo.InvariantCulture'</source>
        <target state="translated">Metoda nebo konstruktor volá nejméně jeden člen, který má přetížení přijímající parametr System.IFormatProvider, ale metoda nebo konstruktor nevolá přetížení, které přijímá parametr IFormatProvider. Když se nezadá System.Globalization.CultureInfo ani objekt IFormatProvider, výchozí hodnota, kterou poskytuje přetížený člen, nemusí mít ve všech národních prostředích požadovaný účinek. Pokud se výsledek zakládá na vstupu od uživatele nebo na výstupu, který se mu zobrazí, zadejte jako parametr IFormatProvider hodnotu CultureInfo.CurrentCulture. V opačném případě, pokud software výsledek uloží a přistupuje k němu, třeba při jeho trvalém uložení na disk nebo do databáze nebo při jeho načtení z nich, zadejte CultureInfo.InvariantCulture.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageIFormatProviderAlternateString">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">Chování {0} se může lišit podle aktuálních nastavení národního prostředí uživatele. Nahraďte toto volání v {1} voláním {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageIFormatProviderAlternate">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">Chování {0} se může lišit podle aktuálních nastavení národního prostředí uživatele. Nahraďte toto volání v {1} voláním {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageUICultureString">
        <source>'{0}' passes '{1}' as the 'IFormatProvider' parameter to '{2}'. This property returns a culture that is inappropriate for formatting methods.</source>
        <target state="translated">{0} předává {1} jako parametr IFormatProvider do {2}. Tato vlastnost vrací jazykovou verzi, která není vhodná pro metody formátování.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageUICulture">
        <source>'{0}' passes '{1}' as the 'IFormatProvider' parameter to '{2}'. This property returns a culture that is inappropriate for formatting methods.</source>
        <target state="translated">{0} předává {1} jako parametr IFormatProvider do {2}. Tato vlastnost vrací jazykovou verzi, která není vhodná pro metody formátování.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonTitle">
        <source>Specify StringComparison</source>
        <target state="translated">Zadejte StringComparison</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonDescription">
        <source>A string comparison operation uses a method overload that does not set a StringComparison parameter. If the result will be displayed to the user, such as when sorting a list of items for display in a list box, specify 'StringComparison.CurrentCulture' or 'StringComparison.CurrentCultureIgnoreCase' as the 'StringComparison' parameter. If comparing case-insensitive identifiers, such as file paths, environment variables, or registry keys and values, specify 'StringComparison.OrdinalIgnoreCase'. Otherwise, if comparing case-sensitive identifiers, specify 'StringComparison.Ordinal'.</source>
        <target state="translated">Operace porovnání řetězců používá přetížení metody, které nenastavuje parametr StringComparison. Pokud se výsledek zobrazí uživateli, třeba při řazení seznamu položek před zobrazením v seznamu, zadejte jako parametr StringComparison StringComparison.CurrentCulture nebo StringComparison.CurrentCultureIgnoreCase. Pokud porovnáváte identifikátory, které nerozlišují velikost písmen, třeba cesty k souborům, proměnné prostředí nebo klíče a hodnoty registru, zadejte StringComparison.OrdinalIgnoreCase. Jinak pokud porovnáváte identifikátory s rozlišováním velikosti písmen, zadejte StringComparison.Ordinal.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonMessage">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">Chování {0} se může lišit podle aktuálních nastavení národního prostředí uživatele. Nahraďte toto volání v {1} voláním {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="NormalizeStringsToUppercaseTitle">
        <source>Normalize strings to uppercase</source>
        <target state="translated">Normalizujte řetězce na velká písmena</target>
        <note />
      </trans-unit>
      <trans-unit id="NormalizeStringsToUppercaseDescription">
        <source>Strings should be normalized to uppercase. A small group of characters cannot make a round trip when they are converted to lowercase. To make a round trip means to convert the characters from one locale to another locale that represents character data differently, and then to accurately retrieve the original characters from the converted characters.</source>
        <target state="translated">Řetězce by se měly normalizovat na velká písmena. Pro určitou malou skupinu znaků nejde po převodu na malá písmena provést dvojí převod. Dvojí převod znamená, že se znaky převedou z jednoho národního prostředí do jiného, které reprezentuje data znaků jinak, a pak se z těchto převedených znaků správně získají zpět původní znaky.</target>
        <note />
      </trans-unit>
      <trans-unit id="NormalizeStringsToUppercaseMessageToUpper">
        <source>In method '{0}', replace the call to '{1}' with '{2}'.</source>
        <target state="translated">V metodě {0} nahraďte volání {1} voláním {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyTitle">
        <source>Dispose methods should call SuppressFinalize</source>
        <target state="translated">Metody Dispose by měly volat SuppressFinalize</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyDescription">
        <source>A method that is an implementation of Dispose does not call GC.SuppressFinalize; or a method that is not an implementation of Dispose calls GC.SuppressFinalize; or a method calls GC.SuppressFinalize and passes something other than this (Me in Visual?Basic).</source>
        <target state="translated">Metoda, která je implementací metody Dispose, nevolá GC.SuppressFinalize, nebo metoda, která není implementací metody Dispose, volá GC.SuppressFinalize, nebo metoda volá GC.SuppressFinalize a předává něco jiného než this (Me ve Visual Basicu).</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageNotCalledWithFinalizer">
        <source>Change {0} to call {1}. This will prevent unnecessary finalization of the object once it has been disposed and it has fallen out of scope.</source>
        <target state="translated">Změňte {0} tak, aby volalo %({1}). To zabrání zbytečné finalizaci objektu poté, co se uvolnil a už není v oboru.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageNotCalled">
        <source>Change {0} to call {1}. This will prevent derived types that introduce a finalizer from needing to re-implement 'IDisposable' to call it.</source>
        <target state="translated">Změňte {0} tak, aby volalo %({1}). Díky tomu odvozené typy, které zavádějí finalizační metodu, nebudou muset znovu implementovat rozhraní IDisposable, aby ji mohly zavolat.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageNotPassedThis">
        <source>{0} calls {1} on something other than itself. Change the call site to pass 'this' ('Me' in Visual Basic) instead.</source>
        <target state="translated">{0} volá {1} na něco jiného než sebe. Změňte lokalitu volání tak, aby místo toho předávala this (Me ve Visual Basicu).</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageOutsideDispose">
        <source>{0} calls {1}, a method that is typically only called within an implementation of 'IDisposable.Dispose'. Refer to the IDisposable pattern for more information.</source>
        <target state="translated">{0} volá {1}, což je metoda, která se obvykle volá jen v implementaci metody IDisposable.Dispose. Další informace najdete ve vzoru IDisposable.</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyTitle">
        <source>Instantiate argument exceptions correctly</source>
        <target state="translated">Vytvářejte správně instanci výjimek argumentů</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyDescription">
        <source>A call is made to the default (parameterless) constructor of an exception type that is or derives from ArgumentException, or an incorrect string argument is passed to a parameterized constructor of an exception type that is or derives from ArgumentException.</source>
        <target state="translated">Zavolal se výchozí konstruktor (bez parametrů) typu výjimky, který je třídou ArgumentException nebo je z ní odvozený, nebo se do jeho konstruktoru s parametry předal nesprávný argument řetězce.</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyMessageNoArguments">
        <source>Call the {0} constructor that contains a message and/or paramName parameter.</source>
        <target state="translated">Zavolejte konstruktor {0}, který obsahuje zprávu a/nebo parametr paramName.</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyMessageIncorrectMessage">
        <source>Method {0} passes parameter name '{1}' as the {2} argument to a {3} constructor. Replace this argument with a descriptive message and pass the parameter name in the correct position.</source>
        <target state="translated">Metoda {0} předává název parametru {1} jako argument {2} konstruktoru {3}. Nahraďte tento argument popisnou zprávou a předejte název parametru na správné pozici.</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyMessageIncorrectParameterName">
        <source>Method {0} passes '{1}' as the {2} argument to a {3} constructor. Replace this argument with one of the method's parameter names. Note that the provided parameter name should have the exact casing as declared on the method.</source>
        <target state="translated">Metoda {0} předává {1} jako argument {2} konstruktoru {3}. Nahraďte tento argument jedním z názvů parametrů metody. Poznámka: Poskytnutý název parametru by měl přesně dodržovat velikost písmen tak, jak je deklarovaný v metodě.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseArrayEmpty">
        <source>Use Array.Empty</source>
        <target state="translated">Použijte Array.Empty</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ja" original="../SystemRuntimeAnalyzersResources.resx">
    <body>
      <trans-unit id="AddNonSerializedAttributeCodeActionTitle">
        <source>Add the 'NonSerialized' attribute to this field.</source>
        <target state="translated">このフィールドに、'NonSerialized' 属性を追加します。</target>
        <note />
      </trans-unit>
      <trans-unit id="AddSerializableAttributeCodeActionTitle">
        <source>Add Serializable attribute</source>
        <target state="translated">Serializable 属性を追加する</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeDescription">
        <source>If a disposable object is not explicitly disposed before all references to it are out of scope, the object will be disposed at some indeterminate time when the garbage collector runs the finalizer of the object. Because an exceptional event might occur that will prevent the finalizer of the object from running, the object should be explicitly disposed instead.</source>
        <target state="translated">破棄可能なオブジェクトは、自身へのすべての参照がスコープ外になる前に明示的に破棄されなかった場合、ガベージ コレクターがそのオブジェクトのファイナライザーを実行した際に不特定の時点で破棄されます。ただし例外的なイベントが起こってオブジェクトのファイナライザーの実行が妨げられる場合もあるため、オブジェクトの破棄は明示的に行ってください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeMayBeDisposedMessage">
        <source>Use recommended dispose pattern to ensure that object created by '{0}' is disposed on all paths. If possible, wrap the creation within a 'using' statement or a 'using' declaration. Otherwise, use a try-finally pattern, with a dedicated local variable declared before the try region and an unconditional Dispose invocation on non-null value in the 'finally' region, say 'x?.Dispose()'. If the object is explicitly disposed within the try region or the dispose ownership is transfered to another object or method, assign 'null' to the local variable just after such an operation to prevent double dispose in 'finally'.</source>
        <target state="translated">推奨された dispose パターンを使用して、'{0}' が作成したオブジェクトがすべてのパスで破棄されるようにします。可能なら、'using' ステートメントまたは 'using' 宣言内で作成をラップします。または、try-finally パターンを、try 領域の前で宣言された専用のローカル変数と、'finally' 領域の非 null 値での条件なしの Dispose の呼び出し (例: 'x?.Dispose()') とともに使用します。オブジェクトが try 領域内で明示的に破棄されるか、dispose の所有権が他のオブジェクトまたはメソッドに移される場合、その操作のすぐ後で 'null' をローカル変数に割り当てて、'finally' 内での dispose の重複を回避します。</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeMayBeDisposedOnExceptionPathsMessage">
        <source>Use recommended dispose pattern to ensure that object created by '{0}' is disposed on all exception paths. If possible, wrap the creation within a 'using' statement or a 'using' declaration. Otherwise, use a try-finally pattern, with a dedicated local variable declared before the try region and an unconditional Dispose invocation on non-null value in the 'finally' region, say 'x?.Dispose()'. If the object is explicitly disposed within the try region or the dispose ownership is transfered to another object or method, assign 'null' to the local variable just after such an operation to prevent double dispose in 'finally'.</source>
        <target state="translated">推奨された dispose パターンを使用して、'{0}' が作成したオブジェクトがすべての例外パスで破棄されるようにします。可能なら、'using' ステートメントまたは 'using' 宣言内で作成をラップします。または、try-finally パターンを、try 領域の前で宣言された専用のローカル変数と、'finally' 領域の非 null 値での条件なしの Dispose の呼び出し (例: 'x?.Dispose()') とともに使用します。オブジェクトが try 領域内で明示的に破棄されるか、dispose の所有権が他のオブジェクトまたはメソッドに移される場合、その操作のすぐ後で 'null' をローカル変数に割り当てて、'finally' 内での dispose の重複を回避します。</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeNotDisposedMessage">
        <source>Call System.IDisposable.Dispose on object created by '{0}' before all references to it are out of scope.</source>
        <target state="translated">'{0}' が作成したオブジェクトへの参照がすべてスコープ外になる前に、そのオブジェクトの System.IDisposable.Dispose を呼び出してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeNotDisposedOnExceptionPathsMessage">
        <source>Object created by '{0}' is not disposed along all exception paths. Call System.IDisposable.Dispose on the object before all references to it are out of scope.</source>
        <target state="translated">'{0}' に作成されたオブジェクトが破棄されない例外パスがあります。オブジェクトへの参照がすべてスコープ外になる前に、このオブジェクトの System.IDisposable.Dispose を呼び出してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeTitle">
        <source>Dispose objects before losing scope</source>
        <target state="translated">スコープを失う前にオブジェクトを破棄</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassLiteralsAsLocalizedParametersDescription">
        <source>A method passes a string literal as a parameter to a constructor or method in the .NET Framework class library and that string should be localizable. To fix a violation of this rule, replace the string literal with a string retrieved through an instance of the ResourceManager class.</source>
        <target state="translated">メソッドは文字列リテラルをパラメーターとして .NET Framework クラス ライブラリ内のコンストラクターまたはメソッドに渡し、その文字列はローカライズ可能である必要があります。このルールの違反を修正するには、文字列リテラルを、ResourceManager クラスのインスタンスを使用して取得した文字列で置き換えます。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassLiteralsAsLocalizedParametersMessage">
        <source>Method '{0}' passes a literal string as parameter '{1}' of a call to '{2}'. Retrieve the following string(s) from a resource table instead: "{3}".</source>
        <target state="translated">メソッド '{0}' は、リテラル文字列を '{2}' への呼び出しのパラメーター '{1}' として渡します。これを変更して、リソース テーブルから次の文字列を取得してください: "{3}"</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassLiteralsAsLocalizedParametersTitle">
        <source>Do not pass literals as localized parameters</source>
        <target state="translated">ローカライズされるパラメーターとしてリテラルを渡さない</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementISerializableCorrectlyDescription">
        <source>To fix a violation of this rule, make the GetObjectData method visible and overridable, and make sure that all instance fields are included in the serialization process or explicitly marked by using the NonSerializedAttribute attribute.</source>
        <target state="translated">このルールの違反を修正するには、GetObjectData メソッドを参照可能およびオーバーライド可能にして、すべてのインスタンス フィールドがシリアル化プロセスに含まれるか、NonSerializedAttribute 属性を使用して明示的にマークされるようにしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementISerializableCorrectlyMessageDefault">
        <source>Add an implementation of GetObjectData to type {0}.</source>
        <target state="translated">GetObjectData の実装を型 {0} に追加します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementISerializableCorrectlyMessageMakeOverridable">
        <source>Make {0}.GetObjectData virtual and overridable.</source>
        <target state="translated">{0}.GetObjectData を仮想およびオーバーライド可能にします。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementISerializableCorrectlyMessageMakeVisible">
        <source>Increase the accessibility of {0}.GetObjectData so that it is visible to derived types.</source>
        <target state="translated">派生型に公開するため、{0}.GetObjectData のアクセシビリティを上げます。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementISerializableCorrectlyTitle">
        <source>Implement ISerializable correctly</source>
        <target state="translated">ISerializable を正しく実装します</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationConstructorsCodeActionTitle">
        <source>Implement Serialization constructor</source>
        <target state="translated">シリアル化コンストラクターを実装する</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationConstructorsDescription">
        <source>To fix a violation of this rule, implement the serialization constructor. For a sealed class, make the constructor private; otherwise, make it protected.</source>
        <target state="translated">このルールの違反を修正するには、シリアル化コンストラクターを実装します。シール クラスの場合はコンストラクターを private にします。そうでない場合、protected にします。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationConstructorsMessageCreateMagicConstructor">
        <source>Add a constructor to {0} with the following signature: 'protected {0}(SerializationInfo info, StreamingContext context)'.</source>
        <target state="translated">次のシグネチャと共にコンストラクターを {0} に追加します: 'protected {0}(SerializationInfo 情報、StreamingContext コンテキスト)'</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationConstructorsMessageMakeSealedMagicConstructorPrivate">
        <source>Declare the serialization constructor of {0}, a sealed type, as private.</source>
        <target state="translated">シールド型である {0} のシリアル化コンストラクターを private として宣言します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationConstructorsMessageMakeUnsealedMagicConstructorFamily">
        <source>Declare the serialization constructor of {0}, an unsealed type, as protected.</source>
        <target state="translated">アンシールド型である {0} のシリアル化コンストラクターを protected として宣言します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationConstructorsTitle">
        <source>Implement serialization constructors</source>
        <target state="translated">シリアル化コンストラクターを実装します</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyDescription">
        <source>A method that handles a serialization event does not have the correct signature, return type, or visibility.</source>
        <target state="translated">シリアル化イベントを処理するメソッドには、正しいシグネチャ、戻り値の型、または可視性がありません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyMessageGeneric">
        <source>Because {0} is marked with OnSerializing, OnSerialized, OnDeserializing, or OnDeserialized, change its signature so that it is no longer generic.</source>
        <target state="translated">{0} は OnSerializing、OnSerialized、OnDeserializing、または OnDeserialized に設定されているため、ジェネリックにならないようにシグネチャを変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyMessageParameters">
        <source>Because {0} is marked with OnSerializing, OnSerialized, OnDeserializing, or OnDeserialized, change its signature so that it takes a single parameter of type 'System.Runtime.Serialization.StreamingContext'.</source>
        <target state="translated">{0} は OnSerializing、OnSerialized、OnDeserializing、または OnDeserialized に設定されているため、'System.Runtime.Serialization.StreamingContext' という型の単一のパラメーターを受け取るようにシグネチャを変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyMessageReturnType">
        <source>Because {0} is marked with OnSerializing, OnSerialized, OnDeserializing, or OnDeserialized, change its return type from {1} to void (Sub in Visual Basic).</source>
        <target state="translated">{0} は OnSerializing、OnSerialized、OnDeserializing、または OnDeserialized に設定されているため、戻り値の型を {1} から void (Visual Basic では Sub) に変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyMessageStatic">
        <source>Because {0} is marked with OnSerializing, OnSerialized, OnDeserializing, or OnDeserialized, change it from static (Shared in Visual Basic) to an instance method.</source>
        <target state="translated">{0} は OnSerializing、OnSerialized、OnDeserializing、または OnDeserialized に設定されているため、静的 (Visual Basic では共有) からインスタンス メソッドに変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyMessageVisibility">
        <source>Because {0} is marked with OnSerializing, OnSerialized, OnDeserializing, or OnDeserialized, change its accessibility to private.</source>
        <target state="translated">{0} は OnSerializing、OnSerialized、OnDeserializing、または OnDeserialized に設定されているため、アクセシビリティをプライベートに変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyTitle">
        <source>Implement serialization methods correctly</source>
        <target state="translated">シリアル化メソッドを正しく実装します</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAllNonSerializableFieldsDescription">
        <source>An instance field of a type that is not serializable is declared in a type that is serializable.</source>
        <target state="translated">シリアル化可能ではない型のインスタンス フィールドが、シリアル化可能な型で宣言されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAllNonSerializableFieldsMessage">
        <source>Field {0} is a member of type {1} which is serializable but is of type {2} which is not serializable</source>
        <target state="translated">フィールド {0} はシリアル化可能な型 {1} のメンバーですが、そのフィールド自体はシリアル化可能ではない型 {2} です</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAllNonSerializableFieldsTitle">
        <source>Mark all non-serializable fields</source>
        <target state="translated">すべてのシリアル化不可能なフィールドを設定します</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkISerializableTypesWithSerializableDescription">
        <source>To be recognized by the common language runtime as serializable, types must be marked by using the SerializableAttribute attribute even when the type uses a custom serialization routine through implementation of the ISerializable interface.</source>
        <target state="translated">共通言語ランタイムからシリアル化可能として認識されるには、型が ISerializable インターフェイスの実装によりカスタムのシリアル化ルーチンを使用する場合でも、SerializableAttribute 属性を使用して型をマークする必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkISerializableTypesWithSerializableMessage">
        <source>Add [Serializable] to {0} as this type implements ISerializable</source>
        <target state="translated">この型は ISerializable を実装するため、[Serializable] を {0} に追加します</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkISerializableTypesWithSerializableTitle">
        <source>Mark ISerializable types with serializable</source>
        <target state="translated">ISerializable 型を serializable に設定します</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideDeserializationMethodsForOptionalFieldsDescription">
        <source>A type has a field that is marked by using the System.Runtime.Serialization.OptionalFieldAttribute attribute, and the type does not provide deserialization event handling methods.</source>
        <target state="translated">型には System.Runtime.Serialization.OptionalFieldAttribute 属性を使用してマークされているフィールドがあり、型は逆シリアル化イベントの処理メソッドを提供しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideDeserializationMethodsForOptionalFieldsMessageOnDeserialized">
        <source>Add a 'private void OnDeserialized(StreamingContext)' method to type {0} and attribute it with the System.Runtime.Serialization.OnDeserializedAttribute.</source>
        <target state="translated">'private void OnDeserialized(StreamingContext)' メソッドを型 {0} に追加し、System.Runtime.Serialization.OnDeserializedAttribute に属性指定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideDeserializationMethodsForOptionalFieldsMessageOnDeserializing">
        <source>Add a 'private void OnDeserializing(StreamingContext)' method to type {0} and attribute it with the System.Runtime.Serialization.OnDeserializingAttribute.</source>
        <target state="translated">'private void OnDeserializing(StreamingContext)' メソッドを型 {0} に追加し、System.Runtime.Serialization.OnDeserializingAttribute に属性指定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideDeserializationMethodsForOptionalFieldsTitle">
        <source>Provide deserialization methods for optional fields</source>
        <target state="translated">省略可能なフィールドに、逆シリアル化メソッドを指定します</target>
        <note />
      </trans-unit>
      <trans-unit id="UseIndexer">
        <source>Use indexer</source>
        <target state="translated">インデクサーを使用する</target>
        <note />
      </trans-unit>
      <trans-unit id="UseOrdinalStringComparisonTitle">
        <source>Use ordinal stringcomparison</source>
        <target state="translated">順序を示す StringComparison を使用します</target>
        <note />
      </trans-unit>
      <trans-unit id="UseOrdinalStringComparisonDescription">
        <source>A string comparison operation that is nonlinguistic does not set the StringComparison parameter to either Ordinal or OrdinalIgnoreCase. By explicitly setting the parameter to either StringComparison.Ordinal or StringComparison.OrdinalIgnoreCase, your code often gains speed, becomes more correct, and becomes more reliable.</source>
        <target state="translated">非言語的な文字列比較操作では、StringComparison パラメーターが Ordinal にも OrdinalIgnoreCase にも設定されません。パラメーターを StringComparison.Ordinal または StringComparison.OrdinalIgnoreCase に明示的に設定することによって、コードは多くの場合、高速で正確になり、信頼性が向上します。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseOrdinalStringComparisonMessageStringComparison">
        <source>{0} passes '{1}' as the 'StringComparison' parameter to {2}. To perform a non-linguistic comparison, specify 'StringComparison.Ordinal' or 'StringComparison.OrdinalIgnoreCase' instead.</source>
        <target state="translated">{0} は '{1}' を 'StringComparison' パラメーターとして {2} に渡します。非言語的な比較を実行するには、代わりに 'StringComparison.Ordinal' または 'StringComparison.OrdinalIgnoreCase' を指定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseOrdinalStringComparisonMessageStringComparer">
        <source>{0} passes '{1}' as the 'StringComparer' parameter to {2}. To perform a non-linguistic comparison, specify 'StringComparer.Ordinal' or 'StringComparer.OrdinalIgnoreCase' instead.</source>
        <target state="translated">{0} は '{1}' を 'StringComparer' パラメーターとして {2} に渡します。非言語的な比較を実行するには、代わりに 'StringComparer.Ordinal' または 'StringComparer.OrdinalIgnoreCase' を指定してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseTimersThatPreventPowerStateChangesTitle">
        <source>Do not use timers that prevent power state changes</source>
        <target state="translated">電源の状態の変更を妨げるタイマーを使用しません</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseTimersThatPreventPowerStateChangesDescription">
        <source>Higher-frequency periodic activity will keep the CPU busy and interfere with power-saving idle timers that turn off the display and hard disks.</source>
        <target state="translated">頻度の高い定期的な動作は CPU のビジー状態を維持し、画面およびハード ディスクの電源を切る節電アイドル タイマーに影響します。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseTimersThatPreventPowerStateChangesMessage">
        <source>Do not use timers that prevent power state changes</source>
        <target state="translated">電源の状態の変更を妨げるタイマーを使用しません</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnsealedAttributesTitle">
        <source>Avoid unsealed attributes</source>
        <target state="translated">アンシールド属性を使用しません</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnsealedAttributesDescription">
        <source>The .NET Framework class library provides methods for retrieving custom attributes. By default, these methods search the attribute inheritance hierarchy. Sealing the attribute eliminates the search through the inheritance hierarchy and can improve performance.</source>
        <target state="translated">.NET Framework クラス ライブラリには、カスタム属性を取得するためのメソッドが用意されています。既定では、これらのメソッドは属性継承階層を検索します。属性をシールすると、継承階層全体を検索しなくなるため、パフォーマンスが向上します。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnsealedAttributesMessage">
        <source>Avoid unsealed attributes</source>
        <target state="translated">アンシールド属性を使用しません</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForEmptyStringsUsingStringLengthTitle">
        <source>Test for empty strings using string length</source>
        <target state="translated">文字列の長さを使用して空の文字列をテストします</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForEmptyStringsUsingStringLengthDescription">
        <source>Comparing strings by using the String.Length property or the String.IsNullOrEmpty method is significantly faster than using Equals.</source>
        <target state="translated">String.Length プロパティまたは String.IsNullOrEmpty メソッドを使用して文字列を比較すると、Equals を使用した場合よりも処理速度が大幅に向上します。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForEmptyStringsUsingStringLengthMessage">
        <source>Test for empty strings using 'string.Length' property or 'string.IsNullOrEmpty' method instead of an Equality check.</source>
        <target state="translated">等値チェックの代わりに 'string.Length' プロパティまたは 'string.IsNullOrEmpty' メソッドを使用して空の文字列をテストしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotLockOnObjectsWithWeakIdentityTitle">
        <source>Do not lock on objects with weak identity</source>
        <target state="translated">弱い ID を伴うオブジェクト上でロックしません</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotLockOnObjectsWithWeakIdentityDescription">
        <source>An object is said to have a weak identity when it can be directly accessed across application domain boundaries. A thread that tries to acquire a lock on an object that has a weak identity can be blocked by a second thread in a different application domain that has a lock on the same object.</source>
        <target state="translated">オブジェクトは、アプリケーション ドメイン境界を超えて直接アクセスできる場合に、弱い ID を持つと言われます。弱い ID を持つオブジェクトに対するロックを取得しようとするスレッドが、同じオブジェクトに対するロックを持っている別のアプリケーション ドメイン内の 2 番目のスレッドによってブロックされることがあります。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotLockOnObjectsWithWeakIdentityMessage">
        <source>Do not lock on objects with weak identity</source>
        <target state="translated">弱い ID を伴うオブジェクト上でロックしません</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchCorruptedStateExceptionsInGeneralHandlersTitle">
        <source>Do not catch corrupted state exceptions in general handlers.</source>
        <target state="translated">汎用ハンドラーの破損状態例外をキャッチしません。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchCorruptedStateExceptionsInGeneralHandlersDescription">
        <source>Do not author general catch handlers in code that receives corrupted state exceptions.</source>
        <target state="translated">破損状態例外を受け取るコード内に汎用キャッチ ハンドラーを作成しないでください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchCorruptedStateExceptionsInGeneralHandlersMessage">
        <source>Do not catch corrupted state exceptions in general handlers.</source>
        <target state="translated">汎用ハンドラーの破損状態例外をキャッチしません。</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsTitle">
        <source>Rethrow to preserve stack details</source>
        <target state="translated">スタック詳細を保持するために再度スローします</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsDescription">
        <source>An exception is rethrown and the exception is explicitly specified in the throw statement. If an exception is rethrown by specifying the exception in the throw statement, the list of method calls between the original method that threw the exception and the current method is lost.</source>
        <target state="translated">例外が再スローされ、その例外が throw ステートメント内に明示的に指定されます。throw ステートメント内で例外を指定することによって例外が再スローされる場合、例外をスローした元のメソッドと現在のメソッドの間のメソッド呼び出しのリストは失われます。</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsMessage">
        <source>Rethrow to preserve stack details</source>
        <target state="translated">スタック詳細を保持するために再度スローします</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesTitle">
        <source>Do not raise reserved exception types</source>
        <target state="translated">予約された例外の種類を発生させません</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesDescription">
        <source>An exception of type that is not sufficiently specific or reserved by the runtime should never be raised by user code. This makes the original error difficult to detect and debug. If this exception instance might be thrown, use a different exception type.</source>
        <target state="translated">十分に特定されていない種類の例外またはランタイムによって予約されている種類の例外は、ユーザー コードで発生することはありません。これにより、元のエラーの検出およびデバッグが困難になります。この例外インスタンスがスローされる可能性がある場合は、別の例外の種類を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesMessageTooGeneric">
        <source>Exception type {0} is not sufficiently specific.</source>
        <target state="translated">例外の種類 {0} は十分に特定されていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesMessageReserved">
        <source>Exception type {0} is reserved by the runtime.</source>
        <target state="translated">例外の種類 {0} は、ランタイムによって予約されています。</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeValueTypeStaticFieldsInlineTitle">
        <source>Initialize value type static fields inline</source>
        <target state="translated">値型の静的フィールドをインラインで初期化します</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeReferenceTypeStaticFieldsInlineTitle">
        <source>Initialize reference type static fields inline</source>
        <target state="translated">参照型の静的フィールドをインラインで初期化します</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeValueTypeStaticFieldsInlineDescription">
        <source>A value type declares an explicit static constructor. To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor.</source>
        <target state="translated">値型が明示的な静的コンストラクターを宣言します。この規則の違反を修正するには、すべての静的データを宣言時に初期化し、静的コンストラクターを削除します。</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeReferenceTypeStaticFieldsInlineDescription">
        <source>A reference type declares an explicit static constructor. To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor.</source>
        <target state="translated">参照型が明示的な静的コンストラクターを宣言します。この規則の違反を修正するには、すべての静的データを宣言時に初期化し、静的コンストラクターを削除します。</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeStaticFieldsInlineMessage">
        <source>Initialize all static fields in '{0}' when those fields are declared and remove the explicit static constructor</source>
        <target state="translated">'{0}' のすべての静的フィールドを宣言時に初期化し、明示的な静的コンストラクターを削除します</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableFieldsShouldBeDisposedTitle">
        <source>Disposable fields should be disposed</source>
        <target state="translated">破棄可能なフィールドは破棄しなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableFieldsShouldBeDisposedDescription">
        <source>A type that implements System.IDisposable declares fields that are of types that also implement IDisposable. The Dispose method of the field is not called by the Dispose method of the declaring type. To fix a violation of this rule, call Dispose on fields that are of types that implement IDisposable if you are responsible for allocating and releasing the unmanaged resources held by the field.</source>
        <target state="translated">System.IDisposable を実装する型は、IDisposable も実装する型のフィールドを宣言します。フィールドの Dispose メソッドは、宣言する型の Dispose メソッドによって呼び出されません。フィールドが保持する管理されていないリソースの割り当てと解放を自分が担当している場合、このルールの違反を修正するには、IDisposable を実装する型のフィールドに Dispose を呼び出します。</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableFieldsShouldBeDisposedMessage">
        <source>'{0}' contains field '{1}' that is of IDisposable type '{2}', but it is never disposed. Change the Dispose method on '{0}' to call Close or Dispose on this field.</source>
        <target state="translated">'{0}' には IDisposable 型 '{2}' のフィールド '{1}' が含まれますが、破棄されることはありません。'{0}' 上の Dispose メソッドを変更して、このフィールドで Close または Dispose を呼び出します。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructorsTitle">
        <source>Do not call overridable methods in constructors</source>
        <target state="translated">コンストラクターのオーバーライド可能なメソッドを呼び出しません</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructorsDescription">
        <source>When a constructor calls a virtual method, the constructor for the instance that invokes the method may not have executed.</source>
        <target state="translated">コンストラクターが仮想メソッドを呼び出すときに、メソッドを呼び出すインスタンスのコンストラクターは実行されていない可能性があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructorsMessage">
        <source>Do not call overridable methods in constructors</source>
        <target state="translated">コンストラクターのオーバーライド可能なメソッドを呼び出しません</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeMethodsShouldCallBaseClassDisposeTitle">
        <source>Dispose methods should call base class dispose</source>
        <target state="translated">Dispose メソッドが基底クラスの Dispose を呼び出す必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeMethodsShouldCallBaseClassDisposeDescription">
        <source>A type that implements System.IDisposable inherits from a type that also implements IDisposable. The Dispose method of the inheriting type does not call the Dispose method of the parent type. To fix a violation of this rule, call base.Dispose in your Dispose method.</source>
        <target state="translated">System.IDisposable を実装する型は、IDisposable も実装する型から継承されます。継承する型の Dispose メソッドは、親の型の Dispose メソッドを呼び出しません。このルールの違反を修正するには、Dispose メソッドで base.Dispose を呼び出します。</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeMethodsShouldCallBaseClassDisposeMessage">
        <source>Ensure that method '{0}' calls '{1}' in all possible control flow paths.</source>
        <target state="translated">考えられるすべての制御フロー パスで、メソッド '{0}' が '{1}' を呼び出すようにしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableTypesShouldDeclareFinalizerTitle">
        <source>Disposable types should declare finalizer</source>
        <target state="translated">破棄可能な型はファイナライザーを宣言しなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableTypesShouldDeclareFinalizerDescription">
        <source>A type that implements System.IDisposable and has fields that suggest the use of unmanaged resources does not implement a finalizer, as described by Object.Finalize.</source>
        <target state="translated">System.IDisposable を実装し、アンマネージ リソースの使用を推奨するフィールドを持っている型は、Object.Finalize で記述されているようにファイナライザーを実装しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableTypesShouldDeclareFinalizerMessage">
        <source>Disposable types should declare finalizer</source>
        <target state="translated">破棄可能な型はファイナライザーを宣言しなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="FinalizersShouldCallBaseClassFinalizerTitle">
        <source>Finalizers should call base class finalizer</source>
        <target state="translated">ファイナライザーは基底クラスのファイナライザーを呼び出さなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="FinalizersShouldCallBaseClassFinalizerDescription">
        <source>Finalization must be propagated through the inheritance hierarchy. To guarantee this, types must call their base class Finalize method in their own Finalize method.</source>
        <target state="translated">終了処理は、継承階層を通じて伝達される必要があります。これを保証するには、型が独自の Finalize メソッド内で基底クラスの Finalize メソッドを呼び出す必要があります。</target>
        <note />
      </trans-unit>
      <trans-unit id="FinalizersShouldCallBaseClassFinalizerMessage">
        <source>Finalizers should call base class finalizer</source>
        <target state="translated">ファイナライザーは基底クラスのファイナライザーを呼び出さなければなりません</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentsToFormattingMethodsTitle">
        <source>Provide correct arguments to formatting methods</source>
        <target state="translated">書式設定メソッドに正しい引数を指定します</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentsToFormattingMethodsDescription">
        <source>The format argument that is passed to System.String.Format does not contain a format item that corresponds to each object argument, or vice versa.</source>
        <target state="translated">System.String.Format に渡される書式引数には、各オブジェクト引数に対応する書式項目が含まれていないか、各書式項目に対応するオブジェクト引数が含まれていません。</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentsToFormattingMethodsMessage">
        <source>Provide correct arguments to formatting methods</source>
        <target state="translated">書式設定メソッドに正しい引数を指定します</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForNaNCorrectlyTitle">
        <source>Test for NaN correctly</source>
        <target state="translated">NaN に対して正しくテストします</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForNaNCorrectlyDescription">
        <source>This expression tests a value against Single.Nan or Double.Nan. Use Single.IsNan(Single) or Double.IsNan(Double) to test the value.</source>
        <target state="translated">この式は、Single.Nan または Double.Nan に対して値をテストします。Single.IsNan(Single) または Double.IsNan(Double) を使用して、値をテストしてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForNaNCorrectlyMessage">
        <source>Test for NaN correctly</source>
        <target state="translated">NaN に対して正しくテストします</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyTitle">
        <source>Attribute string literals should parse correctly</source>
        <target state="translated">属性文字列リテラルは、正しく解析する必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyDescription">
        <source>The string literal parameter of an attribute does not parse correctly for a URL, a GUID, or a version.</source>
        <target state="translated">属性の文字列リテラル パラメーターが URL、GUID、またはバージョンを正しく解析しません。</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyMessageDefault">
        <source>In the constructor of '{0}', change the value of argument '{1}', which is currently "{2}", to something that can be correctly parsed as '{3}'.</source>
        <target state="translated">'{0}' のコンストラクター内にある引数 '{1}' の値 (現在は "{2}") を、'{3}' として正しく解析できる値に変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyMessageEmpty">
        <source>In the constructor of '{0}', change the value of argument '{1}', which is currently an empty string (""), to something that can be correctly parsed as '{2}'.</source>
        <target state="translated">'{0}' のコンストラクター内にある引数 '{1}' の値は現在空の文字列 ("") になっています。'{2}' として正しく解析できる値に変更してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidZeroLengthArrayAllocationsTitle">
        <source>Avoid zero-length array allocations.</source>
        <target state="translated">長さ 0 の配列の割り当てを避けます。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidZeroLengthArrayAllocationsMessage">
        <source>Avoid unnecessary zero-length array allocations.  Use {0} instead.</source>
        <target state="translated">不要な長さ 0 の配列の割り当てを避けます。代わりに {0} を使用してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyTitle">
        <source>Do not use Enumerable methods on indexable collections. Instead use the collection directly</source>
        <target state="translated">インデックス可能なコレクションで Enumerable メソッドを使用しません。代わりに、コレクションを直接使用します</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyDescription">
        <source>This collection is directly indexable. Going through LINQ here causes unnecessary allocations and CPU work.</source>
        <target state="translated">このコレクションは、直接インデックス可能です。ここで LINQ を実行すると、不要な割り当てと CPU 作業が生じます。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyMessage">
        <source>Do not use Enumerable methods on indexable collections. Instead use the collection directly</source>
        <target state="translated">インデックス可能なコレクションで Enumerable メソッドを使用しません。代わりに、コレクションを直接使用します</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureInfoTitle">
        <source>Specify CultureInfo</source>
        <target state="translated">CultureInfo を指定します</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureInfoDescription">
        <source>A method or constructor calls a member that has an overload that accepts a System.Globalization.CultureInfo parameter, and the method or constructor does not call the overload that takes the CultureInfo parameter. When a CultureInfo or System.IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales. If the result will be displayed to the user, specify 'CultureInfo.CurrentCulture' as the 'CultureInfo' parameter. Otherwise, if the result will be stored and accessed by software, such as when it is persisted to disk or to a database, specify 'CultureInfo.InvariantCulture'.</source>
        <target state="translated">メソッドまたはコンストラクターは、System.Globalization.CultureInfo パラメーターを受け取るオーバーロードを持つメンバーを呼び出します。CultureInfo パラメーターを受け取るオーバーロードは呼び出しません。CultureInfo または System.IFormatProvider オブジェクトが指定されない場合、オーバーロードされたメンバーによって指定される既定値は、一部のロケールでは期待どおりの効果がないことがあります。結果がユーザーに表示される場合は、'CultureInfo' パラメーターとして 'CultureInfo.CurrentCulture' を指定してください。そうではなく、結果がソフトウェアによって格納およびアクセスされる場合 (結果がディスクやデータベースに永続的に保存される場合など) は、'CultureInfo.InvariantCulture' を指定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureInfoMessage">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">'{0}' の動作は、現在のユーザーのロケール設定によって異なる場合があります。'{1}' 内のこの呼び出しを '{2}' への呼び出しに置き換えてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderTitle">
        <source>Specify IFormatProvider</source>
        <target state="translated">IFormatProvider を指定します</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderDescription">
        <source>A method or constructor calls one or more members that have overloads that accept a System.IFormatProvider parameter, and the method or constructor does not call the overload that takes the IFormatProvider parameter. When a System.Globalization.CultureInfo or IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales. If the result will be based on the input from/output displayed to the user, specify 'CultureInfo.CurrentCulture' as the 'IFormatProvider'. Otherwise, if the result will be stored and accessed by software, such as when it is loaded from disk/database and when it is persisted to disk/database, specify 'CultureInfo.InvariantCulture'</source>
        <target state="translated">メソッドまたはコンストラクターは、System.IFormatProvider パラメーターを受け取るオーバーロードを持つ 1 つ以上のメンバーを呼び出します。IFormatProvider パラメーターを受け取るオーバーロードは呼び出しません。System.Globalization.CultureInfo または IFormatProvider オブジェクトが指定されない場合、オーバーロードされたメンバーによって指定される既定値は、一部のロケールでは期待どおりの効果がないことがあります。結果がユーザーからの入力およびユーザーに表示される出力に基づく場合、'IFormatProvider' として 'CultureInfo.CurrentCulture' を指定します。そうではなく、結果がソフトウェアによって格納およびアクセスされる場合 (結果がディスク/データベースから読み込まれる場合やディスク/データベースに永続的に保存される場合など) は、'CultureInfo.InvariantCulture' を指定します</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageIFormatProviderAlternateString">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">'{0}' の動作は、現在のユーザーのロケール設定によって異なる場合があります。'{1}' 内のこの呼び出しを '{2}' への呼び出しに置き換えてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageIFormatProviderAlternate">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">'{0}' の動作は、現在のユーザーのロケール設定によって異なる場合があります。'{1}' 内のこの呼び出しを '{2}' への呼び出しに置き換えてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageUICultureString">
        <source>'{0}' passes '{1}' as the 'IFormatProvider' parameter to '{2}'. This property returns a culture that is inappropriate for formatting methods.</source>
        <target state="translated">'{0}' は '{1}' を 'IFormatProvider' パラメーターとして '{2}' に渡します。このプロパティは、書式設定メソッドに不適切なカルチャを返します。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageUICulture">
        <source>'{0}' passes '{1}' as the 'IFormatProvider' parameter to '{2}'. This property returns a culture that is inappropriate for formatting methods.</source>
        <target state="translated">'{0}' は '{1}' を 'IFormatProvider' パラメーターとして '{2}' に渡します。このプロパティは、書式設定メソッドに不適切なカルチャを返します。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonTitle">
        <source>Specify StringComparison</source>
        <target state="translated">StringComparison を指定します</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonDescription">
        <source>A string comparison operation uses a method overload that does not set a StringComparison parameter. If the result will be displayed to the user, such as when sorting a list of items for display in a list box, specify 'StringComparison.CurrentCulture' or 'StringComparison.CurrentCultureIgnoreCase' as the 'StringComparison' parameter. If comparing case-insensitive identifiers, such as file paths, environment variables, or registry keys and values, specify 'StringComparison.OrdinalIgnoreCase'. Otherwise, if comparing case-sensitive identifiers, specify 'StringComparison.Ordinal'.</source>
        <target state="translated">文字列比較操作では、StringComparison パラメーターを設定しないメソッド オーバーロードを使用します。結果がユーザーに表示される場合 (リスト ボックスに表示するために項目のリストを並べ替える場合など) は、'StringComparison' パラメーターとして 'StringComparison.CurrentCulture' または 'StringComparison.CurrentCultureIgnoreCase' を指定します。大文字と小文字が区別されない識別子 (ファイル パス、環境変数、レジストリのキーと値など) を比較する場合は、'StringComparison.OrdinalIgnoreCase' を指定します。そうではなく、大文字と小文字が区別される識別子を比較する場合は、'StringComparison.Ordinal' を指定します。</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonMessage">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">'{0}' の動作は、現在のユーザーのロケール設定によって異なる場合があります。'{1}' 内のこの呼び出しを '{2}' への呼び出しに置き換えてください。</target>
        <note />
      </trans-unit>
      <trans-unit id="NormalizeStringsToUppercaseTitle">
        <source>Normalize strings to uppercase</source>
        <target state="translated">文字列を大文字に標準化します</target>
        <note />
      </trans-unit>
      <trans-unit id="NormalizeStringsToUppercaseDescription">
        <source>Strings should be normalized to uppercase. A small group of characters cannot make a round trip when they are converted to lowercase. To make a round trip means to convert the characters from one locale to another locale that represents character data differently, and then to accurately retrieve the original characters from the converted characters.</source>
        <target state="translated">文字列は、大文字に標準化する必要があります。一部の文字は、小文字に変換した場合、ラウンド トリップできなくなります。ラウンド トリップとは、文字をあるロケールから、文字データを異なる方式で表す別のロケールに変換した後、変換された文字から元の文字を正確に取得することを意味します。</target>
        <note />
      </trans-unit>
      <trans-unit id="NormalizeStringsToUppercaseMessageToUpper">
        <source>In method '{0}', replace the call to '{1}' with '{2}'.</source>
        <target state="translated">メソッド '{0}' で、'{1}' の呼び出しを '{2}' に置き換えます。</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyTitle">
        <source>Dispose methods should call SuppressFinalize</source>
        <target state="translated">Dispose メソッドは、SuppressFinalize を呼び出す必要があります</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyDescription">
        <source>A method that is an implementation of Dispose does not call GC.SuppressFinalize; or a method that is not an implementation of Dispose calls GC.SuppressFinalize; or a method calls GC.SuppressFinalize and passes something other than this (Me in Visual?Basic).</source>
        <target state="translated">Dispose の実装であるメソッドは GC.SuppressFinalize を呼び出しません。または、Dispose の実装ではないメソッドは GC.SuppressFinalize を呼び出します。または、メソッドは GC.SuppressFinalize を呼び出し、this (Visual Basic では Me) 以外のものを渡します。</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageNotCalledWithFinalizer">
        <source>Change {0} to call {1}. This will prevent unnecessary finalization of the object once it has been disposed and it has fallen out of scope.</source>
        <target state="translated">{1} を呼び出すように {0} を変更します。これにより、オブジェクトが破棄されてスコープ外になった場合の、不要な終了処理を回避できます。</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageNotCalled">
        <source>Change {0} to call {1}. This will prevent derived types that introduce a finalizer from needing to re-implement 'IDisposable' to call it.</source>
        <target state="translated">{1} を呼び出すように {0} を変更します。これにより、ファイナライザーを導入する派生型で、その呼び出しのために 'IDisposable' を再実装する必要がなくなります。</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageNotPassedThis">
        <source>{0} calls {1} on something other than itself. Change the call site to pass 'this' ('Me' in Visual Basic) instead.</source>
        <target state="translated">{0} が、それ以外に対して {1} を呼び出します。呼び出しサイトを変更して、'this' (Visual Basic では 'Me') を渡します。</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageOutsideDispose">
        <source>{0} calls {1}, a method that is typically only called within an implementation of 'IDisposable.Dispose'. Refer to the IDisposable pattern for more information.</source>
        <target state="translated">{0} は、通常 'IDisposable.Dispose' の実装内でのみ呼び出されるメソッド {1} を呼び出しています。詳細については、IDisposable パターンを参照してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyTitle">
        <source>Instantiate argument exceptions correctly</source>
        <target state="translated">引数の例外を正しくインスタンス化します</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyDescription">
        <source>A call is made to the default (parameterless) constructor of an exception type that is or derives from ArgumentException, or an incorrect string argument is passed to a parameterized constructor of an exception type that is or derives from ArgumentException.</source>
        <target state="translated">ArgumentException またはそれから派生した例外の種類の既定の (パラメーターのない) コンストラクターに対して呼び出しが行われます。または、正しくない文字列引数が、ArgumentException またはそれから派生した例外の種類のパラメーター化されたコンストラクターに渡されます。</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyMessageNoArguments">
        <source>Call the {0} constructor that contains a message and/or paramName parameter.</source>
        <target state="translated">メッセージおよび paramName パラメーターまたはそのいずれかを含む {0} コンストラクターを呼び出します。</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyMessageIncorrectMessage">
        <source>Method {0} passes parameter name '{1}' as the {2} argument to a {3} constructor. Replace this argument with a descriptive message and pass the parameter name in the correct position.</source>
        <target state="translated">メソッド {0} は、パラメーター名 '{1}' を {2} 引数として {3} コンストラクターに渡します。この引数を説明メッセージに置き換え、正しい位置にパラメーター名を渡してください。</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyMessageIncorrectParameterName">
        <source>Method {0} passes '{1}' as the {2} argument to a {3} constructor. Replace this argument with one of the method's parameter names. Note that the provided parameter name should have the exact casing as declared on the method.</source>
        <target state="translated">メソッド {0} は、'{1}' を {2} 引数として {3} コンストラクターに渡します。この引数をメソッドのいずれかのパラメーター名に置き換えてください。指定されたパラメーター名は、メソッドで宣言されている大文字と小文字の区別を正確に含んでいなければなりません。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseArrayEmpty">
        <source>Use Array.Empty</source>
        <target state="translated">Array.Empty を使用します</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ru" original="../SystemRuntimeAnalyzersResources.resx">
    <body>
      <trans-unit id="UseOrdinalStringComparisonTitle">
        <source>Use ordinal stringcomparison</source>
        <target state="translated">Используйте stringcomparison по порядковым номерам</target>
        <note />
      </trans-unit>
      <trans-unit id="UseOrdinalStringComparisonDescription">
        <source>A string comparison operation that is nonlinguistic does not set the StringComparison parameter to either Ordinal or OrdinalIgnoreCase. By explicitly setting the parameter to either StringComparison.Ordinal or StringComparison.OrdinalIgnoreCase, your code often gains speed, becomes more correct, and becomes more reliable.</source>
        <target state="translated">Нелингвистическая операция сравнения строк не задает для параметра StringComparison значение Ordinal или OrdinalIgnoreCase. Задав явным образом значение StringComparison.Ordinal или StringComparison.OrdinalIgnoreCase для параметра, можно сделать код более быстродействующим, корректным и надежным.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseOrdinalStringComparisonMessageStringComparison">
        <source>{0} passes '{1}' as the 'StringComparison' parameter to {2}. To perform a non-linguistic comparison, specify 'StringComparison.Ordinal' or 'StringComparison.OrdinalIgnoreCase' instead.</source>
        <target state="translated">{0} передает "{1}" в {2} в качестве параметра "StringComparison". Чтобы выполнить нелингвистическое сравнение, укажите "StringComparison.Ordinal" или "StringComparison.OrdinalIgnoreCase".</target>
        <note />
      </trans-unit>
      <trans-unit id="UseOrdinalStringComparisonMessageStringComparer">
        <source>{0} passes '{1}' as the 'StringComparer' parameter to {2}. To perform a non-linguistic comparison, specify 'StringComparer.Ordinal' or 'StringComparer.OrdinalIgnoreCase' instead.</source>
        <target state="translated">{0} передает "{1}" в {2} в качестве параметра "StringComparer". Чтобы выполнить нелингвистическое сравнение, укажите "StringComparer.Ordinal" или "StringComparer.OrdinalIgnoreCase".</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseTimersThatPreventPowerStateChangesTitle">
        <source>Do not use timers that prevent power state changes</source>
        <target state="translated">Не используйте таймеры, препятствующие изменению состояния электропитания</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseTimersThatPreventPowerStateChangesDescription">
        <source>Higher-frequency periodic activity will keep the CPU busy and interfere with power-saving idle timers that turn off the display and hard disks.</source>
        <target state="translated">Периодическая активность с более высокой частотой заставит ЦП переключаться в активный режим и помешает работе энергосберегающих таймеров простоя, которые отключают дисплей и жесткие диски.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseTimersThatPreventPowerStateChangesMessage">
        <source>Do not use timers that prevent power state changes</source>
        <target state="translated">Не используйте таймеры, препятствующие изменению состояния электропитания</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnsealedAttributesTitle">
        <source>Avoid unsealed attributes</source>
        <target state="translated">Избегайте распечатанных атрибутов</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnsealedAttributesDescription">
        <source>The .NET Framework class library provides methods for retrieving custom attributes. By default, these methods search the attribute inheritance hierarchy. Sealing the attribute eliminates the search through the inheritance hierarchy and can improve performance.</source>
        <target state="translated">Эта библиотека классов платформы .NET Framework предоставляет методы для извлечения настраиваемых атрибутов. По умолчанию эти методы выполняют поиск по иерархии наследования атрибутов. Запечатывание атрибута устраняет поиск по иерархии наследования и позволяет повысить производительность.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnsealedAttributesMessage">
        <source>Avoid unsealed attributes</source>
        <target state="translated">Избегайте распечатанных атрибутов</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForEmptyStringsUsingStringLengthTitle">
        <source>Test for empty strings using string length</source>
        <target state="translated">Проверяйте наличие пустых строк, используя длину строки</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForEmptyStringsUsingStringLengthDescription">
        <source>Comparing strings by using the String.Length property or the String.IsNullOrEmpty method is significantly faster than using Equals.</source>
        <target state="translated">Сравнение строк с помощью свойства String.Length или метода String.IsNullOrEmpty выполняется значительно быстрее, чем при использовании Equals.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForEmptyStringsUsingStringLengthMessage">
        <source>Test for empty strings using 'string.Length' property or 'string.IsNullOrEmpty' method instead of an Equality check.</source>
        <target state="translated">Проверяйте наличие пустых строк, используя свойство "string.Length" или метод "string.IsNullOrEmpty" вместо проверки равенства.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotLockOnObjectsWithWeakIdentityTitle">
        <source>Do not lock on objects with weak identity</source>
        <target state="translated">Не блокируйте слабо идентифицируемые объекты</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotLockOnObjectsWithWeakIdentityDescription">
        <source>An object is said to have a weak identity when it can be directly accessed across application domain boundaries. A thread that tries to acquire a lock on an object that has a weak identity can be blocked by a second thread in a different application domain that has a lock on the same object.</source>
        <target state="translated">Слабо идентифицируемым называется объект, к которому можно обратиться напрямую через границы домена приложения. Поток, пытающийся получить блокировку для слабо идентифицируемого объекта, может быть заблокирован вторым потоком в другом домене приложения, получившим блокировку того же объекта.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotLockOnObjectsWithWeakIdentityMessage">
        <source>Do not lock on objects with weak identity</source>
        <target state="translated">Не блокируйте слабо идентифицируемые объекты</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchCorruptedStateExceptionsInGeneralHandlersTitle">
        <source>Do not catch corrupted state exceptions in general handlers.</source>
        <target state="translated">Не перехватывайте исключения поврежденного состояния в общих обработчиках.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchCorruptedStateExceptionsInGeneralHandlersDescription">
        <source>Do not author general catch handlers in code that receives corrupted state exceptions.</source>
        <target state="translated">Не создавайте общие обработчики catch в коде, получающем исключения поврежденного состояния.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchCorruptedStateExceptionsInGeneralHandlersMessage">
        <source>Do not catch corrupted state exceptions in general handlers.</source>
        <target state="translated">Не перехватывайте исключения поврежденного состояния в общих обработчиках.</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsTitle">
        <source>Rethrow to preserve stack details</source>
        <target state="translated">Повторно порождайте исключения для сохранения сведений стека</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsDescription">
        <source>An exception is rethrown and the exception is explicitly specified in the throw statement. If an exception is rethrown by specifying the exception in the throw statement, the list of method calls between the original method that threw the exception and the current method is lost.</source>
        <target state="translated">Исключение выдается повторно и явно указывается в операторе throw. Если исключение порождается повторно путем его указания в операторе throw, список вызовов метода между исходным методом, породившим исключение, и текущим методом теряется.</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsMessage">
        <source>Rethrow to preserve stack details</source>
        <target state="translated">Повторно порождайте исключения для сохранения сведений стека</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesTitle">
        <source>Do not raise reserved exception types</source>
        <target state="translated">Не порождайте исключения зарезервированных типов</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesDescription">
        <source>An exception of type that is not sufficiently specific or reserved by the runtime should never be raised by user code. This makes the original error difficult to detect and debug. If this exception instance might be thrown, use a different exception type.</source>
        <target state="translated">Пользовательский код никогда не должен порождать исключение типа, который является недостаточно определенным либо зарезервирован средой выполнения. Это затрудняет обнаружение и отладку исходной ошибки. Если экземпляр этого исключения может быть порожден, используйте другой тип исключения.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesMessageTooGeneric">
        <source>Exception type {0} is not sufficiently specific.</source>
        <target state="translated">Тип исключения {0} является недостаточно определенным.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesMessageReserved">
        <source>Exception type {0} is reserved by the runtime.</source>
        <target state="translated">Тип исключения {0} зарезервирован средой выполнения.</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeValueTypeStaticFieldsInlineTitle">
        <source>Initialize value type static fields inline</source>
        <target state="translated">Используйте встроенную инициализацию статических полей типов значений</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeReferenceTypeStaticFieldsInlineTitle">
        <source>Initialize reference type static fields inline</source>
        <target state="translated">Используйте встроенную инициализацию статических полей ссылочных типов</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeValueTypeStaticFieldsInlineDescription">
        <source>A value type declares an explicit static constructor. To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor.</source>
        <target state="translated">Тип значения объявляет явный статический конструктор. Чтобы устранить нарушение этого правила, инициализируйте все статические данные при объявлении конструктора и удалите его.</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeReferenceTypeStaticFieldsInlineDescription">
        <source>A reference type declares an explicit static constructor. To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor.</source>
        <target state="translated">Ссылочный тип объявляет явный статический конструктор. Чтобы устранить нарушение этого правила, инициализируйте все статические данные при объявлении конструктора и удалите его.</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeStaticFieldsInlineMessage">
        <source>Initialize all static fields in '{0}' when those fields are declared and remove the explicit static constructor</source>
        <target state="translated">Инициализируйте все статические поля в "{0}" при их объявлении и удалите явный статический конструктор.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableFieldsShouldBeDisposedTitle">
        <source>Disposable fields should be disposed</source>
        <target state="translated">Следует высвобождать высвобождаемые поля</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableFieldsShouldBeDisposedDescription">
        <source>A type that implements System.IDisposable declares fields that are of types that also implement IDisposable. The Dispose method of the field is not called by the Dispose method of the declaring type.</source>
        <target state="translated">Тип, реализующий System.IDisposable, объявляет поля, которые относятся к типам, также реализующим IDisposable. Метод Dispose поля не вызывается методом Dispose объявляющего типа.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableFieldsShouldBeDisposedMessage">
        <source>Disposable fields should be disposed</source>
        <target state="translated">Следует высвобождать высвобождаемые поля</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructorsTitle">
        <source>Do not call overridable methods in constructors</source>
        <target state="translated">Не вызывайте переопределяемые методы в конструкторах</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructorsDescription">
        <source>When a constructor calls a virtual method, the constructor for the instance that invokes the method may not have executed.</source>
        <target state="translated">Когда конструктор вызывает виртуальный метод, конструктор может не выполняться для экземпляра, вызывающего этот метод.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructorsMessage">
        <source>Do not call overridable methods in constructors</source>
        <target state="translated">Не вызывайте переопределяемые методы в конструкторах</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeMethodsShouldCallBaseClassDisposeTitle">
        <source>Dispose Methods Should Call Base Class Dispose</source>
        <target state="translated">Методы Dispose должны вызывать базовый класс Dispose</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeMethodsShouldCallBaseClassDisposeDescription">
        <source>If a type inherits from a disposable type, it must call the Dispose method of the base type from its own Dispose method.</source>
        <target state="translated">Если тип наследует от высвобождаемого типа, он должен вызывать метод Dispose базового типа из собственного метода Dispose.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeMethodsShouldCallBaseClassDisposeMessage">
        <source>Dispose Methods Should Call Base Class Dispose</source>
        <target state="translated">Методы Dispose должны вызывать базовый класс Dispose</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableTypesShouldDeclareFinalizerTitle">
        <source>Disposable types should declare finalizer</source>
        <target state="translated">Высвобождаемые типы должны объявлять методы завершения</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableTypesShouldDeclareFinalizerDescription">
        <source>A type that implements System.IDisposable and has fields that suggest the use of unmanaged resources does not implement a finalizer, as described by Object.Finalize.</source>
        <target state="translated">Тип, который реализует System.IDisposable и имеет поля, предполагающие использование неуправляемых ресурсов, не реализует метод завершения, как описано Object.Finalize.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableTypesShouldDeclareFinalizerMessage">
        <source>Disposable types should declare finalizer</source>
        <target state="translated">Высвобождаемые типы должны объявлять методы завершения</target>
        <note />
      </trans-unit>
      <trans-unit id="FinalizersShouldCallBaseClassFinalizerTitle">
        <source>Finalizers should call base class finalizer</source>
        <target state="translated">Методы завершения должны вызывать метод завершения базового класса</target>
        <note />
      </trans-unit>
      <trans-unit id="FinalizersShouldCallBaseClassFinalizerDescription">
        <source>Finalization must be propagated through the inheritance hierarchy. To guarantee this, types must call their base class Finalize method in their own Finalize method.</source>
        <target state="translated">Завершение должно распространяться через иерархию наследования. Для этого типы должны вызывать метод Finalize своего базового класса в своем собственном методе Finalize.</target>
        <note />
      </trans-unit>
      <trans-unit id="FinalizersShouldCallBaseClassFinalizerMessage">
        <source>Finalizers should call base class finalizer</source>
        <target state="translated">Методы завершения должны вызывать метод завершения базового класса</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentsToFormattingMethodsTitle">
        <source>Provide correct arguments to formatting methods</source>
        <target state="translated">Задайте правильные аргументы для методов форматирования</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentsToFormattingMethodsDescription">
        <source>The format argument that is passed to System.String.Format does not contain a format item that corresponds to each object argument, or vice versa.</source>
        <target state="translated">Передаваемый в System.String.Format аргумент формата не содержит элемент формата, соответствующий каждому из аргументов объекта, или наоборот.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentsToFormattingMethodsMessage">
        <source>Provide correct arguments to formatting methods</source>
        <target state="translated">Задайте правильные аргументы для методов форматирования</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForNaNCorrectlyTitle">
        <source>Test for NaN correctly</source>
        <target state="translated">Правильно выполняйте проверку NaN</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForNaNCorrectlyDescription">
        <source>This expression tests a value against Single.Nan or Double.Nan. Use Single.IsNan(Single) or Double.IsNan(Double) to test the value.</source>
        <target state="translated">Это выражение проверяет значение на соответствие Single.Nan или Double.Nan. Используйте Single.IsNan(Single) или Double.IsNan(Double) для проверки значения.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForNaNCorrectlyMessage">
        <source>Test for NaN correctly</source>
        <target state="translated">Правильно выполняйте проверку NaN</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyTitle">
        <source>Attribute string literals should parse correctly</source>
        <target state="translated">Синтаксический анализ строковых литералов атрибута должен осуществляться правильно</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyDescription">
        <source>The string literal parameter of an attribute does not parse correctly for a URL, a GUID, or a version.</source>
        <target state="translated">Параметр строкового литерала атрибута анализируется неправильно для URL-адреса, GUID или версии.</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyMessageDefault">
        <source>In the constructor of '{0}', change the value of argument '{1}', which is currently "{2}", to something that can be correctly parsed as '{3}'.</source>
        <target state="translated">В конструкторе "{0}" измените аргумент "{1}", который сейчас равен "{2}", на значение, обеспечивающее правильный анализ в качестве "{3}".</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyMessageEmpty">
        <source>In the constructor of '{0}', change the value of argument '{1}', which is currently an empty string (""), to something that can be correctly parsed as '{2}'.</source>
        <target state="translated">В конструкторе "{0}" измените аргумент "{1}", который сейчас равен пустой строке (""), на значение, обеспечивающее правильный анализ в качестве "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidZeroLengthArrayAllocationsTitle">
        <source>Avoid zero-length array allocations.</source>
        <target state="translated">Старайтесь не выделять массивы нулевой длины.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidZeroLengthArrayAllocationsMessage">
        <source>Avoid unnecessary zero-length array allocations.  Use {0} instead.</source>
        <target state="translated">Старайтесь не выделять массивы нулевой длины без необходимости.  Вместо этого используйте {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyTitle">
        <source>Do not use Enumerable methods on indexable collections. Instead use the collection directly</source>
        <target state="translated">Не используйте метод Enumerable для индексируемых коллекций. Вместо этого используйте непосредственно коллекцию</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyDescription">
        <source>This collection is directly indexable. Going through LINQ here causes unnecessary allocations and CPU work.</source>
        <target state="translated">Эта коллекция индексируется напрямую. В этом случае применение LINQ приводит к ненужным выделениям и нагрузке на ЦП.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyMessage">
        <source>Do not use Enumerable methods on indexable collections. Instead use the collection directly</source>
        <target state="translated">Не используйте метод Enumerable для индексируемых коллекций. Вместо этого используйте непосредственно коллекцию</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureInfoTitle">
        <source>Specify CultureInfo</source>
        <target state="translated">Укажите CultureInfo</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureInfoDescription">
        <source>A method or constructor calls a member that has an overload that accepts a System.Globalization.CultureInfo parameter, and the method or constructor does not call the overload that takes the CultureInfo parameter. When a CultureInfo or System.IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales. If the result will be displayed to the user, specify 'CultureInfo.CurrentCulture' as the 'CultureInfo' parameter. Otherwise, if the result will be stored and accessed by software, such as when it is persisted to disk or to a database, specify 'CultureInfo.InvariantCulture'.</source>
        <target state="translated">Метод или конструктор вызывает элемент, который имеет перегрузку, принимающую параметр System.Globalization.CultureInfo, при этом данный метод или конструктор не вызывает перегрузку, принимающую параметр CultureInfo. Если объект CultureInfo или System.IFormatProvider не задан, значение по умолчанию, предоставленное перегруженным элементом, может не оказывать требуемое вам воздействие для всех языковых стандартов. Если результат выводится пользователю, укажите "CultureInfo.CurrentCulture" в качестве параметра "CultureInfo". В противном случае, если результат сохраняется и используется программным обеспечением, например при сохранении его на диск или в базу данных, укажите "CultureInfo.InvariantCulture".</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureInfoMessage">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">Поведение "{0}" может изменяться в зависимости от параметров языкового стандарта текущего пользователя. Замените этот вызов в "{1}" на вызов "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderTitle">
        <source>Specify IFormatProvider</source>
        <target state="translated">Укажите IFormatProvider</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderDescription">
        <source>A method or constructor calls one or more members that have overloads that accept a System.IFormatProvider parameter, and the method or constructor does not call the overload that takes the IFormatProvider parameter. When a System.Globalization.CultureInfo or IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales. If the result will be based on the input from/output displayed to the user, specify 'CultureInfo.CurrentCulture' as the 'IFormatProvider'. Otherwise, if the result will be stored and accessed by software, such as when it is loaded from disk/database and when it is persisted to disk/database, specify 'CultureInfo.InvariantCulture'</source>
        <target state="translated">Метод или конструктор вызывает один или несколько элементов, которые имеют перегрузки, принимающие параметр System.IFormatProvider, при этом данный метод или конструктор не вызывает перегрузку, принимающую параметр IFormatProvider. Если объект System.Globalization.CultureInfo или IFormatProvider не задан, значение по умолчанию, предоставленное перегруженным элементом, может не оказывать требуемое вам воздействие для всех языковых стандартов. Если результат зависит от вводимых пользователям данных или предоставляемых ему выходных данных, укажите "CultureInfo.CurrentCulture" в качестве параметра "IFormatProvider". В противном случае, если результат сохраняется и используется программным обеспечением, например при загрузке его с диска или из базы данных и при сохранении в этих расположениях, укажите "CultureInfo.InvariantCulture".</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageIFormatProviderAlternateString">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">Поведение "{0}" может изменяться в зависимости от параметров языкового стандарта текущего пользователя. Замените этот вызов в "{1}" на вызов "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageIFormatProviderAlternate">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">Поведение "{0}" может изменяться в зависимости от параметров языкового стандарта текущего пользователя. Замените этот вызов в "{1}" на вызов "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageUICultureString">
        <source>'{0}' passes '{1}' as the 'IFormatProvider' parameter to '{2}'. This property returns a culture that is inappropriate for formatting methods.</source>
        <target state="translated">"{0}" передает "{1}" в "{2}" в качестве параметра "IFormatProvider". Это свойство возвращает язык и региональные параметры, не подходящие для методов форматирования.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageUICulture">
        <source>'{0}' passes '{1}' as the 'IFormatProvider' parameter to '{2}'. This property returns a culture that is inappropriate for formatting methods.</source>
        <target state="translated">"{0}" передает "{1}" в "{2}" в качестве параметра "IFormatProvider". Это свойство возвращает язык и региональные параметры, не подходящие для методов форматирования.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonTitle">
        <source>Specify StringComparison</source>
        <target state="translated">Укажите StringComparison</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonDescription">
        <source>A string comparison operation uses a method overload that does not set a StringComparison parameter. If the result will be displayed to the user, such as when sorting a list of items for display in a list box, specify 'StringComparison.CurrentCulture' or 'StringComparison.CurrentCultureIgnoreCase' as the 'StringComparison' parameter. If comparing case-insensitive identifiers, such as file paths, environment variables, or registry keys and values, specify 'StringComparison.OrdinalIgnoreCase'. Otherwise, if comparing case-sensitive identifiers, specify 'StringComparison.Ordinal'.</source>
        <target state="translated">Операция сравнения строк использует перегрузку метода, не задающую параметр StringComparison. Если результат будет отображаться для пользователя, например при сортировке элементов в списке, задайте для параметра "StringComparison" значение "StringComparison.CurrentCulture" или "StringComparison.CurrentCultureIgnoreCase". При сравнении идентификаторов, не чувствительных к регистру, таких как пути к файлам, переменные среды или разделы и значения реестра, используйте "StringComparison.OrdinalIgnoreCase". В противном случае укажите "StringComparison.Ordinal" при сравнении чувствительных к регистру идентификаторов.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonMessage">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">Поведение "{0}" может изменяться в зависимости от параметров языкового стандарта текущего пользователя. Замените этот вызов в "{1}" на вызов "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="NormalizeStringsToUppercaseTitle">
        <source>Normalize strings to uppercase</source>
        <target state="translated">Нормализуйте строки до прописных букв</target>
        <note />
      </trans-unit>
      <trans-unit id="NormalizeStringsToUppercaseDescription">
        <source>Strings should be normalized to uppercase. A small group of characters cannot make a round trip when they are converted to lowercase. To make a round trip means to convert the characters from one locale to another locale that represents character data differently, and then to accurately retrieve the original characters from the converted characters.</source>
        <target state="translated">Строки следует нормализовать до прописных букв. Небольшая группа символов не может выполнить круговой путь, если они преобразованы в нижний регистр. Круговой путь заключается в преобразовании символов из одного языкового стандарта в другой, где символьные данные представлены иначе, и последующем точном извлечении исходных символов из преобразованных.</target>
        <note />
      </trans-unit>
      <trans-unit id="NormalizeStringsToUppercaseMessageToUpper">
        <source>In method '{0}', replace the call to '{1}' with '{2}'.</source>
        <target state="translated">В методе "{0}" замените вызов "{1}" на "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyTitle">
        <source>Dispose methods should call SuppressFinalize</source>
        <target state="translated">Методы Dispose должны вызывать SuppressFinalize</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyDescription">
        <source>A method that is an implementation of Dispose does not call GC.SuppressFinalize; or a method that is not an implementation of Dispose calls GC.SuppressFinalize; or a method calls GC.SuppressFinalize and passes something other than this (Me in Visual?Basic).</source>
        <target state="translated">Метод, являющийся реализацией Dispose, не вызывает GC.SuppressFinalize, метод, не являющийся реализацией Dispose, вызывает GC.SuppressFinalize, либо метод вызывает GC.SuppressFinalize и передает нечто иное (Me в Visual Basic).</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageNotCalledWithFinalizer">
        <source>Change {0} to call {1}. This will prevent unnecessary finalization of the object once it has been disposed and it has fallen out of scope.</source>
        <target state="translated">Замените {0} вызовом {1}. Это предотвратит ненужное завершение объекта после его высвобождения и выхода из области видимости.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageNotCalled">
        <source>Change {0} to call {1}. This will prevent derived types that introduce a finalizer from needing to re-implement 'IDisposable' to call it.</source>
        <target state="translated">Замените {0} вызовом {1}. В результате для производных типов, использующих метод завершения, отпадет необходимость в повторной реализации "IDisposable" для вызова этого метода.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageNotPassedThis">
        <source>{0} calls {1} on something other than itself. Change the call site to pass 'this' ('Me' in Visual Basic) instead.</source>
        <target state="translated">{0} вызывает {1} для другого объекта, а не для себя. Измените место вызова, чтобы передать вместо него "this" ("Me" в Visual Basic).</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageOutsideDispose">
        <source>{0} calls {1}, a method that is typically only called within an implementation of 'IDisposable.Dispose'. Refer to the IDisposable pattern for more information.</source>
        <target state="translated">{0} вызывает {1}, метод, который обычно вызывается только внутри реализации "IDisposable.Dispose". Дополнительные сведения см. в шаблоне IDisposable.</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyDescription">
        <source>A call is made to the default (parameterless) constructor of an exception type that is or derives from ArgumentException, or an incorrect string argument is passed to a parameterized constructor of an exception type that is or derives from ArgumentException.</source>
        <target state="translated">Выполняется вызов конструктора по умолчанию (без параметров) для типа исключения, который является ArgumentException или производным от него, либо в параметризованный конструктор для типа исключения, который является ArgumentException или производным от него, передается неправильный строковый аргумент.</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyMessageNoArguments">
        <source>Call the {0} constructor that contains a message and/or paramName parameter.</source>
        <target state="translated">Вызывайте конструктор {0}, который содержит сообщение и (или) параметр paramName.</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyMessageIncorrectMessage">
        <source>Method {0} passes parameter name '{1}' as the {2} argument to a {3} constructor. Replace this argument with a descriptive message and pass the parameter name in the correct position.</source>
        <target state="translated">Метод {0} передает имя параметра "{1}" в качестве аргумента {2} в конструктор {3}. Замените этот аргумент описательным сообщением и передайте имя этого параметра в правильном положении.</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyMessageIncorrectParameterName">
        <source>Method {0} passes '{1}' as the {2} argument to a {3} constructor. Replace this argument with one of the method's parameter names. Note that the provided parameter name should have the exact casing as declared on the method.</source>
        <target state="translated">Метод {0} передает "{1}" в качестве аргумента {2} в конструктор {3}. Замените этот аргумент одним из имен параметров метода. Заметьте, что предоставленное имя параметра должно использовать те же прописные и строчные буквы, как объявлено в методе.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseArrayEmpty">
        <source>Use Array.Empty</source>
        <target state="translated">Используйте Array.Empty</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyCodeFixIncorrectMessage">
        <source>Pass parameter name in the correct position</source>
        <target state="new">Pass parameter name in the correct position</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyCodeFixIncorrectParameterName">
        <source>Pass message in the correct position</source>
        <target state="new">Pass message in the correct position</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyCodeFixNoArguments">
        <source>Call {0} constructor</source>
        <target state="new">Call {0} constructor</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyTitle">
        <source>Instantiate ArgumentExceptions correctly</source>
        <target state="new">Instantiate ArgumentExceptions correctly</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyCodeFixSwappedMessageAndParameterName">
        <source>Swap message and parameter name</source>
        <target state="new">Swap message and parameter name</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyMessageSwappedMessageAndParameterName">
        <source>Method {0} confuses the {1} and {2} arguments passed to the {3} constructor.</source>
        <target state="new">Method {0} confuses the {1} and {2} arguments passed to the {3} constructor.</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
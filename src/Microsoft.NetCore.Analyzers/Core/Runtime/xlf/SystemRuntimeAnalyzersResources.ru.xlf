<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ru" original="../SystemRuntimeAnalyzersResources.resx">
    <body>
      <trans-unit id="AddNonSerializedAttributeCodeActionTitle">
        <source>Add the 'NonSerialized' attribute to this field.</source>
        <target state="translated">Добавьте атрибут "NonSerialized" в это поле.</target>
        <note />
      </trans-unit>
      <trans-unit id="AddSerializableAttributeCodeActionTitle">
        <source>Add Serializable attribute</source>
        <target state="translated">Добавить атрибут Serializable</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeDescription">
        <source>If a disposable object is not explicitly disposed before all references to it are out of scope, the object will be disposed at some indeterminate time when the garbage collector runs the finalizer of the object. Because an exceptional event might occur that will prevent the finalizer of the object from running, the object should be explicitly disposed instead.</source>
        <target state="translated">Если освобождаемый объект не высвобождается явно до того, как все ссылки на него оказываются вне области имен, объект будет высвобожден в некоторый заранее не определенный момент, когда сборщик мусора запустит завершающий метод объекта. Так как может возникнуть событие исключения, препятствующее выполнению метода завершения объекта, объект будет ликвидирован в явной форме.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeMayBeDisposedMessage">
        <source>Use recommended dispose pattern to ensure that object created by '{0}' is disposed on all paths. If possible, wrap the creation within a 'using' statement or a 'using' declaration. Otherwise, use a try-finally pattern, with a dedicated local variable declared before the try region and an unconditional Dispose invocation on non-null value in the 'finally' region, say 'x?.Dispose()'. If the object is explicitly disposed within the try region or the dispose ownership is transfered to another object or method, assign 'null' to the local variable just after such an operation to prevent double dispose in 'finally'.</source>
        <target state="translated">Используйте рекомендуемый шаблон удаления, чтобы убедиться, что объект, созданный "{0}", удален по всем путям. Если это возможно, заключите создание в оператор "using" или объявление "using". В противном случае используйте шаблон try-finally с выделенной локальной переменной, объявляемой до области try, и безусловным вызовом Dispose для отличного от NULL значения в области "finally", например "x?.Dispose()". Если объект явно удаляется в области try или владение удаления передается другому объекту или методу, назначьте "null" локальной переменной сразу после подобной операции, чтобы предотвратить двойное удаление в "finally".</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeMayBeDisposedOnExceptionPathsMessage">
        <source>Use recommended dispose pattern to ensure that object created by '{0}' is disposed on all exception paths. If possible, wrap the creation within a 'using' statement or a 'using' declaration. Otherwise, use a try-finally pattern, with a dedicated local variable declared before the try region and an unconditional Dispose invocation on non-null value in the 'finally' region, say 'x?.Dispose()'. If the object is explicitly disposed within the try region or the dispose ownership is transfered to another object or method, assign 'null' to the local variable just after such an operation to prevent double dispose in 'finally'.</source>
        <target state="translated">Используйте рекомендуемый шаблон удаления, чтобы убедиться, что объект, созданный "{0}", удален по всем путям исключений. Если это возможно, заключите создание в оператор "using" или объявление "using". В противном случае используйте шаблон try-finally с выделенной локальной переменной, объявляемой до области try, и безусловным вызовом Dispose для отличного от NULL значения в области "finally", например "x?.Dispose()". Если объект явно удаляется в области try или владение удаления передается другому объекту или методу, назначьте "null" локальной переменной сразу после подобной операции, чтобы предотвратить двойное удаление в "finally".</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeNotDisposedMessage">
        <source>Call System.IDisposable.Dispose on object created by '{0}' before all references to it are out of scope.</source>
        <target state="translated">Вызовите System.IDisposable.Dispose для объекта, созданного "{0}", прежде чем все ссылки на него будут вне области действия.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeNotDisposedOnExceptionPathsMessage">
        <source>Object created by '{0}' is not disposed along all exception paths. Call System.IDisposable.Dispose on the object before all references to it are out of scope.</source>
        <target state="translated">Объект, созданный "{0}", не уничтожается во всех путях исключений. Следует вызвать метод System.IDisposable.Dispose для этого объекта до того, как все ссылки на него будут находиться вне области действия.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeObjectsBeforeLosingScopeTitle">
        <source>Dispose objects before losing scope</source>
        <target state="translated">Ликвидировать объекты перед потерей области</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassLiteralsAsLocalizedParametersDescription">
        <source>A method passes a string literal as a parameter to a constructor or method in the .NET Framework class library and that string should be localizable. To fix a violation of this rule, replace the string literal with a string retrieved through an instance of the ResourceManager class.</source>
        <target state="translated">Метод передает строковый литерал в качестве параметра конструктору или методу в библиотеке классов .NET Framework, и эта строка должна быть локализуемой. Чтобы устранить нарушение этого правила, замените строковый литерал строкой, полученной через экземпляр класса ResourceManager.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassLiteralsAsLocalizedParametersMessage">
        <source>Method '{0}' passes a literal string as parameter '{1}' of a call to '{2}'. Retrieve the following string(s) from a resource table instead: "{3}".</source>
        <target state="translated">Метод "{0}" передает строку-литерал, как параметр "{1}" при вызове "{2}". Вместо этого выполните поиск следующих строк в таблице ресурсов: "{3}".</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotPassLiteralsAsLocalizedParametersTitle">
        <source>Do not pass literals as localized parameters</source>
        <target state="translated">Не передавать литералы в качестве локализованных параметров</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementISerializableCorrectlyDescription">
        <source>To fix a violation of this rule, make the GetObjectData method visible and overridable, and make sure that all instance fields are included in the serialization process or explicitly marked by using the NonSerializedAttribute attribute.</source>
        <target state="translated">Чтобы устранить нарушение этого правила, сделайте метод GetObjectData видимым и переопределяемым и убедитесь, что все поля экземпляра включены в процесс сериализации или явно помечены атрибутом NonSerializedAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementISerializableCorrectlyMessageDefault">
        <source>Add an implementation of GetObjectData to type {0}.</source>
        <target state="translated">Добавьте реализацию GetObjectData к типу {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementISerializableCorrectlyMessageMakeOverridable">
        <source>Make {0}.GetObjectData virtual and overridable.</source>
        <target state="translated">Сделайте {0}.GetObjectData виртуальным и переопределяемым.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementISerializableCorrectlyMessageMakeVisible">
        <source>Increase the accessibility of {0}.GetObjectData so that it is visible to derived types.</source>
        <target state="translated">Увеличьте уровень доступности {0}.GetObjectData, чтобы он был видим для производных типов.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementISerializableCorrectlyTitle">
        <source>Implement ISerializable correctly</source>
        <target state="translated">Правильно реализуйте ISerializable</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationConstructorsCodeActionTitle">
        <source>Implement Serialization constructor</source>
        <target state="translated">Реализовать конструктор сериализации</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationConstructorsDescription">
        <source>To fix a violation of this rule, implement the serialization constructor. For a sealed class, make the constructor private; otherwise, make it protected.</source>
        <target state="translated">Чтобы устранить нарушение этого правила, реализуйте конструктор сериализации. Для запечатанного класса сделайте конструктор закрытым; в противном случае сделайте его защищенным.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationConstructorsMessageCreateMagicConstructor">
        <source>Add a constructor to {0} with the following signature: 'protected {0}(SerializationInfo info, StreamingContext context)'.</source>
        <target state="translated">Добавьте конструктор к {0} со следующей сигнатурой: "protected {0}(SerializationInfo info, StreamingContext context)".</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationConstructorsMessageMakeSealedMagicConstructorPrivate">
        <source>Declare the serialization constructor of {0}, a sealed type, as private.</source>
        <target state="translated">Объявите конструктор сериализации {0} запечатанного типа как частный.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationConstructorsMessageMakeUnsealedMagicConstructorFamily">
        <source>Declare the serialization constructor of {0}, an unsealed type, as protected.</source>
        <target state="translated">Объявите конструктор сериализации {0} незапечатанного типа как защищенный.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationConstructorsTitle">
        <source>Implement serialization constructors</source>
        <target state="translated">Реализуйте конструкторы сериализации</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyDescription">
        <source>A method that handles a serialization event does not have the correct signature, return type, or visibility.</source>
        <target state="translated">У метода, обрабатывающего событие сериализации, нет правильной сигнатуры, типа возвращаемого значения или видимости.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyMessageGeneric">
        <source>Because {0} is marked with OnSerializing, OnSerialized, OnDeserializing, or OnDeserialized, change its signature so that it is no longer generic.</source>
        <target state="translated">Так как {0} помечен как OnSerializing, OnSerialized, OnDeserializing или OnDeserialized, измените его сигнатуру так, чтобы он более не был универсальным.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyMessageParameters">
        <source>Because {0} is marked with OnSerializing, OnSerialized, OnDeserializing, or OnDeserialized, change its signature so that it takes a single parameter of type 'System.Runtime.Serialization.StreamingContext'.</source>
        <target state="translated">Так как {0} помечен как OnSerializing, OnSerialized, OnDeserializing или OnDeserialized, измените его сигнатуру так, чтобы он принимал единственный параметр типа "System.Runtime.Serialization.StreamingContext".</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyMessageReturnType">
        <source>Because {0} is marked with OnSerializing, OnSerialized, OnDeserializing, or OnDeserialized, change its return type from {1} to void (Sub in Visual Basic).</source>
        <target state="translated">Так как {0} помечен как OnSerializing, OnSerialized, OnDeserializing или OnDeserialized, замените тип его возвращаемого значения с {1} на void (Sub в Visual Basic).</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyMessageStatic">
        <source>Because {0} is marked with OnSerializing, OnSerialized, OnDeserializing, or OnDeserialized, change it from static (Shared in Visual Basic) to an instance method.</source>
        <target state="translated">Так как {0} помечен как OnSerializing, OnSerialized, OnDeserializing или OnDeserialized, сделайте его не статическим методом (Shared в Visual Basic), а методом экземпляра.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyMessageVisibility">
        <source>Because {0} is marked with OnSerializing, OnSerialized, OnDeserializing, or OnDeserialized, change its accessibility to private.</source>
        <target state="translated">Так как {0} помечен как OnSerializing, OnSerialized, OnDeserializing или OnDeserialized, замените его доступность частной.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyTitle">
        <source>Implement serialization methods correctly</source>
        <target state="translated">Правильно реализуйте методы сериализации</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAllNonSerializableFieldsDescription">
        <source>An instance field of a type that is not serializable is declared in a type that is serializable.</source>
        <target state="translated">Поле экземпляра типа, который не может быть сериализован, объявлено в типе, который может быть сериализован.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAllNonSerializableFieldsMessage">
        <source>Field {0} is a member of type {1} which is serializable but is of type {2} which is not serializable</source>
        <target state="translated">Поле {0} является членом сериализуемого типа {1}, но имеет несериализуемый тип {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAllNonSerializableFieldsTitle">
        <source>Mark all non-serializable fields</source>
        <target state="translated">Пометьте все несериализуемые поля</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkISerializableTypesWithSerializableDescription">
        <source>To be recognized by the common language runtime as serializable, types must be marked by using the SerializableAttribute attribute even when the type uses a custom serialization routine through implementation of the ISerializable interface.</source>
        <target state="translated">Чтобы среда CLR распознавала типы как сериализуемые, они должны быть помечены с помощью атрибута SerializableAttribute, даже если тип использует настраиваемую процедуру сериализации посредством реализации интерфейса ISerializable.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkISerializableTypesWithSerializableMessage">
        <source>Add [Serializable] to {0} as this type implements ISerializable</source>
        <target state="translated">Добавьте [Serializable] к {0}, так как этот тип реализует ISerializable</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkISerializableTypesWithSerializableTitle">
        <source>Mark ISerializable types with serializable</source>
        <target state="translated">Пометить типы ISerializable атрибутом serializable</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideDeserializationMethodsForOptionalFieldsDescription">
        <source>A type has a field that is marked by using the System.Runtime.Serialization.OptionalFieldAttribute attribute, and the type does not provide deserialization event handling methods.</source>
        <target state="translated">Тип имеет поле, помеченное атрибутом System.Runtime.Serialization.OptionalFieldAttribute, и не предоставляет методы для обработки событий десериализации.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideDeserializationMethodsForOptionalFieldsMessageOnDeserialized">
        <source>Add a 'private void OnDeserialized(StreamingContext)' method to type {0} and attribute it with the System.Runtime.Serialization.OnDeserializedAttribute.</source>
        <target state="translated">Добавьте метод "private void OnDeserialized(StreamingContext)" к типу {0} и присвойте ему атрибут System.Runtime.Serialization.OnDeserializedAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideDeserializationMethodsForOptionalFieldsMessageOnDeserializing">
        <source>Add a 'private void OnDeserializing(StreamingContext)' method to type {0} and attribute it with the System.Runtime.Serialization.OnDeserializingAttribute.</source>
        <target state="translated">Добавьте метод "private void OnDeserializing(StreamingContext)" к типу {0} и присвойте ему атрибут System.Runtime.Serialization.OnDeserializingAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideDeserializationMethodsForOptionalFieldsTitle">
        <source>Provide deserialization methods for optional fields</source>
        <target state="translated">Обеспечьте наличие методов десериализации в необязательных полях</target>
        <note />
      </trans-unit>
      <trans-unit id="UseIndexer">
        <source>Use indexer</source>
        <target state="translated">Использовать индексатор</target>
        <note />
      </trans-unit>
      <trans-unit id="UseOrdinalStringComparisonTitle">
        <source>Use ordinal stringcomparison</source>
        <target state="translated">Используйте stringcomparison по порядковым номерам</target>
        <note />
      </trans-unit>
      <trans-unit id="UseOrdinalStringComparisonDescription">
        <source>A string comparison operation that is nonlinguistic does not set the StringComparison parameter to either Ordinal or OrdinalIgnoreCase. By explicitly setting the parameter to either StringComparison.Ordinal or StringComparison.OrdinalIgnoreCase, your code often gains speed, becomes more correct, and becomes more reliable.</source>
        <target state="translated">Нелингвистическая операция сравнения строк не задает для параметра StringComparison значение Ordinal или OrdinalIgnoreCase. Задав явным образом значение StringComparison.Ordinal или StringComparison.OrdinalIgnoreCase для параметра, можно сделать код более быстродействующим, корректным и надежным.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseOrdinalStringComparisonMessageStringComparison">
        <source>{0} passes '{1}' as the 'StringComparison' parameter to {2}. To perform a non-linguistic comparison, specify 'StringComparison.Ordinal' or 'StringComparison.OrdinalIgnoreCase' instead.</source>
        <target state="translated">{0} передает "{1}" в {2} в качестве параметра "StringComparison". Чтобы выполнить нелингвистическое сравнение, укажите "StringComparison.Ordinal" или "StringComparison.OrdinalIgnoreCase".</target>
        <note />
      </trans-unit>
      <trans-unit id="UseOrdinalStringComparisonMessageStringComparer">
        <source>{0} passes '{1}' as the 'StringComparer' parameter to {2}. To perform a non-linguistic comparison, specify 'StringComparer.Ordinal' or 'StringComparer.OrdinalIgnoreCase' instead.</source>
        <target state="translated">{0} передает "{1}" в {2} в качестве параметра "StringComparer". Чтобы выполнить нелингвистическое сравнение, укажите "StringComparer.Ordinal" или "StringComparer.OrdinalIgnoreCase".</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseTimersThatPreventPowerStateChangesTitle">
        <source>Do not use timers that prevent power state changes</source>
        <target state="translated">Не используйте таймеры, препятствующие изменению состояния электропитания</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseTimersThatPreventPowerStateChangesDescription">
        <source>Higher-frequency periodic activity will keep the CPU busy and interfere with power-saving idle timers that turn off the display and hard disks.</source>
        <target state="translated">Периодическая активность с более высокой частотой заставит ЦП переключаться в активный режим и помешает работе энергосберегающих таймеров простоя, которые отключают дисплей и жесткие диски.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseTimersThatPreventPowerStateChangesMessage">
        <source>Do not use timers that prevent power state changes</source>
        <target state="translated">Не используйте таймеры, препятствующие изменению состояния электропитания</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnsealedAttributesTitle">
        <source>Avoid unsealed attributes</source>
        <target state="translated">Избегайте незапечатанных атрибутов</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnsealedAttributesDescription">
        <source>The .NET Framework class library provides methods for retrieving custom attributes. By default, these methods search the attribute inheritance hierarchy. Sealing the attribute eliminates the search through the inheritance hierarchy and can improve performance.</source>
        <target state="translated">Эта библиотека классов платформы .NET Framework предоставляет методы для извлечения настраиваемых атрибутов. По умолчанию эти методы выполняют поиск по иерархии наследования атрибутов. Запечатывание атрибута устраняет поиск по иерархии наследования и позволяет повысить производительность.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidUnsealedAttributesMessage">
        <source>Avoid unsealed attributes</source>
        <target state="translated">Избегайте незапечатанных атрибутов</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForEmptyStringsUsingStringLengthTitle">
        <source>Test for empty strings using string length</source>
        <target state="translated">Проверяйте наличие пустых строк, используя длину строки</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForEmptyStringsUsingStringLengthDescription">
        <source>Comparing strings by using the String.Length property or the String.IsNullOrEmpty method is significantly faster than using Equals.</source>
        <target state="translated">Сравнение строк с помощью свойства String.Length или метода String.IsNullOrEmpty выполняется значительно быстрее, чем при использовании Equals.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForEmptyStringsUsingStringLengthMessage">
        <source>Test for empty strings using 'string.Length' property or 'string.IsNullOrEmpty' method instead of an Equality check.</source>
        <target state="translated">Проверяйте наличие пустых строк, используя свойство "string.Length" или метод "string.IsNullOrEmpty" вместо проверки равенства.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotLockOnObjectsWithWeakIdentityTitle">
        <source>Do not lock on objects with weak identity</source>
        <target state="translated">Не блокируйте слабо идентифицируемые объекты</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotLockOnObjectsWithWeakIdentityDescription">
        <source>An object is said to have a weak identity when it can be directly accessed across application domain boundaries. A thread that tries to acquire a lock on an object that has a weak identity can be blocked by a second thread in a different application domain that has a lock on the same object.</source>
        <target state="translated">Слабо идентифицируемым называется объект, к которому можно обратиться напрямую через границы домена приложения. Поток, пытающийся получить блокировку для слабо идентифицируемого объекта, может быть заблокирован вторым потоком в другом домене приложения, получившим блокировку того же объекта.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotLockOnObjectsWithWeakIdentityMessage">
        <source>Do not lock on objects with weak identity</source>
        <target state="translated">Не блокируйте слабо идентифицируемые объекты</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchCorruptedStateExceptionsInGeneralHandlersTitle">
        <source>Do not catch corrupted state exceptions in general handlers.</source>
        <target state="translated">Не перехватывайте исключения поврежденного состояния в общих обработчиках.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchCorruptedStateExceptionsInGeneralHandlersDescription">
        <source>Do not author general catch handlers in code that receives corrupted state exceptions.</source>
        <target state="translated">Не создавайте общие обработчики catch в коде, получающем исключения поврежденного состояния.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchCorruptedStateExceptionsInGeneralHandlersMessage">
        <source>Do not catch corrupted state exceptions in general handlers.</source>
        <target state="translated">Не перехватывайте исключения поврежденного состояния в общих обработчиках.</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsTitle">
        <source>Rethrow to preserve stack details</source>
        <target state="translated">Повторно порождайте исключения для сохранения сведений стека</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsDescription">
        <source>An exception is rethrown and the exception is explicitly specified in the throw statement. If an exception is rethrown by specifying the exception in the throw statement, the list of method calls between the original method that threw the exception and the current method is lost.</source>
        <target state="translated">Исключение выдается повторно и явно указывается в операторе throw. Если исключение порождается повторно путем его указания в операторе throw, список вызовов метода между исходным методом, породившим исключение, и текущим методом теряется.</target>
        <note />
      </trans-unit>
      <trans-unit id="RethrowToPreserveStackDetailsMessage">
        <source>Rethrow to preserve stack details</source>
        <target state="translated">Повторно порождайте исключения для сохранения сведений стека</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesTitle">
        <source>Do not raise reserved exception types</source>
        <target state="translated">Не порождайте исключения зарезервированных типов</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesDescription">
        <source>An exception of type that is not sufficiently specific or reserved by the runtime should never be raised by user code. This makes the original error difficult to detect and debug. If this exception instance might be thrown, use a different exception type.</source>
        <target state="translated">Пользовательский код никогда не должен порождать исключение типа, который является недостаточно определенным либо зарезервирован средой выполнения. Это затрудняет обнаружение и отладку исходной ошибки. Если экземпляр этого исключения может быть порожден, используйте другой тип исключения.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesMessageTooGeneric">
        <source>Exception type {0} is not sufficiently specific.</source>
        <target state="translated">Тип исключения {0} является недостаточно определенным.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotRaiseReservedExceptionTypesMessageReserved">
        <source>Exception type {0} is reserved by the runtime.</source>
        <target state="translated">Тип исключения {0} зарезервирован средой выполнения.</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeValueTypeStaticFieldsInlineTitle">
        <source>Initialize value type static fields inline</source>
        <target state="translated">Используйте встроенную инициализацию статических полей типов значений</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeReferenceTypeStaticFieldsInlineTitle">
        <source>Initialize reference type static fields inline</source>
        <target state="translated">Используйте встроенную инициализацию статических полей ссылочных типов</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeValueTypeStaticFieldsInlineDescription">
        <source>A value type declares an explicit static constructor. To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor.</source>
        <target state="translated">Тип значения объявляет явный статический конструктор. Чтобы устранить нарушение этого правила, инициализируйте все статические данные при объявлении конструктора и удалите его.</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeReferenceTypeStaticFieldsInlineDescription">
        <source>A reference type declares an explicit static constructor. To fix a violation of this rule, initialize all static data when it is declared and remove the static constructor.</source>
        <target state="translated">Ссылочный тип объявляет явный статический конструктор. Чтобы устранить нарушение этого правила, инициализируйте все статические данные при объявлении конструктора и удалите его.</target>
        <note />
      </trans-unit>
      <trans-unit id="InitializeStaticFieldsInlineMessage">
        <source>Initialize all static fields in '{0}' when those fields are declared and remove the explicit static constructor</source>
        <target state="translated">Инициализируйте все статические поля в "{0}" при их объявлении и удалите явный статический конструктор.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableFieldsShouldBeDisposedTitle">
        <source>Disposable fields should be disposed</source>
        <target state="translated">Следует высвобождать высвобождаемые поля</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableFieldsShouldBeDisposedDescription">
        <source>A type that implements System.IDisposable declares fields that are of types that also implement IDisposable. The Dispose method of the field is not called by the Dispose method of the declaring type. To fix a violation of this rule, call Dispose on fields that are of types that implement IDisposable if you are responsible for allocating and releasing the unmanaged resources held by the field.</source>
        <target state="translated">Тип, который реализует System.IDisposable, объявляет поля, относящиеся к типам, которые также реализуют IDisposable. Метод Dispose поля не вызывается методом Dispose объявляющего типа. Чтобы устранить нарушение этого правила, вызовите Dispose для полей, относящихся к типам, которые реализуют IDisposable, если вы отвечаете за выделение и освобождение неуправляемых ресурсов, хранящихся в поле.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableFieldsShouldBeDisposedMessage">
        <source>'{0}' contains field '{1}' that is of IDisposable type '{2}', but it is never disposed. Change the Dispose method on '{0}' to call Close or Dispose on this field.</source>
        <target state="translated">"{0}" содержит поле "{1}", которое имеет тип IDisposable "{2}", но никогда не удаляется. Измените метод Dispose для "{0}" на вызов Close или Dispose для этого поля.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructorsTitle">
        <source>Do not call overridable methods in constructors</source>
        <target state="translated">Не вызывайте переопределяемые методы в конструкторах</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructorsDescription">
        <source>When a constructor calls a virtual method, the constructor for the instance that invokes the method may not have executed.</source>
        <target state="translated">Когда конструктор вызывает виртуальный метод, конструктор может не выполняться для экземпляра, вызывающего этот метод.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallOverridableMethodsInConstructorsMessage">
        <source>Do not call overridable methods in constructors</source>
        <target state="translated">Не вызывайте переопределяемые методы в конструкторах</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeMethodsShouldCallBaseClassDisposeTitle">
        <source>Dispose methods should call base class dispose</source>
        <target state="translated">Метод Dispose должен вызывать базовый класс Dispose</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeMethodsShouldCallBaseClassDisposeDescription">
        <source>A type that implements System.IDisposable inherits from a type that also implements IDisposable. The Dispose method of the inheriting type does not call the Dispose method of the parent type. To fix a violation of this rule, call base.Dispose in your Dispose method.</source>
        <target state="translated">Тип, который реализует System.IDisposable, наследует от типа, который также реализует IDisposable. Метод Dispose наследующего типа не вызывает метод Dispose родительского типа. Чтобы устранить нарушение этого правила, вызовите base.Dispose в методе Dispose.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposeMethodsShouldCallBaseClassDisposeMessage">
        <source>Ensure that method '{0}' calls '{1}' in all possible control flow paths.</source>
        <target state="translated">Убедитесь, что метод "{0}" вызывает "{1}" во всех возможных путях потока управления.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableTypesShouldDeclareFinalizerTitle">
        <source>Disposable types should declare finalizer</source>
        <target state="translated">Высвобождаемые типы должны объявлять методы завершения</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableTypesShouldDeclareFinalizerDescription">
        <source>A type that implements System.IDisposable and has fields that suggest the use of unmanaged resources does not implement a finalizer, as described by Object.Finalize.</source>
        <target state="translated">Тип, который реализует System.IDisposable и имеет поля, предполагающие использование неуправляемых ресурсов, не реализует метод завершения, как описано Object.Finalize.</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableTypesShouldDeclareFinalizerMessage">
        <source>Disposable types should declare finalizer</source>
        <target state="translated">Высвобождаемые типы должны объявлять методы завершения</target>
        <note />
      </trans-unit>
      <trans-unit id="FinalizersShouldCallBaseClassFinalizerTitle">
        <source>Finalizers should call base class finalizer</source>
        <target state="translated">Методы завершения должны вызывать метод завершения базового класса</target>
        <note />
      </trans-unit>
      <trans-unit id="FinalizersShouldCallBaseClassFinalizerDescription">
        <source>Finalization must be propagated through the inheritance hierarchy. To guarantee this, types must call their base class Finalize method in their own Finalize method.</source>
        <target state="translated">Завершение должно распространяться через иерархию наследования. Для этого типы должны вызывать метод Finalize своего базового класса в своем собственном методе Finalize.</target>
        <note />
      </trans-unit>
      <trans-unit id="FinalizersShouldCallBaseClassFinalizerMessage">
        <source>Finalizers should call base class finalizer</source>
        <target state="translated">Методы завершения должны вызывать метод завершения базового класса</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentsToFormattingMethodsTitle">
        <source>Provide correct arguments to formatting methods</source>
        <target state="translated">Задайте правильные аргументы для методов форматирования</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentsToFormattingMethodsDescription">
        <source>The format argument that is passed to System.String.Format does not contain a format item that corresponds to each object argument, or vice versa.</source>
        <target state="translated">Передаваемый в System.String.Format аргумент формата не содержит элемент формата, соответствующий каждому из аргументов объекта, или наоборот.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideCorrectArgumentsToFormattingMethodsMessage">
        <source>Provide correct arguments to formatting methods</source>
        <target state="translated">Задайте правильные аргументы для методов форматирования</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForNaNCorrectlyTitle">
        <source>Test for NaN correctly</source>
        <target state="translated">Правильно выполняйте проверку NaN</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForNaNCorrectlyDescription">
        <source>This expression tests a value against Single.Nan or Double.Nan. Use Single.IsNan(Single) or Double.IsNan(Double) to test the value.</source>
        <target state="translated">Это выражение проверяет значение на соответствие Single.Nan или Double.Nan. Используйте Single.IsNan(Single) или Double.IsNan(Double) для проверки значения.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestForNaNCorrectlyMessage">
        <source>Test for NaN correctly</source>
        <target state="translated">Правильно выполняйте проверку NaN</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyTitle">
        <source>Attribute string literals should parse correctly</source>
        <target state="translated">Синтаксический анализ строковых литералов атрибута должен осуществляться правильно</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyDescription">
        <source>The string literal parameter of an attribute does not parse correctly for a URL, a GUID, or a version.</source>
        <target state="translated">Параметр строкового литерала атрибута анализируется неправильно для URL-адреса, GUID или версии.</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyMessageDefault">
        <source>In the constructor of '{0}', change the value of argument '{1}', which is currently "{2}", to something that can be correctly parsed as '{3}'.</source>
        <target state="translated">В конструкторе "{0}" измените аргумент "{1}", который сейчас равен "{2}", на значение, обеспечивающее правильный анализ в качестве "{3}".</target>
        <note />
      </trans-unit>
      <trans-unit id="AttributeStringLiteralsShouldParseCorrectlyMessageEmpty">
        <source>In the constructor of '{0}', change the value of argument '{1}', which is currently an empty string (""), to something that can be correctly parsed as '{2}'.</source>
        <target state="translated">В конструкторе "{0}" измените аргумент "{1}", который сейчас равен пустой строке (""), на значение, обеспечивающее правильный анализ в качестве "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidZeroLengthArrayAllocationsTitle">
        <source>Avoid zero-length array allocations.</source>
        <target state="translated">Старайтесь не выделять массивы нулевой длины.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidZeroLengthArrayAllocationsMessage">
        <source>Avoid unnecessary zero-length array allocations.  Use {0} instead.</source>
        <target state="translated">Старайтесь не выделять массивы нулевой длины без необходимости.  Вместо этого используйте {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyTitle">
        <source>Do not use Enumerable methods on indexable collections. Instead use the collection directly</source>
        <target state="translated">Не используйте метод Enumerable для индексируемых коллекций. Вместо этого используйте непосредственно коллекцию</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyDescription">
        <source>This collection is directly indexable. Going through LINQ here causes unnecessary allocations and CPU work.</source>
        <target state="translated">Эта коллекция индексируется напрямую. В этом случае применение LINQ приводит к ненужным выделениям и нагрузке на ЦП.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseEnumerableMethodsOnIndexableCollectionsInsteadUseTheCollectionDirectlyMessage">
        <source>Do not use Enumerable methods on indexable collections. Instead use the collection directly</source>
        <target state="translated">Не используйте метод Enumerable для индексируемых коллекций. Вместо этого используйте непосредственно коллекцию</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureInfoTitle">
        <source>Specify CultureInfo</source>
        <target state="translated">Укажите CultureInfo</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureInfoDescription">
        <source>A method or constructor calls a member that has an overload that accepts a System.Globalization.CultureInfo parameter, and the method or constructor does not call the overload that takes the CultureInfo parameter. When a CultureInfo or System.IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales. If the result will be displayed to the user, specify 'CultureInfo.CurrentCulture' as the 'CultureInfo' parameter. Otherwise, if the result will be stored and accessed by software, such as when it is persisted to disk or to a database, specify 'CultureInfo.InvariantCulture'.</source>
        <target state="translated">Метод или конструктор вызывает элемент, который имеет перегрузку, принимающую параметр System.Globalization.CultureInfo, при этом данный метод или конструктор не вызывает перегрузку, принимающую параметр CultureInfo. Если объект CultureInfo или System.IFormatProvider не задан, значение по умолчанию, предоставленное перегруженным элементом, может не оказывать требуемое вам воздействие для всех языковых стандартов. Если результат выводится пользователю, укажите "CultureInfo.CurrentCulture" в качестве параметра "CultureInfo". В противном случае, если результат сохраняется и используется программным обеспечением, например при сохранении его на диск или в базу данных, укажите "CultureInfo.InvariantCulture".</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyCultureInfoMessage">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">Поведение "{0}" может изменяться в зависимости от параметров языкового стандарта текущего пользователя. Замените этот вызов в "{1}" на вызов "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderTitle">
        <source>Specify IFormatProvider</source>
        <target state="translated">Укажите IFormatProvider</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderDescription">
        <source>A method or constructor calls one or more members that have overloads that accept a System.IFormatProvider parameter, and the method or constructor does not call the overload that takes the IFormatProvider parameter. When a System.Globalization.CultureInfo or IFormatProvider object is not supplied, the default value that is supplied by the overloaded member might not have the effect that you want in all locales. If the result will be based on the input from/output displayed to the user, specify 'CultureInfo.CurrentCulture' as the 'IFormatProvider'. Otherwise, if the result will be stored and accessed by software, such as when it is loaded from disk/database and when it is persisted to disk/database, specify 'CultureInfo.InvariantCulture'</source>
        <target state="translated">Метод или конструктор вызывает один или несколько элементов, которые имеют перегрузки, принимающие параметр System.IFormatProvider, при этом данный метод или конструктор не вызывает перегрузку, принимающую параметр IFormatProvider. Если объект System.Globalization.CultureInfo или IFormatProvider не задан, значение по умолчанию, предоставленное перегруженным элементом, может не оказывать требуемое вам воздействие для всех языковых стандартов. Если результат зависит от вводимых пользователям данных или предоставляемых ему выходных данных, укажите "CultureInfo.CurrentCulture" в качестве параметра "IFormatProvider". В противном случае, если результат сохраняется и используется программным обеспечением, например при загрузке его с диска или из базы данных и при сохранении в этих расположениях, укажите "CultureInfo.InvariantCulture".</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageIFormatProviderAlternateString">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">Поведение "{0}" может изменяться в зависимости от параметров языкового стандарта текущего пользователя. Замените этот вызов в "{1}" на вызов "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageIFormatProviderAlternate">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">Поведение "{0}" может изменяться в зависимости от параметров языкового стандарта текущего пользователя. Замените этот вызов в "{1}" на вызов "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageUICultureString">
        <source>'{0}' passes '{1}' as the 'IFormatProvider' parameter to '{2}'. This property returns a culture that is inappropriate for formatting methods.</source>
        <target state="translated">"{0}" передает "{1}" в "{2}" в качестве параметра "IFormatProvider". Это свойство возвращает язык и региональные параметры, не подходящие для методов форматирования.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyIFormatProviderMessageUICulture">
        <source>'{0}' passes '{1}' as the 'IFormatProvider' parameter to '{2}'. This property returns a culture that is inappropriate for formatting methods.</source>
        <target state="translated">"{0}" передает "{1}" в "{2}" в качестве параметра "IFormatProvider". Это свойство возвращает язык и региональные параметры, не подходящие для методов форматирования.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonTitle">
        <source>Specify StringComparison</source>
        <target state="translated">Укажите StringComparison</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonDescription">
        <source>A string comparison operation uses a method overload that does not set a StringComparison parameter. If the result will be displayed to the user, such as when sorting a list of items for display in a list box, specify 'StringComparison.CurrentCulture' or 'StringComparison.CurrentCultureIgnoreCase' as the 'StringComparison' parameter. If comparing case-insensitive identifiers, such as file paths, environment variables, or registry keys and values, specify 'StringComparison.OrdinalIgnoreCase'. Otherwise, if comparing case-sensitive identifiers, specify 'StringComparison.Ordinal'.</source>
        <target state="translated">Операция сравнения строк использует перегрузку метода, не задающую параметр StringComparison. Если результат будет отображаться для пользователя, например при сортировке элементов в списке, задайте для параметра "StringComparison" значение "StringComparison.CurrentCulture" или "StringComparison.CurrentCultureIgnoreCase". При сравнении идентификаторов, не чувствительных к регистру, таких как пути к файлам, переменные среды или разделы и значения реестра, используйте "StringComparison.OrdinalIgnoreCase". В противном случае укажите "StringComparison.Ordinal" при сравнении чувствительных к регистру идентификаторов.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyStringComparisonMessage">
        <source>The behavior of '{0}' could vary based on the current user's locale settings. Replace this call in '{1}' with a call to '{2}'.</source>
        <target state="translated">Поведение "{0}" может изменяться в зависимости от параметров языкового стандарта текущего пользователя. Замените этот вызов в "{1}" на вызов "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="NormalizeStringsToUppercaseTitle">
        <source>Normalize strings to uppercase</source>
        <target state="translated">Нормализуйте строки до прописных букв</target>
        <note />
      </trans-unit>
      <trans-unit id="NormalizeStringsToUppercaseDescription">
        <source>Strings should be normalized to uppercase. A small group of characters cannot make a round trip when they are converted to lowercase. To make a round trip means to convert the characters from one locale to another locale that represents character data differently, and then to accurately retrieve the original characters from the converted characters.</source>
        <target state="translated">Строки следует нормализовать до прописных букв. Небольшая группа символов не может выполнить круговой путь, если они преобразованы в нижний регистр. Круговой путь заключается в преобразовании символов из одного языкового стандарта в другой, где символьные данные представлены иначе, и последующем точном извлечении исходных символов из преобразованных.</target>
        <note />
      </trans-unit>
      <trans-unit id="NormalizeStringsToUppercaseMessageToUpper">
        <source>In method '{0}', replace the call to '{1}' with '{2}'.</source>
        <target state="translated">В методе "{0}" замените вызов "{1}" на "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyTitle">
        <source>Dispose methods should call SuppressFinalize</source>
        <target state="translated">Методы Dispose должны вызывать SuppressFinalize</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyDescription">
        <source>A method that is an implementation of Dispose does not call GC.SuppressFinalize; or a method that is not an implementation of Dispose calls GC.SuppressFinalize; or a method calls GC.SuppressFinalize and passes something other than this (Me in Visual?Basic).</source>
        <target state="translated">Метод, являющийся реализацией Dispose, не вызывает GC.SuppressFinalize, метод, не являющийся реализацией Dispose, вызывает GC.SuppressFinalize, либо метод вызывает GC.SuppressFinalize и передает нечто иное (Me в Visual Basic).</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageNotCalledWithFinalizer">
        <source>Change {0} to call {1}. This will prevent unnecessary finalization of the object once it has been disposed and it has fallen out of scope.</source>
        <target state="translated">Замените {0} вызовом {1}. Это предотвратит ненужное завершение объекта после его высвобождения и выхода из области видимости.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageNotCalled">
        <source>Change {0} to call {1}. This will prevent derived types that introduce a finalizer from needing to re-implement 'IDisposable' to call it.</source>
        <target state="translated">Замените {0} вызовом {1}. В результате для производных типов, использующих метод завершения, отпадет необходимость в повторной реализации "IDisposable" для вызова этого метода.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageNotPassedThis">
        <source>{0} calls {1} on something other than itself. Change the call site to pass 'this' ('Me' in Visual Basic) instead.</source>
        <target state="translated">{0} вызывает {1} для другого объекта, а не для себя. Измените место вызова, чтобы передать вместо него "this" ("Me" в Visual Basic).</target>
        <note />
      </trans-unit>
      <trans-unit id="CallGCSuppressFinalizeCorrectlyMessageOutsideDispose">
        <source>{0} calls {1}, a method that is typically only called within an implementation of 'IDisposable.Dispose'. Refer to the IDisposable pattern for more information.</source>
        <target state="translated">{0} вызывает {1}, метод, который обычно вызывается только внутри реализации "IDisposable.Dispose". Дополнительные сведения см. в шаблоне IDisposable.</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyTitle">
        <source>Instantiate argument exceptions correctly</source>
        <target state="translated">Правильно создавайте экземпляры исключений аргументов</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyDescription">
        <source>A call is made to the default (parameterless) constructor of an exception type that is or derives from ArgumentException, or an incorrect string argument is passed to a parameterized constructor of an exception type that is or derives from ArgumentException.</source>
        <target state="translated">Выполняется вызов конструктора по умолчанию (без параметров) для типа исключения, который является ArgumentException или производным от него, либо в параметризованный конструктор для типа исключения, который является ArgumentException или производным от него, передается неправильный строковый аргумент.</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyMessageNoArguments">
        <source>Call the {0} constructor that contains a message and/or paramName parameter.</source>
        <target state="translated">Вызывайте конструктор {0}, который содержит сообщение и (или) параметр paramName.</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyMessageIncorrectMessage">
        <source>Method {0} passes parameter name '{1}' as the {2} argument to a {3} constructor. Replace this argument with a descriptive message and pass the parameter name in the correct position.</source>
        <target state="translated">Метод {0} передает имя параметра "{1}" в качестве аргумента {2} в конструктор {3}. Замените этот аргумент описательным сообщением и передайте имя этого параметра в правильном положении.</target>
        <note />
      </trans-unit>
      <trans-unit id="InstantiateArgumentExceptionsCorrectlyMessageIncorrectParameterName">
        <source>Method {0} passes '{1}' as the {2} argument to a {3} constructor. Replace this argument with one of the method's parameter names. Note that the provided parameter name should have the exact casing as declared on the method.</source>
        <target state="translated">Метод {0} передает "{1}" в качестве аргумента {2} в конструктор {3}. Замените этот аргумент одним из имен параметров метода. Заметьте, что предоставленное имя параметра должно использовать те же прописные и строчные буквы, как объявлено в методе.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseArrayEmpty">
        <source>Use Array.Empty</source>
        <target state="translated">Используйте Array.Empty</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
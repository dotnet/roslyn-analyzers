<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ApprovedCipherMode" xml:space="preserve">
    <value>Do Not Use Unsafe Cipher Modes</value>
  </data>
  <data name="ApprovedCipherModeDescription" xml:space="preserve">
    <value>These modes are vulnerable to attacks. Use only approved modes (CBC, CTS).</value>
  </data>
  <data name="ApprovedCipherModeMessage" xml:space="preserve">
    <value>It uses an unsafe Cipher Mode {0}</value>
  </data>
  <data name="DoNotAddSchemaByURL" xml:space="preserve">
    <value>Do Not Add Schema By URL</value>
  </data>
  <data name="DoNotAddSchemaByURLDescription" xml:space="preserve">
    <value>This overload of XmlSchemaCollection.Add method internally enables DTD processing on the XML reader instance used, and uses UrlResolver for resolving external XML entities. The outcome is information disclosure. Content from file system or network shares for the machine processing the XML can be exposed to attacker. In addition, an attacker can use this as a DoS vector.</value>
  </data>
  <data name="DoNotAddSchemaByURLMessage" xml:space="preserve">
    <value>This overload of the Add method is potentially unsafe because it may resolve dangerous external references</value>
  </data>
  <data name="DoNotCallDangerousMethodsInDeserialization" xml:space="preserve">
    <value>Do Not Call Dangerous Methods In Deserialization</value>
  </data>
  <data name="DoNotCallDangerousMethodsInDeserializationDescription" xml:space="preserve">
    <value>Insecure Deserialization is a vulnerability which occurs when untrusted data is used to abuse the logic of an application, inflict a Denial-of-Service (DoS) attack, or even execute arbitrary code upon it being deserialized. It’s frequently possible for malicious users to abuse these deserialization features when the application is deserializing untrusted data which is under their control. Specifically, invoke dangerous methods in the process of deserialization. Successful insecure deserialization attacks could allow an attacker to carry out attacks such as DoS attacks, authentication bypasses, and remote code execution.</value>
  </data>
  <data name="DoNotCallDangerousMethodsInDeserializationMessage" xml:space="preserve">
    <value>When deserializing an instance of class {0}, method {1} can call dangerous method {2}.</value>
  </data>
  <data name="DoNotDisableCertificateValidation" xml:space="preserve">
    <value>Do Not Disable Certificate Validation</value>
  </data>
  <data name="DoNotDisableCertificateValidationDescription" xml:space="preserve">
    <value>A certificate can help authenticate the identity of the server. Clients should validate the server certificate to ensure requests are sent to the intended server. If the ServerCertificateValidationCallback always returns 'true', any certificate will pass validation.</value>
  </data>
  <data name="DoNotDisableCertificateValidationMessage" xml:space="preserve">
    <value>The ServerCertificateValidationCallback is set to a function that accepts any server certificate, by always returning true. Ensure that server certificates are validated to verify the identity of the server receiving requests.</value>
  </data>
  <data name="DoNotDisableHTTPHeaderChecking" xml:space="preserve">
    <value>Do Not Disable HTTP Header Checking</value>
  </data>
  <data name="DoNotDisableHTTPHeaderCheckingDescription" xml:space="preserve">
    <value>HTTP header checking enables encoding of the carriage return and newline characters, \r and \n, that are found in response headers. This encoding can help to avoid injection attacks that exploit an application that echoes untrusted data contained by the header.</value>
  </data>
  <data name="DoNotDisableHTTPHeaderCheckingMessage" xml:space="preserve">
    <value>Do not disable HTTP header checking</value>
  </data>
  <data name="DoNotDisableRequestValidation" xml:space="preserve">
    <value>Do Not Disable Request Validation</value>
  </data>
  <data name="DoNotDisableRequestValidationDescription" xml:space="preserve">
    <value>Request validation is a feature in ASP.NET that examines HTTP requests and determines whether they contain potentially dangerous content. This check adds protection from markup or code in the URL query string, cookies, or posted form values that might have been added for malicious purposes. So, it is generally desirable and should be left enabled for defense in depth.</value>
  </data>
  <data name="DoNotDisableRequestValidationMessage" xml:space="preserve">
    <value>The method {0} has request validation disabled</value>
  </data>
  <data name="DoNotDisableSchUseStrongCrypto" xml:space="preserve">
    <value>Do Not Disable SChannel Use of Strong Crypto</value>
  </data>
  <data name="DoNotDisableSchUseStrongCryptoDescription" xml:space="preserve">
    <value>Starting with the .NET Framework 4.6, the System.Net.ServicePointManager and System.Net.Security.SslStream classes are recommeded to use new protocols. The old ones have protocol weaknesses and are not supported. Setting Switch.System.Net.DontEnableSchUseStrongCrypto with true will use the old weak crypto check and opt out of the protocol migration.</value>
  </data>
  <data name="DoNotDisableSchUseStrongCryptoMessage" xml:space="preserve">
    <value>{0} disables TLS 1.2 and enables SSLv3</value>
  </data>
  <data name="DoNotReferSelfInSerializableClass" xml:space="preserve">
    <value>Do Not Refer Self In Serializable Class</value>
  </data>
  <data name="DoNotReferSelfInSerializableClassDescription" xml:space="preserve">
    <value>This can allow an attacker to DOS or exhaust the memory of the process.</value>
  </data>
  <data name="DoNotReferSelfInSerializableClassMessage" xml:space="preserve">
    <value>{0} participates in a potential reference cycle</value>
  </data>
  <data name="DoNotSerializeTypesWithPointerFields" xml:space="preserve">
    <value>Do Not Serialize Types With Pointer Fields</value>
  </data>
  <data name="DoNotSerializeTypesWithPointerFieldsDescription" xml:space="preserve">
    <value>Pointers are not "type safe" in the sense that you cannot guarantee the correctness of the memory they point at. So, serializing types with pointer fields is dangerous, as it may allow an attacker to control the pointer.</value>
  </data>
  <data name="DoNotSerializeTypesWithPointerFieldsMessage" xml:space="preserve">
    <value>Pointer field {0} on serializable type.</value>
  </data>
  <data name="DoNotUseBrokenCryptographicAlgorithms" xml:space="preserve">
    <value>Do Not Use Broken Cryptographic Algorithms</value>
  </data>
  <data name="DoNotUseBrokenCryptographicAlgorithmsDescription" xml:space="preserve">
    <value>An attack making it computationally feasible to break this algorithm exists. This allows attackers to break the cryptographic guarantees it is designed to provide. Depending on the type and application of this cryptographic algorithm, this may allow attackers to read enciphered messages, tamper with enciphered  messages, forge digital signatures, tamper with hashed content, or otherwise compromise any cryptosystem based on this algorithm. Replace encryption uses with the AES algorithm (AES-256, AES-192 and AES-128 are acceptable) with a key length greater than or equal to 128 bits. Replace hashing uses with a hashing function in the SHA-2 family, such as SHA512, SHA384, or SHA256. Replace digital signature uses with RSA with a key length greater than or equal to 2048-bits, or ECDSA with a key length greater than or equal to 256 bits.</value>
  </data>
  <data name="DoNotUseBrokenCryptographicAlgorithmsMessage" xml:space="preserve">
    <value>{0} uses a broken cryptographic algorithm {1}</value>
  </data>
  <data name="DoNotUseDeprecatedSecurityProtocols" xml:space="preserve">
    <value>Do Not Use Deprecated Security Protocols</value>
  </data>
  <data name="DoNotUseDeprecatedSecurityProtocolsDescription" xml:space="preserve">
    <value>Using a deprecated security protocol rather than the system default is risky.</value>
  </data>
  <data name="DoNotUseDeprecatedSecurityProtocolsMessage" xml:space="preserve">
    <value>Hard-coded use of deprecated security protocol {0}</value>
  </data>
  <data name="DoNotUseMD5" xml:space="preserve">
    <value>Do not use insecure cryptographic algorithm MD5.</value>
  </data>
  <data name="DoNotUseMD5Description" xml:space="preserve">
    <value>This type implements MD5, a cryptographically insecure hashing function. Hash collisions are computationally feasible for the MD5 and HMACMD5 algorithms. Replace this usage with a SHA-2 family hash algorithm (SHA512, SHA384, SHA256).</value>
  </data>
  <data name="DoNotUseSHA1" xml:space="preserve">
    <value>Do not use insecure cryptographic algorithm SHA1.</value>
  </data>
  <data name="DoNotUseSHA1Description" xml:space="preserve">
    <value>This type implements SHA1, a cryptographically insecure hashing function. Hash collisions are computationally feasible for the SHA-1 and SHA-0 algorithms. Replace this usage with a SHA-2 family hash algorithm (SHA512, SHA384, SHA256).</value>
  </data>
  <data name="DoNotUseWeakCryptographicAlgorithms" xml:space="preserve">
    <value>Do Not Use Weak Cryptographic Algorithms</value>
  </data>
  <data name="DoNotUseWeakCryptographicAlgorithmsDescription" xml:space="preserve">
    <value>Cryptographic algorithms degrade over time as attacks become for advances to attacker get access to more computation. Depending on the type and application of this cryptographic algorithm, further degradation of the cryptographic strength of it may allow attackers to read enciphered messages, tamper with enciphered  messages, forge digital signatures, tamper with hashed content, or otherwise compromise any cryptosystem based on this algorithm. Replace encryption uses with the AES algorithm (AES-256, AES-192 and AES-128 are acceptable) with a key length greater than or equal to 128 bits. Replace hashing uses with a hashing function in the SHA-2 family, such as SHA-2 512, SHA-2 384, or SHA-2 256.</value>
  </data>
  <data name="DoNotUseWeakCryptographicAlgorithmsMessage" xml:space="preserve">
    <value>{0} uses a weak cryptographic algorithm {1}</value>
  </data>
  <data name="SetViewStateUserKey" xml:space="preserve">
    <value>Set ViewStateUserKey For Classes Derived From Page</value>
  </data>
  <data name="SetViewStateUserKeyDescription" xml:space="preserve">
    <value>Setting the ViewStateUserKey property can help you prevent attacks on your application by allowing you to assign an identifier to the view-state variable for individual users so that they cannot use the variable to generate an attack. Otherwise, there will be cross-site request forgery vulnerabilities.</value>
  </data>
  <data name="SetViewStateUserKeyMessage" xml:space="preserve">
    <value>The subclass {0} of Page does not set the ViewStateUserKey property in method OnInit</value>
  </data>
  <data name="UseXmlReaderDescription" xml:space="preserve">
    <value>Processing XML from untrusted data may load dangerous external references, which should be restricted by using an XmlReader with a secure resolver or with DTD processing disabled.</value>
  </data>
  <data name="UseXmlReaderForDataSetReadXml" xml:space="preserve">
    <value>Use XmlReader For DataSet Read Xml</value>
  </data>
  <data name="UseXmlReaderForDeserialize" xml:space="preserve">
    <value>Use XmlReader For Deserialize</value>
  </data>
  <data name="UseXmlReaderForSchemaRead" xml:space="preserve">
    <value>Use XmlReader For Schema Read</value>
  </data>
  <data name="UseXmlReaderForValidatingReader" xml:space="preserve">
    <value>Use XmlReader For Validating Reader</value>
  </data>
  <data name="UseXmlReaderForXPathDocument" xml:space="preserve">
    <value>Use XmlReader For XPathDocument</value>
  </data>
  <data name="UseXmlReaderMessage" xml:space="preserve">
    <value>This overload of the {0}.{1} method is potentially unsafe, use an overload that takes a XmlReader instance instead</value>
  </data>
</root>
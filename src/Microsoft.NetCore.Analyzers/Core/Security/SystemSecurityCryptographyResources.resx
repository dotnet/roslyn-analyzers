<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ApprovedCipherMode" xml:space="preserve">
    <value>Do Not Use Unsafe Cipher Modes</value>
  </data>
  <data name="ApprovedCipherModeDescription" xml:space="preserve">
    <value>These modes are vulnerable to attacks. Use only approved modes (CBC, CTS).</value>
  </data>
  <data name="ApprovedCipherModeMessage" xml:space="preserve">
    <value>It uses an unsafe Cipher Mode {0}</value>
  </data>
  <data name="DefinitelyInstallRootCert" xml:space="preserve">
    <value>Do Not Add Certificates To Root Store</value>
  </data>
  <data name="DefinitelyInstallRootCertMessage" xml:space="preserve">
    <value>Adding certificates to the operating system's trusted root certificates increases the risk of incorrectly authenticating an illegitimate certificate</value>
  </data>
  <data name="DefinitelyUseSecureCookiesASPNetCore" xml:space="preserve">
    <value>Use Secure Cookies In ASP.Net Core</value>
  </data>
  <data name="DefinitelyUseSecureCookiesASPNetCoreMessage" xml:space="preserve">
    <value>Set CookieOptions.Secure = true when setting a cookie</value>
  </data>
  <data name="DoNotAddSchemaByURL" xml:space="preserve">
    <value>Do Not Add Schema By URL</value>
  </data>
  <data name="DoNotAddSchemaByURLDescription" xml:space="preserve">
    <value>This overload of XmlSchemaCollection.Add method internally enables DTD processing on the XML reader instance used, and uses UrlResolver for resolving external XML entities. The outcome is information disclosure. Content from file system or network shares for the machine processing the XML can be exposed to attacker. In addition, an attacker can use this as a DoS vector.</value>
  </data>
  <data name="DoNotAddSchemaByURLMessage" xml:space="preserve">
    <value>This overload of the Add method is potentially unsafe because it may resolve dangerous external references</value>
  </data>
  <data name="DoNotCallDangerousMethodsInDeserialization" xml:space="preserve">
    <value>Do Not Call Dangerous Methods In Deserialization</value>
  </data>
  <data name="DoNotCallDangerousMethodsInDeserializationDescription" xml:space="preserve">
    <value>Insecure Deserialization is a vulnerability which occurs when untrusted data is used to abuse the logic of an application, inflict a Denial-of-Service (DoS) attack, or even execute arbitrary code upon it being deserialized. It’s frequently possible for malicious users to abuse these deserialization features when the application is deserializing untrusted data which is under their control. Specifically, invoke dangerous methods in the process of deserialization. Successful insecure deserialization attacks could allow an attacker to carry out attacks such as DoS attacks, authentication bypasses, and remote code execution.</value>
  </data>
  <data name="DoNotCallDangerousMethodsInDeserializationMessage" xml:space="preserve">
    <value>When deserializing an instance of class {0}, method {1} can call dangerous method {2}.</value>
  </data>
  <data name="DoNotDisableCertificateValidation" xml:space="preserve">
    <value>Do Not Disable Certificate Validation</value>
  </data>
  <data name="DoNotDisableCertificateValidationDescription" xml:space="preserve">
    <value>A certificate can help authenticate the identity of the server. Clients should validate the server certificate to ensure requests are sent to the intended server. If the ServerCertificateValidationCallback always returns 'true', any certificate will pass validation.</value>
  </data>
  <data name="DoNotDisableCertificateValidationMessage" xml:space="preserve">
    <value>The ServerCertificateValidationCallback is set to a function that accepts any server certificate, by always returning true. Ensure that server certificates are validated to verify the identity of the server receiving requests.</value>
  </data>
  <data name="DoNotDisableHTTPHeaderChecking" xml:space="preserve">
    <value>Do Not Disable HTTP Header Checking</value>
  </data>
  <data name="DoNotDisableHTTPHeaderCheckingDescription" xml:space="preserve">
    <value>HTTP header checking enables encoding of the carriage return and newline characters, \r and \n, that are found in response headers. This encoding can help to avoid injection attacks that exploit an application that echoes untrusted data contained by the header.</value>
  </data>
  <data name="DoNotDisableHTTPHeaderCheckingMessage" xml:space="preserve">
    <value>Do not disable HTTP header checking</value>
  </data>
  <data name="DoNotDisableRequestValidation" xml:space="preserve">
    <value>Do Not Disable Request Validation</value>
  </data>
  <data name="DoNotDisableRequestValidationDescription" xml:space="preserve">
    <value>Request validation is a feature in ASP.NET that examines HTTP requests and determines whether they contain potentially dangerous content. This check adds protection from markup or code in the URL query string, cookies, or posted form values that might have been added for malicious purposes. So, it is generally desirable and should be left enabled for defense in depth.</value>
  </data>
  <data name="DoNotDisableRequestValidationMessage" xml:space="preserve">
    <value>{0} has request validation disabled</value>
  </data>
  <data name="DoNotDisableSchUseStrongCrypto" xml:space="preserve">
    <value>Do Not Disable SChannel Use of Strong Crypto</value>
  </data>
  <data name="DoNotDisableSchUseStrongCryptoDescription" xml:space="preserve">
    <value>Starting with the .NET Framework 4.6, the System.Net.ServicePointManager and System.Net.Security.SslStream classes are recommeded to use new protocols. The old ones have protocol weaknesses and are not supported. Setting Switch.System.Net.DontEnableSchUseStrongCrypto with true will use the old weak crypto check and opt out of the protocol migration.</value>
  </data>
  <data name="DoNotDisableSchUseStrongCryptoMessage" xml:space="preserve">
    <value>{0} disables TLS 1.2 and enables SSLv3</value>
  </data>
  <data name="DoNotHardCodeEncryptionKey" xml:space="preserve">
    <value>Do Not Hard Code Encryption Key</value>
  </data>
  <data name="DoNotHardCodeEncryptionKeyDescription" xml:space="preserve">
    <value>SymmetricAlgorithm's .Key property, or a method's rgbKey parameter, should never be a hardcoded value.</value>
  </data>
  <data name="DoNotHardCodeEncryptionKeyMessage" xml:space="preserve">
    <value>Potential security vulnerability was found where '{0}' in method '{1}' may be tainted by hardcoded key from '{2}' in method '{3}'</value>
  </data>
  <data name="DoNotInstallRootCertDescription" xml:space="preserve">
    <value>By default, the Trusted Root Certification Authorities certificate store is configured with a set of public CAs that has met the requirements of the Microsoft Root Certificate Program. Since all trusted root CAs can issue certificates for any domain, an attacker can pick a weak or coercible CA that you install by yourself to target for an attack – and a single vulnerable, malicious or coercible CA undermines the security of the entire system. To make matters worse, these attacks can go unnoticed quite easily.</value>
  </data>
  <data name="DoNotReferSelfInSerializableClass" xml:space="preserve">
    <value>Do Not Refer Self In Serializable Class</value>
  </data>
  <data name="DoNotReferSelfInSerializableClassDescription" xml:space="preserve">
    <value>This can allow an attacker to DOS or exhaust the memory of the process.</value>
  </data>
  <data name="DoNotReferSelfInSerializableClassMessage" xml:space="preserve">
    <value>{0} participates in a potential reference cycle</value>
  </data>
  <data name="DoNotSerializeTypesWithPointerFields" xml:space="preserve">
    <value>Do Not Serialize Types With Pointer Fields</value>
  </data>
  <data name="DoNotSerializeTypesWithPointerFieldsDescription" xml:space="preserve">
    <value>Pointers are not "type safe" in the sense that you cannot guarantee the correctness of the memory they point at. So, serializing types with pointer fields is dangerous, as it may allow an attacker to control the pointer.</value>
  </data>
  <data name="DoNotSerializeTypesWithPointerFieldsMessage" xml:space="preserve">
    <value>Pointer field {0} on serializable type.</value>
  </data>
  <data name="DoNotUseAccountSAS" xml:space="preserve">
    <value>Do Not Use Account Shared Access Signature</value>
  </data>
  <data name="DoNotUseAccountSASDescription" xml:space="preserve">
    <value>Shared Access Signatures(SAS) are a vital part of the security model for any application using Azure Storage, they should provide limited and safe permissions to your storage account to clients that don't have the account key. All of the operations available via a service SAS are also available via an account SAS, that is, account SAS is too powerful. So it is recommended to use Service SAS to delegate access more carefully.</value>
  </data>
  <data name="DoNotUseAccountSASMessage" xml:space="preserve">
    <value>Use Service SAS instead of Account SAS for fine grained access control and container-level access policy</value>
  </data>
  <data name="DoNotUseBrokenCryptographicAlgorithms" xml:space="preserve">
    <value>Do Not Use Broken Cryptographic Algorithms</value>
  </data>
  <data name="DoNotUseBrokenCryptographicAlgorithmsDescription" xml:space="preserve">
    <value>An attack making it computationally feasible to break this algorithm exists. This allows attackers to break the cryptographic guarantees it is designed to provide. Depending on the type and application of this cryptographic algorithm, this may allow attackers to read enciphered messages, tamper with enciphered  messages, forge digital signatures, tamper with hashed content, or otherwise compromise any cryptosystem based on this algorithm. Replace encryption uses with the AES algorithm (AES-256, AES-192 and AES-128 are acceptable) with a key length greater than or equal to 128 bits. Replace hashing uses with a hashing function in the SHA-2 family, such as SHA512, SHA384, or SHA256. Replace digital signature uses with RSA with a key length greater than or equal to 2048-bits, or ECDSA with a key length greater than or equal to 256 bits.</value>
  </data>
  <data name="DoNotUseBrokenCryptographicAlgorithmsMessage" xml:space="preserve">
    <value>{0} uses a broken cryptographic algorithm {1}</value>
  </data>
  <data name="DoNotUseDeprecatedSecurityProtocols" xml:space="preserve">
    <value>Do Not Use Deprecated Security Protocols</value>
  </data>
  <data name="DoNotUseDeprecatedSecurityProtocolsDescription" xml:space="preserve">
    <value>Using a deprecated security protocol rather than the system default is risky.</value>
  </data>
  <data name="DoNotUseDeprecatedSecurityProtocolsMessage" xml:space="preserve">
    <value>Hard-coded use of deprecated security protocol {0}</value>
  </data>
  <data name="DoNotUseDSA" xml:space="preserve">
    <value>Do Not Use Digital Signature Algorithm (DSA)</value>
  </data>
  <data name="DoNotUseDSADescription" xml:space="preserve">
    <value>DSA is too weak to use.</value>
  </data>
  <data name="DoNotUseDSAMessage" xml:space="preserve">
    <value>Asymmetric encryption algorithm {0} is weak. Switch to an RSA with at least 2048 key size, ECDH or ECDSA algorithm instead</value>
  </data>
  <data name="DoNotUseMD5" xml:space="preserve">
    <value>Do not use insecure cryptographic algorithm MD5.</value>
  </data>
  <data name="DoNotUseMD5Description" xml:space="preserve">
    <value>This type implements MD5, a cryptographically insecure hashing function. Hash collisions are computationally feasible for the MD5 and HMACMD5 algorithms. Replace this usage with a SHA-2 family hash algorithm (SHA512, SHA384, SHA256).</value>
  </data>
  <data name="DoNotUseObsoleteKDFAlgorithm" xml:space="preserve">
    <value>Do not use obsolete key derivation function</value>
  </data>
  <data name="DoNotUseObsoleteKDFAlgorithmDescription" xml:space="preserve">
    <value>Password-based key derivation should use PBKDF2 with SHA-2. Avoid using PasswordDeriveBytes since it generates a PBKDF1 key. Avoid using Rfc2898DeriveBytes.CryptDeriveKey since it doesn't use the iteration count or salt.</value>
  </data>
  <data name="DoNotUseObsoleteKDFAlgorithmMessage" xml:space="preserve">
    <value>Call to obsolete key derivation function {0}.{1}</value>
  </data>
  <data name="DoNotUseSHA1" xml:space="preserve">
    <value>Do not use insecure cryptographic algorithm SHA1.</value>
  </data>
  <data name="DoNotUseSHA1Description" xml:space="preserve">
    <value>This type implements SHA1, a cryptographically insecure hashing function. Hash collisions are computationally feasible for the SHA-1 and SHA-0 algorithms. Replace this usage with a SHA-2 family hash algorithm (SHA512, SHA384, SHA256).</value>
  </data>
  <data name="DoNotUseWeakCryptographicAlgorithms" xml:space="preserve">
    <value>Do Not Use Weak Cryptographic Algorithms</value>
  </data>
  <data name="DoNotUseWeakCryptographicAlgorithmsDescription" xml:space="preserve">
    <value>Cryptographic algorithms degrade over time as attacks become for advances to attacker get access to more computation. Depending on the type and application of this cryptographic algorithm, further degradation of the cryptographic strength of it may allow attackers to read enciphered messages, tamper with enciphered  messages, forge digital signatures, tamper with hashed content, or otherwise compromise any cryptosystem based on this algorithm. Replace encryption uses with the AES algorithm (AES-256, AES-192 and AES-128 are acceptable) with a key length greater than or equal to 128 bits. Replace hashing uses with a hashing function in the SHA-2 family, such as SHA-2 512, SHA-2 384, or SHA-2 256.</value>
  </data>
  <data name="DoNotUseWeakCryptographicAlgorithmsMessage" xml:space="preserve">
    <value>{0} uses a weak cryptographic algorithm {1}</value>
  </data>
  <data name="DoNotUseWeakKDFAlgorithm" xml:space="preserve">
    <value>Do Not Use Weak Key Derivation Function Algorithm</value>
  </data>
  <data name="DoNotUseWeakKDFAlgorithmDescription" xml:space="preserve">
    <value>Some implementations of the Rfc2898DeriveBytes class allow for a hash algorithm to be specified in a constructor parameter or overwritten in the HashAlgorithm property. If a hash algorithm is specified, then it should be SHA-256 or higher.</value>
  </data>
  <data name="DoNotUseWeakKDFAlgorithmMessage" xml:space="preserve">
    <value>{0} created with a weak hash algorithm. Use SHA256, SHA384, or SHA512 to create a strong key from a password</value>
  </data>
  <data name="DoNotUseXslTransform" xml:space="preserve">
    <value>Do Not Use XslTransform</value>
  </data>
  <data name="DoNotUseXslTransformMessage" xml:space="preserve">
    <value>Do not use XslTransform. It does not restrict potentially dangerous external references.</value>
  </data>
  <data name="HardCodedSecurityProtocolMessage" xml:space="preserve">
    <value>Avoid hardcoding SecurityProtocolType {0}, and instead use SecurityProtocolType.SystemDefault to allow the operating system to choose the best Transport Layer Security protocol to use.</value>
  </data>
  <data name="HardCodedSecurityProtocolTitle" xml:space="preserve">
    <value>Avoid hardcoding SecurityProtocolType value</value>
  </data>
  <data name="MaybeInstallRootCert" xml:space="preserve">
    <value>Ensure Certificates Are Not Added To Root Store</value>
  </data>
  <data name="MaybeInstallRootCertMessage" xml:space="preserve">
    <value>Adding certificates to the operating system's trusted root certificates is insecure. Ensure that the target store is not root store.</value>
  </data>
  <data name="MaybeUseSecureCookiesASPNetCore" xml:space="preserve">
    <value>Ensure Use Secure Cookies In ASP.Net Core</value>
  </data>
  <data name="MaybeUseSecureCookiesASPNetCoreMessage" xml:space="preserve">
    <value>Ensure that CookieOptions.Secure = true when setting a cookie</value>
  </data>
  <data name="SetViewStateUserKey" xml:space="preserve">
    <value>Set ViewStateUserKey For Classes Derived From Page</value>
  </data>
  <data name="SetViewStateUserKeyDescription" xml:space="preserve">
    <value>Setting the ViewStateUserKey property can help you prevent attacks on your application by allowing you to assign an identifier to the view-state variable for individual users so that they cannot use the variable to generate an attack. Otherwise, there will be cross-site request forgery vulnerabilities.</value>
  </data>
  <data name="SetViewStateUserKeyMessage" xml:space="preserve">
    <value>The class {0} derived from System.Web.UI.Page does not set the ViewStateUserKey property in the OnInit method or Page_Init method</value>
  </data>
  <data name="UseContainerLevelAccessPolicy" xml:space="preserve">
    <value>Use Container Level Access Policy</value>
  </data>
  <data name="UseContainerLevelAccessPolicyDescription" xml:space="preserve">
    <value>No access policy identifier is specified, making tokens non-revocable.</value>
  </data>
  <data name="UseContainerLevelAccessPolicyMessage" xml:space="preserve">
    <value>Consider using Azure's role-based access control instead of a Shared Access Signature (SAS) if possible. If you still need to use a SAS, use a container-level access policy when creating a SAS</value>
  </data>
  <data name="UseSecureCookiesASPNetCoreDescription" xml:space="preserve">
    <value>Applications available over HTTPS must use secure cookies.</value>
  </data>
  <data name="UseSharedAccessProtocolHttpsOnly" xml:space="preserve">
    <value>Use SharedAccessProtocol HttpsOnly</value>
  </data>
  <data name="UseSharedAccessProtocolHttpsOnlyDescription" xml:space="preserve">
    <value>HTTPS encrypts network traffic. Use HttpsOnly, rather than HttpOrHttps, to ensure network traffic is always encrypted to help prevent disclosure of sensitive data.</value>
  </data>
  <data name="UseSharedAccessProtocolHttpsOnlyMessage" xml:space="preserve">
    <value>Consider using Azure's role-based access control instead of a Shared Access Signature (SAS) if possible. If you still need to use a SAS, specify SharedAccessProtocol.HttpsOnly</value>
  </data>
  <data name="UseXmlReaderDescription" xml:space="preserve">
    <value>Processing XML from untrusted data may load dangerous external references, which should be restricted by using an XmlReader with a secure resolver or with DTD processing disabled.</value>
  </data>
  <data name="UseXmlReaderForDataSetReadXml" xml:space="preserve">
    <value>Use XmlReader For DataSet Read Xml</value>
  </data>
  <data name="UseXmlReaderForDeserialize" xml:space="preserve">
    <value>Use XmlReader For Deserialize</value>
  </data>
  <data name="UseXmlReaderForSchemaRead" xml:space="preserve">
    <value>Use XmlReader For Schema Read</value>
  </data>
  <data name="UseXmlReaderForValidatingReader" xml:space="preserve">
    <value>Use XmlReader For Validating Reader</value>
  </data>
  <data name="UseXmlReaderForXPathDocument" xml:space="preserve">
    <value>Use XmlReader For XPathDocument</value>
  </data>
  <data name="UseXmlReaderMessage" xml:space="preserve">
    <value>This overload of the {0}.{1} method is potentially unsafe, use an overload that takes a XmlReader instance instead</value>
  </data>
  <data name="UseRSAWithSufficientKeySize" xml:space="preserve">
    <value>Use Rivest–Shamir–Adleman (RSA) Algorithm With Sufficient Key Size</value>
  </data>
  <data name="UseRSAWithSufficientKeySizeDescription" xml:space="preserve">
    <value>Encryption algorithms are vulnerable to brute force attacks when too small a key size is used.</value>
  </data>
  <data name="UseRSAWithSufficientKeySizeMessage" xml:space="preserve">
    <value>Asymmetric encryption algorithm {0}'s key size is less than 2048. Switch to an RSA with at least 2048 key size, ECDH or ECDSA algorithm instead.</value>
  </data>
  <data name="DefinitelyUseWeakKDFInsufficientIterationCount" xml:space="preserve">
    <value>Do Not Use Weak Key Derivation Function With Insufficient Iteration Count</value>
  </data>
  <data name="DefinitelyUseWeakKDFInsufficientIterationCountMessage" xml:space="preserve">
    <value>Use at least {0} iterations when deriving a cryptographic key from a password. By default, Rfc2898DeriveByte's IterationCount is only 1000</value>
  </data>
  <data name="DoNotUseWeakKDFInsufficientIterationCountDescription" xml:space="preserve">
    <value>When deriving cryptographic keys from user-provided inputs such as password, use sufficient iteration count (at least 100k).</value>
  </data>
  <data name="MaybeUseWeakKDFInsufficientIterationCount" xml:space="preserve">
    <value>Ensure Sufficient Iteration Count When Using Weak Key Derivation Function</value>
  </data>
  <data name="MaybeUseWeakKDFInsufficientIterationCountMessage" xml:space="preserve">
    <value>Ensure that the iteration count is at least {0} when deriving a cryptographic key from a password. By default, Rfc2898DeriveByte's IterationCount is only 1000</value>
  </data>
  <data name="DoNotAddArchiveItemPathToTheTargetFileSystemPath" xml:space="preserve">
    <value>Do Not Add Archive Item's Path To The Target File System Path</value>
  </data>
  <data name="DoNotAddArchiveItemPathToTheTargetFileSystemPathDescription" xml:space="preserve">
    <value>When extracting files from an archive and using the archive item's path, check if the path is safe. Archive path can be relative and can lead to file system access outside of the expected file system target path, leading to malicious config changes and remote code execution via lay-and-wait technique.</value>
  </data>
  <data name="DoNotAddArchiveItemPathToTheTargetFileSystemPathMessage" xml:space="preserve">
    <value>When creating path for '{0} in method {1}' from relative archive item path to extract file and the source is an untrusted zip archive, make sure to sanitize relative archive item path '{2} in method {3}'</value>
  </data>
</root>
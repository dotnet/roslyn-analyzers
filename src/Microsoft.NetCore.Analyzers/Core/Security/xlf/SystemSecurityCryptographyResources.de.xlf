<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="de" original="../SystemSecurityCryptographyResources.resx">
    <body>
      <trans-unit id="ApprovedCipherMode">
        <source>Do Not Use Unsafe Cipher Modes</source>
        <target state="translated">Verwenden Sie keine unsicheren Verschlüsselungsmodi.</target>
        <note />
      </trans-unit>
      <trans-unit id="ApprovedCipherModeDescription">
        <source>These modes are vulnerable to attacks. Use only approved modes (CBC, CTS).</source>
        <target state="translated">Diese Modi sind für Angriffe anfällig. Verwenden Sie nur zugelassene Modi (CBC, CTS).</target>
        <note />
      </trans-unit>
      <trans-unit id="ApprovedCipherModeMessage">
        <source>It uses an unsafe Cipher Mode {0}</source>
        <target state="translated">Ein unsicherer Verschlüsselungsmodus ({0}) wird verwendet.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyInstallRootCert">
        <source>Do Not Add Certificates To Root Store</source>
        <target state="new">Do Not Add Certificates To Root Store</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyInstallRootCertMessage">
        <source>Adding certificates to the operating system's trusted root certificates increases the risk of incorrectly authenticating an illegitimate certificate</source>
        <target state="new">Adding certificates to the operating system's trusted root certificates increases the risk of incorrectly authenticating an illegitimate certificate</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseSecureCookiesASPNetCore">
        <source>Use Secure Cookies In ASP.Net Core</source>
        <target state="new">Use Secure Cookies In ASP.Net Core</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseSecureCookiesASPNetCoreMessage">
        <source>Set CookieOptions.Secure = true when setting a cookie</source>
        <target state="new">Set CookieOptions.Secure = true when setting a cookie</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddSchemaByURL">
        <source>Do Not Add Schema By URL</source>
        <target state="translated">Schema nicht nach URL hinzufügen</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddSchemaByURLDescription">
        <source>This overload of XmlSchemaCollection.Add method internally enables DTD processing on the XML reader instance used, and uses UrlResolver for resolving external XML entities. The outcome is information disclosure. Content from file system or network shares for the machine processing the XML can be exposed to attacker. In addition, an attacker can use this as a DoS vector.</source>
        <target state="translated">Diese Überladung der XmlSchemaCollection.Add-Methode aktiviert intern die DTD-Verarbeitung in der verwendeten XML-Reader-Instanz und verwendet UrlResolver zum Auflösen externer XML-Entitäten. Das Ergebnis ist die Offenlegung von Informationen. Inhalte aus Dateisystem- oder Netzwerkfreigaben für den Computer, der die XML-Daten verarbeitet, können für Angreifer verfügbar gemacht werden. Darüber hinaus kann ein Angreifer sie als DoS-Vektor verwenden.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddSchemaByURLMessage">
        <source>This overload of the Add method is potentially unsafe because it may resolve dangerous external references</source>
        <target state="translated">Diese Überladung der Add-Methode ist möglicherweise unsicher, weil dadurch gefährliche externe Verweise aufgelöst werden können.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallDangerousMethodsInDeserialization">
        <source>Do Not Call Dangerous Methods In Deserialization</source>
        <target state="translated">Keine gefährlichen Methoden bei der Deserialisierung aufrufen</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallDangerousMethodsInDeserializationDescription">
        <source>Insecure Deserialization is a vulnerability which occurs when untrusted data is used to abuse the logic of an application, inflict a Denial-of-Service (DoS) attack, or even execute arbitrary code upon it being deserialized. It’s frequently possible for malicious users to abuse these deserialization features when the application is deserializing untrusted data which is under their control. Specifically, invoke dangerous methods in the process of deserialization. Successful insecure deserialization attacks could allow an attacker to carry out attacks such as DoS attacks, authentication bypasses, and remote code execution.</source>
        <target state="translated">Bei der unsicheren Deserialisierung handelt es sich um ein Sicherheitsrisiko, das auftreten kann, wenn nicht vertrauenswürdige Daten verwendet werden, um die Logik einer Anwendung auf nicht beabsichtigte Weise zu verwenden, einen Denial-of-Service-Angriff (DoS) durchzuführen oder beliebigen Code auszuführen, um diese zu deserialisieren. Angreifer nutzen diese Deserialisierungsfeatures häufig aus, indem sie ihre nicht vertrauenswürdigen Daten von der Anwendung deserialisieren lassen. Während der Deserialisierung werden so insbesondere gefährliche Methoden aufgerufen. Eine erfolgreich durchgeführte unsichere Deserialisierung kann dazu führen, dass der Angreifer DoS-Angriffe durchführen, die Authentifizierung umgehen oder Code remote ausführen kann.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallDangerousMethodsInDeserializationMessage">
        <source>When deserializing an instance of class {0}, method {1} can call dangerous method {2}.</source>
        <target state="translated">Wenn eine Instanz der Klasse {0} deserialisiert wird, kann die Methode {1} die gefährliche Methode {2} aufrufen.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableCertificateValidation">
        <source>Do Not Disable Certificate Validation</source>
        <target state="translated">Deaktivieren Sie die Zertifikatüberprüfung nicht</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableCertificateValidationDescription">
        <source>A certificate can help authenticate the identity of the server. Clients should validate the server certificate to ensure requests are sent to the intended server. If the ServerCertificateValidationCallback always returns 'true', any certificate will pass validation.</source>
        <target state="translated">Mithilfe von Zertifikaten können Sie die Identität des Servers authentifizieren. Clients sollten das Serverzertifikat überprüfen, um sicherzustellen, dass die Anforderungen an den richtigen Server gesendet werden. Wenn die Eigenschaft "ServerCertificateValidationCallback" immer "true" zurückgibt, werden alle Zertifikate als gültig eingestuft.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableCertificateValidationMessage">
        <source>The ServerCertificateValidationCallback is set to a function that accepts any server certificate, by always returning true. Ensure that server certificates are validated to verify the identity of the server receiving requests.</source>
        <target state="translated">Die ServerCertificateValidationCallback-Eigenschaft wurde auf eine Funktion festgelegt, die alle Serverzertifikate akzeptiert, indem immer "true" zurückgegeben wird. Stellen Sie sicher, dass die Serverzertifikate darauf ausgelegt sind, die Identität des Servers zu überprüfen, der Anforderungen erhält.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableHTTPHeaderChecking">
        <source>Do Not Disable HTTP Header Checking</source>
        <target state="translated">Deaktivieren Sie nicht die Überprüfung von HTTP-Headern.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableHTTPHeaderCheckingDescription">
        <source>HTTP header checking enables encoding of the carriage return and newline characters, \r and \n, that are found in response headers. This encoding can help to avoid injection attacks that exploit an application that echoes untrusted data contained by the header.</source>
        <target state="translated">Durch die Überprüfung von HTTP-Headern wird die Codierung der Wagenrücklauf- und Zeilenumbruchzeichen (\r und \n) ermöglicht, die im Antwortheader enthalten sind. Durch diese Codierung können Angriffe durch Einschleusung von Befehlen vermieden werden, bei denen eine Anwendung ausgenutzt wird, die nicht vertrauenswürdige, im Header enthaltene Daten zurückgibt.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableHTTPHeaderCheckingMessage">
        <source>Do not disable HTTP header checking</source>
        <target state="translated">Deaktivieren Sie nicht die Überprüfung von HTTP-Headern.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableRequestValidation">
        <source>Do Not Disable Request Validation</source>
        <target state="translated">Deaktivieren Sie nicht die Anforderungsüberprüfung.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableRequestValidationDescription">
        <source>Request validation is a feature in ASP.NET that examines HTTP requests and determines whether they contain potentially dangerous content. This check adds protection from markup or code in the URL query string, cookies, or posted form values that might have been added for malicious purposes. So, it is generally desirable and should be left enabled for defense in depth.</source>
        <target state="translated">Die Anforderungsüberprüfung ist ein Feature in ASP.NET, das HTTP-Anforderungen untersucht und ermittelt, ob sie potenziell gefährliche Inhalte enthalten. Diese Überprüfung fügt Schutz vor Markup oder Code in der URL-Abfragezeichenfolge, in Cookies oder in bereitgestellten Formularwerten hinzu, das bzw. der möglicherweise zu böswilligen Zwecken hinzugefügt wurden. Deshalb wird sie allgemein empfohlen und sollte für eine detaillierte Verteidigung aktiviert bleiben.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableRequestValidationMessage">
        <source>{0} has request validation disabled</source>
        <target state="translated">Für die Methode "{0}" wurde die Anforderungsüberprüfung deaktiviert.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableSchUseStrongCrypto">
        <source>Do Not Disable SChannel Use of Strong Crypto</source>
        <target state="translated">Deaktivieren Sie die starke Verschlüsselung für Schannel nicht</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableSchUseStrongCryptoDescription">
        <source>Starting with the .NET Framework 4.6, the System.Net.ServicePointManager and System.Net.Security.SslStream classes are recommeded to use new protocols. The old ones have protocol weaknesses and are not supported. Setting Switch.System.Net.DontEnableSchUseStrongCrypto with true will use the old weak crypto check and opt out of the protocol migration.</source>
        <target state="translated">Ab .NET Framework 4.6 wird empfohlen, dass die Klassen System.Net.ServicePointManager und System.Net.Security.SslStream neue Protokolle verwenden. Bei den alten Klassen bestehen Protokollschwächen, weshalb sie nicht unterstützt werden. Wenn Sie Switch.System.Net.DontEnableSchUseStrongCrypto auf "true" festlegen, wird die alte, schwache Verschlüsselungsprüfung verwendet und die Protokollmigration verhindert.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableSchUseStrongCryptoMessage">
        <source>{0} disables TLS 1.2 and enables SSLv3</source>
        <target state="translated">{0} deaktiviert TLS 1.2 und aktiviert SSLv3</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInstallRootCertDescription">
        <source>By default, the Trusted Root Certification Authorities certificate store is configured with a set of public CAs that has met the requirements of the Microsoft Root Certificate Program. Since all trusted root CAs can issue certificates for any domain, an attacker can pick a weak or coercible CA that you install by yourself to target for an attack – and a single vulnerable, malicious or coercible CA undermines the security of the entire system. To make matters worse, these attacks can go unnoticed quite easily.</source>
        <target state="new">By default, the Trusted Root Certification Authorities certificate store is configured with a set of public CAs that has met the requirements of the Microsoft Root Certificate Program. Since all trusted root CAs can issue certificates for any domain, an attacker can pick a weak or coercible CA that you install by yourself to target for an attack – and a single vulnerable, malicious or coercible CA undermines the security of the entire system. To make matters worse, these attacks can go unnoticed quite easily.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotReferSelfInSerializableClass">
        <source>Do Not Refer Self In Serializable Class</source>
        <target state="translated">Verwenden Sie keine Selbstverweise in serialisierbaren Klassen</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotReferSelfInSerializableClassDescription">
        <source>This can allow an attacker to DOS or exhaust the memory of the process.</source>
        <target state="translated">Dies kann zu DOS-Angriffen oder zum Auslasten des Arbeitsspeichers des Prozesses führen.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotReferSelfInSerializableClassMessage">
        <source>{0} participates in a potential reference cycle</source>
        <target state="translated">{0} ist Teil eines potenziellen Verweiszyklus</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotSerializeTypesWithPointerFields">
        <source>Do Not Serialize Types With Pointer Fields</source>
        <target state="translated">Typen mit Zeigerfeldern dürfen nicht serialisiert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotSerializeTypesWithPointerFieldsDescription">
        <source>Pointers are not "type safe" in the sense that you cannot guarantee the correctness of the memory they point at. So, serializing types with pointer fields is dangerous, as it may allow an attacker to control the pointer.</source>
        <target state="translated">Zeiger sind nicht "typensicher", insofern als Sie nicht garantieren können, dass auf den richtigen Arbeitsspeicher verwiesen wird. Daher ist das Serialisieren von Typen mit Zeigerfeldern gefährlich, weil ein Angreifer dadurch möglicherweise den Zeiger steuern kann.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotSerializeTypesWithPointerFieldsMessage">
        <source>Pointer field {0} on serializable type.</source>
        <target state="translated">Zeigerfeld "{0}" für serialisierbaren Typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseAccountSAS">
        <source>Do Not Use Account Shared Access Signature</source>
        <target state="translated">Shared Access Signature des Kontos nicht verwenden</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseAccountSASDescription">
        <source>Shared Access Signatures(SAS) are a vital part of the security model for any application using Azure Storage, they should provide limited and safe permissions to your storage account to clients that don't have the account key. All of the operations available via a service SAS are also available via an account SAS, that is, account SAS is too powerful. So it is recommended to use Service SAS to delegate access more carefully.</source>
        <target state="translated">SAS (Shared Access Signatures) sind ein wichtiger Bestandteil des Sicherheitsmodells für jede Anwendung, die Azure Storage verwendet. Sie müssen eingeschränkte und sichere Berechtigungen für Ihr Speicherkonto für Clients bereitstellen, die nicht über den Kontoschlüssel verfügen. Alle über eine Dienst-SAS verfügbaren Vorgänge sind auch über eine Konto-SAS verfügbar. Die Konto-SAS besitzt daher zu hohe Berechtigungen. Es empfiehlt sich, die Dienst-SAS zu verwenden und den Zugriff detaillierter zu delegieren.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseAccountSASMessage">
        <source>Use Service SAS instead of Account SAS for fine grained access control and container-level access policy</source>
        <target state="translated">Für detailliertere Zugriffssteuerung und Zugriffsrichtlinie auf Containerebene die Dienst-SAS anstelle der Konto-SAS verwenden</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseBrokenCryptographicAlgorithms">
        <source>Do Not Use Broken Cryptographic Algorithms</source>
        <target state="translated">Keine beschädigten kryptografischen Algorithmen verwenden</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseBrokenCryptographicAlgorithmsDescription">
        <source>An attack making it computationally feasible to break this algorithm exists. This allows attackers to break the cryptographic guarantees it is designed to provide. Depending on the type and application of this cryptographic algorithm, this may allow attackers to read enciphered messages, tamper with enciphered  messages, forge digital signatures, tamper with hashed content, or otherwise compromise any cryptosystem based on this algorithm. Replace encryption uses with the AES algorithm (AES-256, AES-192 and AES-128 are acceptable) with a key length greater than or equal to 128 bits. Replace hashing uses with a hashing function in the SHA-2 family, such as SHA512, SHA384, or SHA256. Replace digital signature uses with RSA with a key length greater than or equal to 2048-bits, or ECDSA with a key length greater than or equal to 256 bits.</source>
        <target state="translated">Es ist ein Angriff vorhanden, der es rechnerisch möglich macht, diesen Algorithmus zu zerstören. So können Angreifer die kryptografischen Garantien durchbrechen, für deren Bereitstellung er entwickelt wurde. Je nach Typ und Anwendung dieses kryptografischen Algorithmus können Angreifer verschlüsselte Nachrichten lesen, verschlüsselte Nachrichten manipulieren, digitale Signaturen fälschen, Hashinhalte manipulieren oder jedes auf diesem Algorithmus basierende Verschlüsselungssystem in anderer Hinsicht kompromittieren. Ersetzen Sie die Verwendung von Verschlüsselungen durch den AES-Algorithmus (AES-256, AES-192 und AES-128 sind zulässig) mit einer Schlüssellänge von mindestens 128 Bit. Ersetzen Sie die Verwendung von Hashing durch eine Hashfunktion in der SHA-2-Familie, beispielsweise SHA512, SHA384 oder SHA256. Ersetzen Sie die Verwendung digitaler Signaturen durch RSA mit einer Schlüssellänge von mindestens 2048 Bit oder durch ECDSA mit einer Schlüssellänge von mindestens 256 Bit.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseBrokenCryptographicAlgorithmsMessage">
        <source>{0} uses a broken cryptographic algorithm {1}</source>
        <target state="translated">"{0}" verwendet einen beschädigten kryptografischen Algorithmus: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDSA">
        <source>Do Not Use Digital Signature Algorithm (DSA)</source>
        <target state="new">Do Not Use Digital Signature Algorithm (DSA)</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDSADescription">
        <source>DSA is too weak to use.</source>
        <target state="new">DSA is too weak to use.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDSAMessage">
        <source>Asymmetric encryption algorithm {0} is weak. Switch to an RSA with at least 2048 key size, ECDH or ECDSA algorithm instead</source>
        <target state="new">Asymmetric encryption algorithm {0} is weak. Switch to an RSA with at least 2048 key size, ECDH or ECDSA algorithm instead</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDeprecatedSecurityProtocols">
        <source>Do Not Use Deprecated Security Protocols</source>
        <target state="translated">Verwenden Sie keine veralteten Sicherheitsprotokolle.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDeprecatedSecurityProtocolsDescription">
        <source>Using a deprecated security protocol rather than the system default is risky.</source>
        <target state="translated">Die Verwendung eines veralteten Sicherheitsprotokolls anstelle des Systemstandards ist riskant.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDeprecatedSecurityProtocolsMessage">
        <source>Hard-coded use of deprecated security protocol {0}</source>
        <target state="translated">Hartcodierte Verwendung des veralteten Sicherheitsprotokolls "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseMD5">
        <source>Do not use insecure cryptographic algorithm MD5.</source>
        <target state="translated">Verwenden Sie nicht den unsicheren kryptografischen Algorithmus MD5.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseMD5Description">
        <source>This type implements MD5, a cryptographically insecure hashing function. Hash collisions are computationally feasible for the MD5 and HMACMD5 algorithms. Replace this usage with a SHA-2 family hash algorithm (SHA512, SHA384, SHA256).</source>
        <target state="translated">Dieser Typ implementiert MD5, eine kryptografisch unsichere Hashfunktion. Hashkollisionen sind für die Algorithmen MD5 und HMACMD5 rechnerisch möglich. Ersetzen Sie diese Verwendung durch einen Hashalgorithmus der SHA-2-Familie (SHA512, SHA384, SHA256).</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseObsoleteKDFAlgorithm">
        <source>Do not use obsolete key derivation function</source>
        <target state="translated">Keine veraltete Schlüsselableitungsfunktion verwenden</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseObsoleteKDFAlgorithmDescription">
        <source>Password-based key derivation should use PBKDF2 with SHA-2. Avoid using PasswordDeriveBytes since it generates a PBKDF1 key. Avoid using Rfc2898DeriveBytes.CryptDeriveKey since it doesn't use the iteration count or salt.</source>
        <target state="translated">Die kennwortbasierte Schlüsselableitung sollte PBKDF2 mit SHA-2 verwenden. Verwenden Sie nicht PasswordDeriveBytes, da hierbei ein PBKDF1-Schlüssel generiert wird. Verwenden Sie nicht Rfc2898DeriveBytes.CryptDeriveKey, da hierbei weder Iterationszählung noch Salt verwendet werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseObsoleteKDFAlgorithmMessage">
        <source>Call to obsolete key derivation function {0}.{1}</source>
        <target state="translated">Aufruf der veralteten Schlüsselableitungsfunktion {0}.{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSHA1">
        <source>Do not use insecure cryptographic algorithm SHA1.</source>
        <target state="translated">Verwenden Sie nicht den unsicheren kryptografischen SHA1-Algorithmus.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSHA1Description">
        <source>This type implements SHA1, a cryptographically insecure hashing function. Hash collisions are computationally feasible for the SHA-1 and SHA-0 algorithms. Replace this usage with a SHA-2 family hash algorithm (SHA512, SHA384, SHA256).</source>
        <target state="translated">Dieser Typ implementiert SHA1, eine kryptografisch unsichere Hashfunktion. Hashkollisionen sind für die Algorithmen SHA-1 und SHA-0 rechnerisch möglich. Ersetzen Sie diese Verwendung durch einen Hashalgorithmus der SHA-2-Familie (SHA512, SHA384, SHA256).</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakCryptographicAlgorithms">
        <source>Do Not Use Weak Cryptographic Algorithms</source>
        <target state="translated">Keine schwachen kryptografischen Algorithmen verwenden</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakCryptographicAlgorithmsDescription">
        <source>Cryptographic algorithms degrade over time as attacks become for advances to attacker get access to more computation. Depending on the type and application of this cryptographic algorithm, further degradation of the cryptographic strength of it may allow attackers to read enciphered messages, tamper with enciphered  messages, forge digital signatures, tamper with hashed content, or otherwise compromise any cryptosystem based on this algorithm. Replace encryption uses with the AES algorithm (AES-256, AES-192 and AES-128 are acceptable) with a key length greater than or equal to 128 bits. Replace hashing uses with a hashing function in the SHA-2 family, such as SHA-2 512, SHA-2 384, or SHA-2 256.</source>
        <target state="translated">Kryptografische Algorithmen verlieren mit der Zeit ihre Wirkung, weil Angreifer ihre Methoden verbessern und Zugang zu umfangreicheren Berechnungsalgorithmen erhalten. Je nach Typ und Anwendung dieses kryptografischen Algorithmus können Angreifer durch eine weitere Herabsetzung der kryptografischen Stärke verschlüsselte Nachrichten lesen, verschlüsselte Nachrichten manipulieren, digitale Signaturen fälschen, Hashinhalte manipulieren oder jedes auf diesem Algorithmus basierende Verschlüsselungssystem in anderer Hinsicht kompromittieren. Ersetzen Sie die Verwendung von Verschlüsselungen durch den AES-Algorithmus (AES-256, AES-192 und AES-128 sind zulässig) mit einer Schlüssellänge von mindestens 128 Bit. Ersetzen Sie die Verwendung von Hashing durch eine Hashfunktion in der SHA-2-Familie, beispielsweise SHA-2 512, SHA-2 384 oder SHA-2 256.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakCryptographicAlgorithmsMessage">
        <source>{0} uses a weak cryptographic algorithm {1}</source>
        <target state="translated">"{0}" verwendet einen schwachen kryptografischen Algorithmus: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakKDFAlgorithm">
        <source>Do Not Use Weak Key Derivation Function Algorithm</source>
        <target state="new">Do Not Use Weak Key Derivation Function Algorithm</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakKDFAlgorithmDescription">
        <source>Some implementations of the Rfc2898DeriveBytes class allow for a hash algorithm to be specified in a constructor parameter or overwritten in the HashAlgorithm property. If a hash algorithm is specified, then it should be SHA-256 or higher.</source>
        <target state="new">Some implementations of the Rfc2898DeriveBytes class allow for a hash algorithm to be specified in a constructor parameter or overwritten in the HashAlgorithm property. If a hash algorithm is specified, then it should be SHA-256 or higher.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakKDFAlgorithmMessage">
        <source>{0} created with a weak hash algorithm. Use SHA256, SHA384, or SHA512 to create a strong key from a password</source>
        <target state="new">{0} created with a weak hash algorithm. Use SHA256, SHA384, or SHA512 to create a strong key from a password</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseXslTransform">
        <source>Do Not Use XslTransform</source>
        <target state="translated">Kein XslTransform verwenden</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseXslTransformMessage">
        <source>Do not use XslTransform. It does not restrict potentially dangerous external references.</source>
        <target state="translated">Verwenden Sie kein XslTransform. Es schränkt potenziell gefährliche externe Verweise nicht ein.</target>
        <note />
      </trans-unit>
      <trans-unit id="HardCodedSecurityProtocolMessage">
        <source>Avoid hardcoding SecurityProtocolType {0}, and instead use SecurityProtocolType.SystemDefault to allow the operating system to choose the best Transport Layer Security protocol to use.</source>
        <target state="new">Avoid hardcoding SecurityProtocolType {0}, and instead use SecurityProtocolType.SystemDefault to allow the operating system to choose the best Transport Layer Security protocol to use.</target>
        <note />
      </trans-unit>
      <trans-unit id="HardCodedSecurityProtocolTitle">
        <source>Avoid hardcoding SecurityProtocolType value</source>
        <target state="new">Avoid hardcoding SecurityProtocolType value</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeInstallRootCert">
        <source>Ensure Certificates Are Not Added To Root Store</source>
        <target state="new">Ensure Certificates Are Not Added To Root Store</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeInstallRootCertMessage">
        <source>Adding certificates to the operating system's trusted root certificates is insecure. Ensure that the target store is not root store.</source>
        <target state="new">Adding certificates to the operating system's trusted root certificates is insecure. Ensure that the target store is not root store.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseSecureCookiesASPNetCore">
        <source>Ensure Use Secure Cookies In ASP.Net Core</source>
        <target state="new">Ensure Use Secure Cookies In ASP.Net Core</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseSecureCookiesASPNetCoreMessage">
        <source>Ensure that CookieOptions.Secure = true when setting a cookie</source>
        <target state="new">Ensure that CookieOptions.Secure = true when setting a cookie</target>
        <note />
      </trans-unit>
      <trans-unit id="SetViewStateUserKey">
        <source>Set ViewStateUserKey For Classes Derived From Page</source>
        <target state="translated">Legen Sie ViewStateUserKey für von der Seite abgeleitete Klassen fest.</target>
        <note />
      </trans-unit>
      <trans-unit id="SetViewStateUserKeyDescription">
        <source>Setting the ViewStateUserKey property can help you prevent attacks on your application by allowing you to assign an identifier to the view-state variable for individual users so that they cannot use the variable to generate an attack. Otherwise, there will be cross-site request forgery vulnerabilities.</source>
        <target state="translated">Durch Festlegen der ViewStateUserKey-Eigenschaft können Sie Angriffe auf Ihre Anwendung verhindern, indem Sie der view-state-Variablen für einzelne Benutzer einen Bezeichner zuweisen können, damit diese die Variable nicht zum Generieren eines Angriffs verwenden können. Andernfalls besteht das Sicherheitsrisiko der websiteübergreifenden Anforderungsfälschung.</target>
        <note />
      </trans-unit>
      <trans-unit id="SetViewStateUserKeyMessage">
        <source>The subclass {0} of Page does not set the ViewStateUserKey property in method OnInit</source>
        <target state="translated">Die Unterklasse "{0}" der Seite legt nicht die ViewStateUserKey-Eigenschaft in der OnInit-Methode fest.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseContainerLevelAccessPolicy">
        <source>Use Container Level Access Policy</source>
        <target state="new">Use Container Level Access Policy</target>
        <note />
      </trans-unit>
      <trans-unit id="UseContainerLevelAccessPolicyDescription">
        <source>No access policy identifier is specified, making tokens non-revocable.</source>
        <target state="new">No access policy identifier is specified, making tokens non-revocable.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseContainerLevelAccessPolicyMessage">
        <source>Consider using Azure's role-based access control instead of a Shared Access Signature (SAS) if possible. If you still need to use a SAS, use a container-level access policy when creating a SAS</source>
        <target state="new">Consider using Azure's role-based access control instead of a Shared Access Signature (SAS) if possible. If you still need to use a SAS, use a container-level access policy when creating a SAS</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRSAWithSufficientKeySize">
        <source>Use Rivest–Shamir–Adleman (RSA) Algorithm With Sufficient Key Size</source>
        <target state="new">Use Rivest–Shamir–Adleman (RSA) Algorithm With Sufficient Key Size</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRSAWithSufficientKeySizeDescription">
        <source>Encryption algorithms are vulnerable to brute force attacks when too small a key size is used.</source>
        <target state="new">Encryption algorithms are vulnerable to brute force attacks when too small a key size is used.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRSAWithSufficientKeySizeMessage">
        <source>Asymmetric encryption algorithm {0}'s key size is less than 2048. Switch to an RSA with at least 2048 key size, ECDH or ECDSA algorithm instead.</source>
        <target state="new">Asymmetric encryption algorithm {0}'s key size is less than 2048. Switch to an RSA with at least 2048 key size, ECDH or ECDSA algorithm instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSecureCookiesASPNetCoreDescription">
        <source>Applications available over HTTPS must use secure cookies.</source>
        <target state="new">Applications available over HTTPS must use secure cookies.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSharedAccessProtocolHttpsOnly">
        <source>Use SharedAccessProtocol HttpsOnly</source>
        <target state="translated">SharedAccessProtocol HttpsOnly verwenden</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSharedAccessProtocolHttpsOnlyDescription">
        <source>HTTPS encrypts network traffic. Use HttpsOnly, rather than HttpOrHttps, to ensure network traffic is always encrypted to help prevent disclosure of sensitive data.</source>
        <target state="translated">HTTPS verschlüsselt den Netzwerkdatenverkehr. Verwenden Sie HttpsOnly anstelle von HttpOrHttps, um sicherzustellen, dass der Netzwerkdatenverkehr immer verschlüsselt ist, um die Offenlegung vertraulicher Daten zu verhindern.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSharedAccessProtocolHttpsOnlyMessage">
        <source>Consider using Azure's role-based access control instead of a Shared Access Signature (SAS) if possible. If you still need to use a SAS, specify SharedAccessProtocol.HttpsOnly</source>
        <target state="translated">Erwägen Sie, wenn möglich, die rollenbasierte Zugriffssteuerung von Azure anstelle einer Shared Access Signature (SAS) zu verwenden. Wenn Sie noch eine SAS verwenden müssen, geben Sie "SharedAccessProtocol. HttpsOnly" an.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderDescription">
        <source>Processing XML from untrusted data may load dangerous external references, which should be restricted by using an XmlReader with a secure resolver or with DTD processing disabled.</source>
        <target state="translated">Durch das Verarbeiten von XML aus nicht vertrauenswürdigen Daten werden möglicherweise gefährliche externe Verweise geladen, die mithilfe eines XmlReaders mit sicherem Konfliktlöser oder mit deaktivierter DTD-Verarbeitung eingeschränkt werden müssen.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDataSetReadXml">
        <source>Use XmlReader For DataSet Read Xml</source>
        <target state="translated">XmlReader zum Lesen von DataSet-XML verwenden</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDeserialize">
        <source>Use XmlReader For Deserialize</source>
        <target state="translated">XmlReader zum Deserialisieren verwenden</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForSchemaRead">
        <source>Use XmlReader For Schema Read</source>
        <target state="translated">XmlReader zum Lesen von Schemas verwenden</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForValidatingReader">
        <source>Use XmlReader For Validating Reader</source>
        <target state="translated">XmlReader zum Überprüfen von Reader verwenden</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForXPathDocument">
        <source>Use XmlReader For XPathDocument</source>
        <target state="translated">XmlReader für XPathDocument verwenden</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderMessage">
        <source>This overload of the {0}.{1} method is potentially unsafe, use an overload that takes a XmlReader instance instead</source>
        <target state="translated">Diese Überladung der {0}.{1}-Methode ist möglicherweise unsicher. Verwenden Sie eine Überladung, die stattdessen eine XmlReader-Instanz akzeptiert.</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
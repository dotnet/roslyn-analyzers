<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ko" original="../SystemSecurityCryptographyResources.resx">
    <body>
      <trans-unit id="ApprovedCipherMode">
        <source>Do Not Use Unsafe Cipher Modes</source>
        <target state="translated">안전하지 않은 암호화 모드를 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ApprovedCipherModeDescription">
        <source>These modes are vulnerable to attacks. Use only approved modes (CBC, CTS).</source>
        <target state="translated">이러한 모드는 공격에 취약합니다. 승인된 모드(CBC, CTS)만 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ApprovedCipherModeMessage">
        <source>It uses an unsafe Cipher Mode {0}</source>
        <target state="translated">안전하지 않은 암호화 모드 {0}을(를) 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyInstallRootCert">
        <source>Do Not Add Certificates To Root Store</source>
        <target state="new">Do Not Add Certificates To Root Store</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyInstallRootCertMessage">
        <source>Adding certificates to the operating system's trusted root certificates increases the risk of incorrectly authenticating an illegitimate certificate</source>
        <target state="new">Adding certificates to the operating system's trusted root certificates increases the risk of incorrectly authenticating an illegitimate certificate</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseSecureCookiesASPNetCore">
        <source>Use Secure Cookies In ASP.Net Core</source>
        <target state="new">Use Secure Cookies In ASP.Net Core</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseSecureCookiesASPNetCoreMessage">
        <source>Set CookieOptions.Secure = true when setting a cookie</source>
        <target state="new">Set CookieOptions.Secure = true when setting a cookie</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddSchemaByURL">
        <source>Do Not Add Schema By URL</source>
        <target state="translated">URL로 스키마를 추가하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddSchemaByURLDescription">
        <source>This overload of XmlSchemaCollection.Add method internally enables DTD processing on the XML reader instance used, and uses UrlResolver for resolving external XML entities. The outcome is information disclosure. Content from file system or network shares for the machine processing the XML can be exposed to attacker. In addition, an attacker can use this as a DoS vector.</source>
        <target state="translated">XmlSchemaCollection.Add 메서드의 이 오버로드는 사용되는 XML 판독기에서 내부적으로 DTD 처리를 사용하도록 설정하고 UrlResolver를 사용하여 외부 XML 엔터티를 확인합니다. 결과는 정보 공개입니다. XML을 처리하는 머신에 대한 파일 시스템 또는 네트워크 공유의 콘텐츠가 공격자에게 공개될 수 있습니다. 또한 공격자가 이 취약성을 DoS 벡터로 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddSchemaByURLMessage">
        <source>This overload of the Add method is potentially unsafe because it may resolve dangerous external references</source>
        <target state="translated">Add 메서드의 이 오버로드는 위험한 외부 참조를 확인할 수 있으므로 잠재적으로 안전하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallDangerousMethodsInDeserialization">
        <source>Do Not Call Dangerous Methods In Deserialization</source>
        <target state="translated">역직렬화에서 위험한 메서드를 호출하면 안 됨</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallDangerousMethodsInDeserializationDescription">
        <source>Insecure Deserialization is a vulnerability which occurs when untrusted data is used to abuse the logic of an application, inflict a Denial-of-Service (DoS) attack, or even execute arbitrary code upon it being deserialized. It’s frequently possible for malicious users to abuse these deserialization features when the application is deserializing untrusted data which is under their control. Specifically, invoke dangerous methods in the process of deserialization. Successful insecure deserialization attacks could allow an attacker to carry out attacks such as DoS attacks, authentication bypasses, and remote code execution.</source>
        <target state="translated">안전하지 않은 deserialization은 트러스트되지 않은 데이터를 사용하여 애플리케이션 논리를 남용할 때 발생하는 취약성이고, DoS(서비스 거부) 공격을 가하거나 deserialize될 때 임의의 코드를 실행하기도 합니다. 종종 악의적인 사용자가 제어하는 트리스트되지 않은 데이터를 애플리케이션에서 deserialize할 때 이러한 deserialization 기능을 사용할 수 있습니다. 특히 deserialization 과정에 위험한 메서드를 호출합니다. 안전하지 않은 deserialization 공격이 성공하면 공격자가 DoS 공격, 인증 건너뜀 및 원격 코드 실행과 같은 공격을 수행할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallDangerousMethodsInDeserializationMessage">
        <source>When deserializing an instance of class {0}, method {1} can call dangerous method {2}.</source>
        <target state="translated">{0} 클래스의 인스턴스를 deserialize할 때 {1} 메서드가 위험한 {2} 메서드를 호출할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableCertificateValidation">
        <source>Do Not Disable Certificate Validation</source>
        <target state="translated">인증서 유효성 검사를 비활성화하지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableCertificateValidationDescription">
        <source>A certificate can help authenticate the identity of the server. Clients should validate the server certificate to ensure requests are sent to the intended server. If the ServerCertificateValidationCallback always returns 'true', any certificate will pass validation.</source>
        <target state="translated">인증서는 서버의 ID를 인증하는 데 도움이 될 수 있습니다. 클라이언트가 요청을 원하는 서버에 보내려면 서버 인증서의 유효성을 검사해야 합니다. ServerCertificateValidationCallback이 항상 'true'를 반환하는 경우 모든 인증서가 유효성 검사를 통과합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableCertificateValidationMessage">
        <source>The ServerCertificateValidationCallback is set to a function that accepts any server certificate, by always returning true. Ensure that server certificates are validated to verify the identity of the server receiving requests.</source>
        <target state="translated">ServerCertificateValidationCallback은 항상 true를 반환하여 서버 인증서를 허용하는 함수로 설정되어 있습니다. 서버 인증서의 유효성을 검사하여 요청을 받는 서버의 ID를 확인해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableHTTPHeaderChecking">
        <source>Do Not Disable HTTP Header Checking</source>
        <target state="translated">HTTP 헤더 검사를 사용하지 않도록 설정하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableHTTPHeaderCheckingDescription">
        <source>HTTP header checking enables encoding of the carriage return and newline characters, \r and \n, that are found in response headers. This encoding can help to avoid injection attacks that exploit an application that echoes untrusted data contained by the header.</source>
        <target state="translated">HTTP 헤더 검사를 사용하면 응답 헤더에 있는 캐리지 리턴 및 줄 바꿈 문자 \r 및 \n을 인코딩할 수 있습니다. 이 인코딩을 수행하면 헤더에 포함된 신뢰할 수 없는 데이터를 에코하는 애플리케이션을 악용하는 삽입 공격을 방지할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableHTTPHeaderCheckingMessage">
        <source>Do not disable HTTP header checking</source>
        <target state="translated">HTTP 헤더 검사를 사용하지 않도록 설정하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableRequestValidation">
        <source>Do Not Disable Request Validation</source>
        <target state="translated">요청 유효성 검사를 사용하지 않도록 설정하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableRequestValidationDescription">
        <source>Request validation is a feature in ASP.NET that examines HTTP requests and determines whether they contain potentially dangerous content. This check adds protection from markup or code in the URL query string, cookies, or posted form values that might have been added for malicious purposes. So, it is generally desirable and should be left enabled for defense in depth.</source>
        <target state="translated">요청 유효성 검사는 HTTP 요청을 검사하고 잠재적으로 위험한 콘텐츠가 포함되는지 확인하는 ASP.NET 기능입니다. 이 검사는 악의적인 목적으로 추가되었을 수 있는 URL 쿼리 문자열, 쿠키 또는 게시된 양식 값에 있는 태그 또는 코드에서 보호를 추가합니다. 따라서 일반적으로 이 검사를 수행하는 것이 좋고 심층 방어를 위해 사용하도록 설정해 두어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableRequestValidationMessage">
        <source>{0} has request validation disabled</source>
        <target state="translated">메서드 {0}에서 요청 유효성 검사가 사용하지 않도록 설정되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableSchUseStrongCrypto">
        <source>Do Not Disable SChannel Use of Strong Crypto</source>
        <target state="translated">SChannel의 강력한 암호화 사용을 비활성화하지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableSchUseStrongCryptoDescription">
        <source>Starting with the .NET Framework 4.6, the System.Net.ServicePointManager and System.Net.Security.SslStream classes are recommeded to use new protocols. The old ones have protocol weaknesses and are not supported. Setting Switch.System.Net.DontEnableSchUseStrongCrypto with true will use the old weak crypto check and opt out of the protocol migration.</source>
        <target state="translated">.NET Framework 4.6부터 System.Net.ServicePointManager 및 System.Net.Security.SslStream 클래스의 경우 새 프로토콜을 사용하는 것이 좋습니다. 프로토콜 약점이 있는 기존 프로토콜은 지원되지 않습니다. Switch.System.Net.DontEnableSchUseStrongCrypto를 true로 설정하면 이전의 취약한 암호화 검사를 사용하여 프로토콜 마이그레이션을 옵트아웃합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableSchUseStrongCryptoMessage">
        <source>{0} disables TLS 1.2 and enables SSLv3</source>
        <target state="translated">{0}이(가) TLS 1.2를 사용하지 않도록, SSLv3를 사용하도록 설정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInstallRootCertDescription">
        <source>By default, the Trusted Root Certification Authorities certificate store is configured with a set of public CAs that has met the requirements of the Microsoft Root Certificate Program. Since all trusted root CAs can issue certificates for any domain, an attacker can pick a weak or coercible CA that you install by yourself to target for an attack – and a single vulnerable, malicious or coercible CA undermines the security of the entire system. To make matters worse, these attacks can go unnoticed quite easily.</source>
        <target state="new">By default, the Trusted Root Certification Authorities certificate store is configured with a set of public CAs that has met the requirements of the Microsoft Root Certificate Program. Since all trusted root CAs can issue certificates for any domain, an attacker can pick a weak or coercible CA that you install by yourself to target for an attack – and a single vulnerable, malicious or coercible CA undermines the security of the entire system. To make matters worse, these attacks can go unnoticed quite easily.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotReferSelfInSerializableClass">
        <source>Do Not Refer Self In Serializable Class</source>
        <target state="translated">직렬화 가능 클래스에서 자체 참조하지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotReferSelfInSerializableClassDescription">
        <source>This can allow an attacker to DOS or exhaust the memory of the process.</source>
        <target state="translated">이를 통해 공격자는 DOS 공격을 수행하거나 프로세스의 메모리를 모두 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotReferSelfInSerializableClassMessage">
        <source>{0} participates in a potential reference cycle</source>
        <target state="translated">{0}이(가) 잠재적 참조 순환에 참여합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotSerializeTypesWithPointerFields">
        <source>Do Not Serialize Types With Pointer Fields</source>
        <target state="translated">포인터 필드를 사용하여 형식을 직렬화하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotSerializeTypesWithPointerFieldsDescription">
        <source>Pointers are not "type safe" in the sense that you cannot guarantee the correctness of the memory they point at. So, serializing types with pointer fields is dangerous, as it may allow an attacker to control the pointer.</source>
        <target state="translated">포인터는 가리키는 메모리의 정확성을 보장할 수 없다는 점에서 "형식이 안전"하지 않습니다. 따라서 공격자가 포인터를 제어하게 될 수 있으므로 포인터 필드를 사용하여 형식을 직렬화하는 것은 위험합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotSerializeTypesWithPointerFieldsMessage">
        <source>Pointer field {0} on serializable type.</source>
        <target state="translated">serializable 형식의 포인터 필드 {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseAccountSAS">
        <source>Do Not Use Account Shared Access Signature</source>
        <target state="translated">계정 공유 액세스 서명 사용 안 함</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseAccountSASDescription">
        <source>Shared Access Signatures(SAS) are a vital part of the security model for any application using Azure Storage, they should provide limited and safe permissions to your storage account to clients that don't have the account key. All of the operations available via a service SAS are also available via an account SAS, that is, account SAS is too powerful. So it is recommended to use Service SAS to delegate access more carefully.</source>
        <target state="translated">SAS(공유 액세스 서명)는 Azure Storage를 사용하는 애플리케이션에 대한 보안 모델의 필수적인 부분으로, 계정 키가 없는 클라이언트에 스토리지 계정에 대한 제한되고 안전한 권한을 제공해야 합니다. 서비스 SAS를 통해 사용할 수 있는 모든 작업은 계정 SAS를 통해서도 사용할 수 있습니다. 즉, 계정 SAS는 권한이 너무 강력합니다. 따라서 서비스 SAS를 사용하여 액세스 권한을 더욱 신중하게 위임하는 것이 좋습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseAccountSASMessage">
        <source>Use Service SAS instead of Account SAS for fine grained access control and container-level access policy</source>
        <target state="translated">세분화된 액세스 제어와 컨테이너 수준 액세스 정책을 위해 계정 SAS가 아닌 서비스 SAS 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseBrokenCryptographicAlgorithms">
        <source>Do Not Use Broken Cryptographic Algorithms</source>
        <target state="translated">손상된 암호화 알고리즘을 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseBrokenCryptographicAlgorithmsDescription">
        <source>An attack making it computationally feasible to break this algorithm exists. This allows attackers to break the cryptographic guarantees it is designed to provide. Depending on the type and application of this cryptographic algorithm, this may allow attackers to read enciphered messages, tamper with enciphered  messages, forge digital signatures, tamper with hashed content, or otherwise compromise any cryptosystem based on this algorithm. Replace encryption uses with the AES algorithm (AES-256, AES-192 and AES-128 are acceptable) with a key length greater than or equal to 128 bits. Replace hashing uses with a hashing function in the SHA-2 family, such as SHA512, SHA384, or SHA256. Replace digital signature uses with RSA with a key length greater than or equal to 2048-bits, or ECDSA with a key length greater than or equal to 256 bits.</source>
        <target state="translated">계산상 이 알고리즘을 손상시킬 수 있는 공격이 있습니다. 이를 통해, 제공되어야 하는 암호화 보장이 공격자에 의해 손상될 수 있습니다. 암호화 알고리즘의 형식과 애플리케이션에 따라 공격자가 암호화된 메시지를 읽고, 암호화된 메시지를 변조하고, 디지털 서명을 위조하고, 해시된 콘텐츠를 변조하거나 이 알고리즘 기반의 암호화 시스템을 손상시킬 수 있습니다. 암호화를 키 길이가 128비트보다 크거나 같은 AES 알고리즘(AES-256, AES-192 및 AES-128 사용 가능)으로 바꾸세요. 해시를 SHA512, SHA384 또는 SHA256과 같은 SHA-2 패밀리의 해시 알고리즘으로 바꾸세요. 디지털 서명을 키 길이가 2048비트보다 크거나 같은 RSA 또는 키 길이가 256비트보다 크거나 같은 ECDSA로 바꾸세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseBrokenCryptographicAlgorithmsMessage">
        <source>{0} uses a broken cryptographic algorithm {1}</source>
        <target state="translated">{0}이(가) 손상된 암호화 알고리즘 {1}을(를) 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDSA">
        <source>Do Not Use Digital Signature Algorithm (DSA)</source>
        <target state="new">Do Not Use Digital Signature Algorithm (DSA)</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDSADescription">
        <source>DSA is too weak to use.</source>
        <target state="new">DSA is too weak to use.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDSAMessage">
        <source>Asymmetric encryption algorithm {0} is weak. Switch to an RSA with at least 2048 key size, ECDH or ECDSA algorithm instead</source>
        <target state="new">Asymmetric encryption algorithm {0} is weak. Switch to an RSA with at least 2048 key size, ECDH or ECDSA algorithm instead</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDeprecatedSecurityProtocols">
        <source>Do Not Use Deprecated Security Protocols</source>
        <target state="translated">사용되지 않는 보안 프로토콜을 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDeprecatedSecurityProtocolsDescription">
        <source>Using a deprecated security protocol rather than the system default is risky.</source>
        <target state="translated">시스템 기본값이 아닌 사용되지 않는 보안 프로토콜을 사용하는 것은 위험합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDeprecatedSecurityProtocolsMessage">
        <source>Hard-coded use of deprecated security protocol {0}</source>
        <target state="translated">사용되지 않는 보안 프로토콜 {0}의 하드 코드된 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseMD5">
        <source>Do not use insecure cryptographic algorithm MD5.</source>
        <target state="translated">안전하지 않은 암호화 알고리즘 MD5를 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseMD5Description">
        <source>This type implements MD5, a cryptographically insecure hashing function. Hash collisions are computationally feasible for the MD5 and HMACMD5 algorithms. Replace this usage with a SHA-2 family hash algorithm (SHA512, SHA384, SHA256).</source>
        <target state="translated">이 형식은 안전하지 않게 암호화된 해시 알고리즘인 MD5를 구현합니다. MD5 및 HMACMD5 알고리즘에서 계산상 해시 충돌이 발생할 수 있습니다. 이 사용법을 SHA-2 패밀리 해시 알고리즘(SHA512, SHA384, SHA256)으로 바꾸세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseObsoleteKDFAlgorithm">
        <source>Do not use obsolete key derivation function</source>
        <target state="translated">사용되지 않는 키 파생 함수 사용 안 함</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseObsoleteKDFAlgorithmDescription">
        <source>Password-based key derivation should use PBKDF2 with SHA-2. Avoid using PasswordDeriveBytes since it generates a PBKDF1 key. Avoid using Rfc2898DeriveBytes.CryptDeriveKey since it doesn't use the iteration count or salt.</source>
        <target state="translated">암호 기반 키 파생은 PBKDF2와 SHA-2를 사용해야 합니다. PasswordDeriveBytes는 PBKDF1 키를 생성하므로 사용하지 마세요. Rfc2898DeriveBytes.CryptDeriveKey는 반복 횟수 또는 솔트를 사용하지 않으므로 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseObsoleteKDFAlgorithmMessage">
        <source>Call to obsolete key derivation function {0}.{1}</source>
        <target state="translated">사용되지 않는 키 파생 함수 {0}.{1}에 대한 호출</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSHA1">
        <source>Do not use insecure cryptographic algorithm SHA1.</source>
        <target state="translated">안전하지 않은 암호화 알고리즘 SHA1을 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSHA1Description">
        <source>This type implements SHA1, a cryptographically insecure hashing function. Hash collisions are computationally feasible for the SHA-1 and SHA-0 algorithms. Replace this usage with a SHA-2 family hash algorithm (SHA512, SHA384, SHA256).</source>
        <target state="translated">이 형식은 안전하지 않게 암호화된 해시 알고리즘인 SHA1을 구현합니다. SHA-1 및 SHA-0 알고리즘에서 계산상 해시 충돌이 발생할 수 있습니다. 이 사용법을 SHA-2 패밀리 해시 알고리즘(SHA512, SHA384, SHA256)으로 바꾸세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakCryptographicAlgorithms">
        <source>Do Not Use Weak Cryptographic Algorithms</source>
        <target state="translated">취약한 암호화 알고리즘을 사용하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakCryptographicAlgorithmsDescription">
        <source>Cryptographic algorithms degrade over time as attacks become for advances to attacker get access to more computation. Depending on the type and application of this cryptographic algorithm, further degradation of the cryptographic strength of it may allow attackers to read enciphered messages, tamper with enciphered  messages, forge digital signatures, tamper with hashed content, or otherwise compromise any cryptosystem based on this algorithm. Replace encryption uses with the AES algorithm (AES-256, AES-192 and AES-128 are acceptable) with a key length greater than or equal to 128 bits. Replace hashing uses with a hashing function in the SHA-2 family, such as SHA-2 512, SHA-2 384, or SHA-2 256.</source>
        <target state="translated">암호화 알고리즘의 성능이 점점 저하되어 공격자가 더 많은 계산에 액세스할 수 있도록 공격이 진화합니다. 암호화 알고리즘의 형식과 애플리케이션 및 계속 저하되는 암호화 기능에 따라 공격자가 암호화된 메시지를 읽고, 암호화된 메시지를 변조하고, 디지털 서명을 위조하고, 해시된 콘텐츠를 변조하거나 이 알고리즘 기반의 암호화 시스템을 손상시킬 수 있습니다. 암호화를 키 길이가 128비트보다 크거나 같은 AES 알고리즘(AES-256, AES-192 및 AES-128 사용 가능)으로 바꾸세요. 해시를 SHA-2 512, SHA-2 384 또는 SHA-2 256과 같은 SHA-2 패밀리의 해시 알고리즘으로 바꾸세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakCryptographicAlgorithmsMessage">
        <source>{0} uses a weak cryptographic algorithm {1}</source>
        <target state="translated">{0}이(가) 취약한 암호화 알고리즘 {1}을(를) 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakKDFAlgorithm">
        <source>Do Not Use Weak Key Derivation Function Algorithm</source>
        <target state="new">Do Not Use Weak Key Derivation Function Algorithm</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakKDFAlgorithmDescription">
        <source>Some implementations of the Rfc2898DeriveBytes class allow for a hash algorithm to be specified in a constructor parameter or overwritten in the HashAlgorithm property. If a hash algorithm is specified, then it should be SHA-256 or higher.</source>
        <target state="new">Some implementations of the Rfc2898DeriveBytes class allow for a hash algorithm to be specified in a constructor parameter or overwritten in the HashAlgorithm property. If a hash algorithm is specified, then it should be SHA-256 or higher.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakKDFAlgorithmMessage">
        <source>{0} created with a weak hash algorithm. Use SHA256, SHA384, or SHA512 to create a strong key from a password</source>
        <target state="new">{0} created with a weak hash algorithm. Use SHA256, SHA384, or SHA512 to create a strong key from a password</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseXslTransform">
        <source>Do Not Use XslTransform</source>
        <target state="translated">XslTransform 사용 안 함</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseXslTransformMessage">
        <source>Do not use XslTransform. It does not restrict potentially dangerous external references.</source>
        <target state="translated">XslTransform을 사용하지 마세요. 잠재적으로 위험한 외부 참조를 제한하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="HardCodedSecurityProtocolMessage">
        <source>Avoid hardcoding SecurityProtocolType {0}, and instead use SecurityProtocolType.SystemDefault to allow the operating system to choose the best Transport Layer Security protocol to use.</source>
        <target state="new">Avoid hardcoding SecurityProtocolType {0}, and instead use SecurityProtocolType.SystemDefault to allow the operating system to choose the best Transport Layer Security protocol to use.</target>
        <note />
      </trans-unit>
      <trans-unit id="HardCodedSecurityProtocolTitle">
        <source>Avoid hardcoding SecurityProtocolType value</source>
        <target state="new">Avoid hardcoding SecurityProtocolType value</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeInstallRootCert">
        <source>Ensure Certificates Are Not Added To Root Store</source>
        <target state="new">Ensure Certificates Are Not Added To Root Store</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeInstallRootCertMessage">
        <source>Adding certificates to the operating system's trusted root certificates is insecure. Ensure that the target store is not root store.</source>
        <target state="new">Adding certificates to the operating system's trusted root certificates is insecure. Ensure that the target store is not root store.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseSecureCookiesASPNetCore">
        <source>Ensure Use Secure Cookies In ASP.Net Core</source>
        <target state="new">Ensure Use Secure Cookies In ASP.Net Core</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseSecureCookiesASPNetCoreMessage">
        <source>Ensure that CookieOptions.Secure = true when setting a cookie</source>
        <target state="new">Ensure that CookieOptions.Secure = true when setting a cookie</target>
        <note />
      </trans-unit>
      <trans-unit id="SetViewStateUserKey">
        <source>Set ViewStateUserKey For Classes Derived From Page</source>
        <target state="translated">Page에서 파생된 클래스의 ViewStateUserKey 설정</target>
        <note />
      </trans-unit>
      <trans-unit id="SetViewStateUserKeyDescription">
        <source>Setting the ViewStateUserKey property can help you prevent attacks on your application by allowing you to assign an identifier to the view-state variable for individual users so that they cannot use the variable to generate an attack. Otherwise, there will be cross-site request forgery vulnerabilities.</source>
        <target state="translated">ViewStateUserKey 속성을 설정하면 공격을 생성하는 데 변수를 사용할 수 없도록 개별 사용자의 뷰 상태 변수에 식별자를 할당할 수 있어 애플리케이션에 대한 공격을 방지할 수 있습니다. 그렇지 않으면 교차 사이트 요청 위조 취약성이 발생합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SetViewStateUserKeyMessage">
        <source>The subclass {0} of Page does not set the ViewStateUserKey property in method OnInit</source>
        <target state="translated">Page의 서브클래스 {0}은(는) OnInit 메서드에서 ViewStateUserKey 속성을 설정하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseContainerLevelAccessPolicy">
        <source>Use Container Level Access Policy</source>
        <target state="new">Use Container Level Access Policy</target>
        <note />
      </trans-unit>
      <trans-unit id="UseContainerLevelAccessPolicyDescription">
        <source>No access policy identifier is specified, making tokens non-revocable.</source>
        <target state="new">No access policy identifier is specified, making tokens non-revocable.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseContainerLevelAccessPolicyMessage">
        <source>Consider using Azure's role-based access control instead of a Shared Access Signature (SAS) if possible. If you still need to use a SAS, use a container-level access policy when creating a SAS</source>
        <target state="new">Consider using Azure's role-based access control instead of a Shared Access Signature (SAS) if possible. If you still need to use a SAS, use a container-level access policy when creating a SAS</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRSAWithSufficientKeySize">
        <source>Use Rivest–Shamir–Adleman (RSA) Algorithm With Sufficient Key Size</source>
        <target state="new">Use Rivest–Shamir–Adleman (RSA) Algorithm With Sufficient Key Size</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRSAWithSufficientKeySizeDescription">
        <source>Encryption algorithms are vulnerable to brute force attacks when too small a key size is used.</source>
        <target state="new">Encryption algorithms are vulnerable to brute force attacks when too small a key size is used.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRSAWithSufficientKeySizeMessage">
        <source>Asymmetric encryption algorithm {0}'s key size is less than 2048. Switch to an RSA with at least 2048 key size, ECDH or ECDSA algorithm instead.</source>
        <target state="new">Asymmetric encryption algorithm {0}'s key size is less than 2048. Switch to an RSA with at least 2048 key size, ECDH or ECDSA algorithm instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSecureCookiesASPNetCoreDescription">
        <source>Applications available over HTTPS must use secure cookies.</source>
        <target state="new">Applications available over HTTPS must use secure cookies.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSharedAccessProtocolHttpsOnly">
        <source>Use SharedAccessProtocol HttpsOnly</source>
        <target state="translated">SharedAccessProtocol HttpsOnly 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSharedAccessProtocolHttpsOnlyDescription">
        <source>HTTPS encrypts network traffic. Use HttpsOnly, rather than HttpOrHttps, to ensure network traffic is always encrypted to help prevent disclosure of sensitive data.</source>
        <target state="translated">HTTPS는 네트워크 트래픽을 암호화 합니다. 중요 한 데이터가 공개 되지 않도록 하려면 HttpOrHttps 대신 HttpsOnly를 사용 하 여 네트워크 트래픽이 항상 암호화 되도록 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSharedAccessProtocolHttpsOnlyMessage">
        <source>Consider using Azure's role-based access control instead of a Shared Access Signature (SAS) if possible. If you still need to use a SAS, specify SharedAccessProtocol.HttpsOnly</source>
        <target state="translated">가능한 경우 SA (공유 액세스 서명) 대신 Azure의 역할 기반 액세스 제어를 사용 하십시오. 여전히 SA를 사용 해야 하는 경우 SharedAccessProtocol을 지정 합니다. HttpsOnly</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderDescription">
        <source>Processing XML from untrusted data may load dangerous external references, which should be restricted by using an XmlReader with a secure resolver or with DTD processing disabled.</source>
        <target state="translated">신뢰할 수 없는 데이터의 XML을 처리하면 위험한 외부 참조가 로드될 수 있습니다. 위험한 외부 참조는 안전한 확인자와 함께 또는 DTD 처리를 사용하지 않도록 설정한 상태로 XmlReader를 사용하여 제한해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDataSetReadXml">
        <source>Use XmlReader For DataSet Read Xml</source>
        <target state="translated">데이터 세트 읽기 Xml에 XmlReader 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDeserialize">
        <source>Use XmlReader For Deserialize</source>
        <target state="translated">Deserialize에 XmlReader 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForSchemaRead">
        <source>Use XmlReader For Schema Read</source>
        <target state="translated">스키마 읽기에 XmlReader 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForValidatingReader">
        <source>Use XmlReader For Validating Reader</source>
        <target state="translated">판독기 유효성 검사에 XmlReader 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForXPathDocument">
        <source>Use XmlReader For XPathDocument</source>
        <target state="translated">XPathDocument에 XmlReader 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderMessage">
        <source>This overload of the {0}.{1} method is potentially unsafe, use an overload that takes a XmlReader instance instead</source>
        <target state="translated">{0}.{1} 메서드의 이 오버로드는 안전하지 않을 수 있으므로 대신 XmlReader 인스턴스를 사용하는 오버로드를 사용하세요.</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
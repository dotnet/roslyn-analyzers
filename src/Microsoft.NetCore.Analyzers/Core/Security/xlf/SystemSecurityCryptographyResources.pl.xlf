<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="pl" original="../SystemSecurityCryptographyResources.resx">
    <body>
      <trans-unit id="ApprovedCipherMode">
        <source>Do Not Use Unsafe Cipher Modes</source>
        <target state="translated">Nie używaj niebezpiecznych trybów szyfrowania</target>
        <note />
      </trans-unit>
      <trans-unit id="ApprovedCipherModeDescription">
        <source>These modes are vulnerable to attacks. Use only approved modes (CBC, CTS).</source>
        <target state="translated">Te tryby są podatne na ataki. Używaj jedynie zatwierdzonych trybów (CBC, CTS).</target>
        <note />
      </trans-unit>
      <trans-unit id="ApprovedCipherModeMessage">
        <source>It uses an unsafe Cipher Mode {0}</source>
        <target state="translated">Używa niebezpiecznego trybu szyfrowania {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyInstallRootCert">
        <source>Do Not Add Certificates To Root Store</source>
        <target state="new">Do Not Add Certificates To Root Store</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyInstallRootCertMessage">
        <source>Adding certificates to the operating system's trusted root certificates increases the risk of incorrectly authenticating an illegitimate certificate</source>
        <target state="new">Adding certificates to the operating system's trusted root certificates increases the risk of incorrectly authenticating an illegitimate certificate</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseSecureCookiesASPNetCore">
        <source>Use Secure Cookies In ASP.Net Core</source>
        <target state="new">Use Secure Cookies In ASP.Net Core</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseSecureCookiesASPNetCoreMessage">
        <source>Set CookieOptions.Secure = true when setting a cookie</source>
        <target state="new">Set CookieOptions.Secure = true when setting a cookie</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddSchemaByURL">
        <source>Do Not Add Schema By URL</source>
        <target state="translated">Nie dodawaj schematu przez adres URL</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddSchemaByURLDescription">
        <source>This overload of XmlSchemaCollection.Add method internally enables DTD processing on the XML reader instance used, and uses UrlResolver for resolving external XML entities. The outcome is information disclosure. Content from file system or network shares for the machine processing the XML can be exposed to attacker. In addition, an attacker can use this as a DoS vector.</source>
        <target state="translated">To przeciążenie metody XmlSchemaCollection.Add wewnętrznie umożliwia przetwarzanie elementu DTD w używanym wystąpieniu obiektu odczytującego XML i używa elementu UrlResolver do rozpoznawania zewnętrznych jednostek XML. Wynikiem jest ujawnienie informacji. 	Zawartość systemu plików lub udziałów sieciowych w przypadku maszynowego przetwarzania elementu XML może być narażona na atak. Ponadto atakujący może użyć tego jako wektora ataku DoS.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddSchemaByURLMessage">
        <source>This overload of the Add method is potentially unsafe because it may resolve dangerous external references</source>
        <target state="translated">To przeciążenie metody Add jest potencjalnie niebezpieczne, ponieważ może spowodować powstanie niebezpiecznych odwołań zewnętrznych</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallDangerousMethodsInDeserialization">
        <source>Do Not Call Dangerous Methods In Deserialization</source>
        <target state="translated">Nie wywołuj niebezpiecznych metod w deserializacji</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallDangerousMethodsInDeserializationDescription">
        <source>Insecure Deserialization is a vulnerability which occurs when untrusted data is used to abuse the logic of an application, inflict a Denial-of-Service (DoS) attack, or even execute arbitrary code upon it being deserialized. It’s frequently possible for malicious users to abuse these deserialization features when the application is deserializing untrusted data which is under their control. Specifically, invoke dangerous methods in the process of deserialization. Successful insecure deserialization attacks could allow an attacker to carry out attacks such as DoS attacks, authentication bypasses, and remote code execution.</source>
        <target state="translated">Niezabezpieczona deserializacja to luka w zabezpieczeniach, która występuje, gdy niezaufane dane są używane w przypadku nadużywania logiki aplikacji, przeprowadzania ataku typu „odmowa usługi” (DoS), a nawet wykonywania kodu umownego w trakcie deserializacji. Złośliwi użytkownicy często mogą nadużywać tych funkcji deserializacji, gdy aplikacja deserializuje niezaufane dane, które są kontrolowane przez te funkcje. W szczególności może ona wywoływać niebezpieczne metody w procesie deserializacji. Skuteczne ataki typu „niezabezpieczona deserializacja” mogą pozwolić osobie atakującej na przeprowadzanie ataków, takich jak ataki DoS, pomijanie uwierzytelniania i zdalne wykonywanie kodu.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallDangerousMethodsInDeserializationMessage">
        <source>When deserializing an instance of class {0}, method {1} can call dangerous method {2}.</source>
        <target state="translated">Podczas deserializacji wystąpienia klasy {0} metoda {1} może wywołać niebezpieczną metodę {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableCertificateValidation">
        <source>Do Not Disable Certificate Validation</source>
        <target state="translated">Nie należy wyłączać walidacji certyfikatów</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableCertificateValidationDescription">
        <source>A certificate can help authenticate the identity of the server. Clients should validate the server certificate to ensure requests are sent to the intended server. If the ServerCertificateValidationCallback always returns 'true', any certificate will pass validation.</source>
        <target state="translated">Certyfikat może pomóc uwierzytelnić tożsamość serwera. Klienci powinni weryfikować certyfikat serwera, aby upewnić się, że żądania są wysyłane do odpowiedniego serwera. Jeśli element ServerCertificateValidationCallback zawsze zwraca wartość „true”, walidacja każdego certyfikatu zakończy się powodzeniem.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableCertificateValidationMessage">
        <source>The ServerCertificateValidationCallback is set to a function that accepts any server certificate, by always returning true. Ensure that server certificates are validated to verify the identity of the server receiving requests.</source>
        <target state="translated">Właściwość zestawu ServerCertificateValidationCallback została ustawiona na funkcję, która akceptuje dowolny certyfikat serwera, zawsze zwracając wartość true. Upewnij się, że certyfikaty serwera zostały walidowane, aby zweryfikować tożsamość serwera odbierającego żądania.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableHTTPHeaderChecking">
        <source>Do Not Disable HTTP Header Checking</source>
        <target state="translated">Nie wyłączaj sprawdzania nagłówka HTTP</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableHTTPHeaderCheckingDescription">
        <source>HTTP header checking enables encoding of the carriage return and newline characters, \r and \n, that are found in response headers. This encoding can help to avoid injection attacks that exploit an application that echoes untrusted data contained by the header.</source>
        <target state="translated">Sprawdzanie nagłówka HTTP umożliwia kodowanie znaków powrotu karetki i nowego wiersza, \r i \n, które znajdują się w nagłówkach odpowiedzi. To kodowanie może pomóc uniknąć ataków polegających na wstrzyknięciu kodu, które wykorzystują aplikację przekazującą niezaufane dane zawarte w nagłówku.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableHTTPHeaderCheckingMessage">
        <source>Do not disable HTTP header checking</source>
        <target state="translated">Nie wyłączaj sprawdzania nagłówków HTTP</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableRequestValidation">
        <source>Do Not Disable Request Validation</source>
        <target state="translated">Nie wyłączaj weryfikacji żądań</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableRequestValidationDescription">
        <source>Request validation is a feature in ASP.NET that examines HTTP requests and determines whether they contain potentially dangerous content. This check adds protection from markup or code in the URL query string, cookies, or posted form values that might have been added for malicious purposes. So, it is generally desirable and should be left enabled for defense in depth.</source>
        <target state="translated">Weryfikacja żądań to funkcja platformy ASP.NET, która sprawdza żądania HTTP i określa, czy zawierają potencjalnie niebezpieczną zawartość. To sprawdzenie zapewnia dodatkową ochronę przed znacznikami lub kodem w ciągu zapytania adresu URL, plikach cookie lub przesłanych wartościach formularza, które mogły zostać dodane w złośliwym celu. Ogólnie jest to pożądana funkcja i powinna pozostać włączona, aby zapewnić ochronę w głębi systemu.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableRequestValidationMessage">
        <source>{0} has request validation disabled</source>
        <target state="translated">Metoda {0} ma wyłączoną weryfikację żądań</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableSchUseStrongCrypto">
        <source>Do Not Disable SChannel Use of Strong Crypto</source>
        <target state="translated">Nie należy wyłączać użycia silnej kryptografii w pakiecie SChannel</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableSchUseStrongCryptoDescription">
        <source>Starting with the .NET Framework 4.6, the System.Net.ServicePointManager and System.Net.Security.SslStream classes are recommeded to use new protocols. The old ones have protocol weaknesses and are not supported. Setting Switch.System.Net.DontEnableSchUseStrongCrypto with true will use the old weak crypto check and opt out of the protocol migration.</source>
        <target state="translated">Zaczynając od programu .NET Framework 4.6, klasy System.Net.ServicePointManager i System.Net.Security.SslStream są zalecane do użycia dla nowych protokołów. W starych występują słabości protokołu i nie są one obsługiwane. Ustawienie wartości true dla parametru Switch.System.Net.DontEnableSchUseStrongCrypto spowoduje użycie starego i słabego sprawdzania kryptograficznego oraz rezygnację z migracji protokołu.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableSchUseStrongCryptoMessage">
        <source>{0} disables TLS 1.2 and enables SSLv3</source>
        <target state="translated">Metoda {0} wyłącza protokół TLS 1.2 i włącza protokół SSLv3</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInstallRootCertDescription">
        <source>By default, the Trusted Root Certification Authorities certificate store is configured with a set of public CAs that has met the requirements of the Microsoft Root Certificate Program. Since all trusted root CAs can issue certificates for any domain, an attacker can pick a weak or coercible CA that you install by yourself to target for an attack – and a single vulnerable, malicious or coercible CA undermines the security of the entire system. To make matters worse, these attacks can go unnoticed quite easily.</source>
        <target state="new">By default, the Trusted Root Certification Authorities certificate store is configured with a set of public CAs that has met the requirements of the Microsoft Root Certificate Program. Since all trusted root CAs can issue certificates for any domain, an attacker can pick a weak or coercible CA that you install by yourself to target for an attack – and a single vulnerable, malicious or coercible CA undermines the security of the entire system. To make matters worse, these attacks can go unnoticed quite easily.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotReferSelfInSerializableClass">
        <source>Do Not Refer Self In Serializable Class</source>
        <target state="translated">Nie przywołuj klasy możliwej do serializacji w niej samej</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotReferSelfInSerializableClassDescription">
        <source>This can allow an attacker to DOS or exhaust the memory of the process.</source>
        <target state="translated">Może to umożliwić atakującemu przeprowadzenie ataku DoS lub wyczerpanie pamięci procesu.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotReferSelfInSerializableClassMessage">
        <source>{0} participates in a potential reference cycle</source>
        <target state="translated">Element {0} należy do potencjalnego cyklu odwołań</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotSerializeTypesWithPointerFields">
        <source>Do Not Serialize Types With Pointer Fields</source>
        <target state="translated">Nie serializuj typów z polami wskaźników</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotSerializeTypesWithPointerFieldsDescription">
        <source>Pointers are not "type safe" in the sense that you cannot guarantee the correctness of the memory they point at. So, serializing types with pointer fields is dangerous, as it may allow an attacker to control the pointer.</source>
        <target state="translated">Wskaźniki nie są „bezpieczne pod względem typu” w tym sensie, że nie można zagwarantować poprawności pamięci, którą wskazują. W związu z tym serializowanie typów z polami wskaźnika jest niebezpieczne, ponieważ może umożliwić atakującemu kontrolowanie wskaźnika.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotSerializeTypesWithPointerFieldsMessage">
        <source>Pointer field {0} on serializable type.</source>
        <target state="translated">Pole wskaźnika {0} w typie przeznaczonym do serializacji.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseAccountSAS">
        <source>Do Not Use Account Shared Access Signature</source>
        <target state="translated">Nie korzystaj z sygnatury dostępu współdzielonego konta</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseAccountSASDescription">
        <source>Shared Access Signatures(SAS) are a vital part of the security model for any application using Azure Storage, they should provide limited and safe permissions to your storage account to clients that don't have the account key. All of the operations available via a service SAS are also available via an account SAS, that is, account SAS is too powerful. So it is recommended to use Service SAS to delegate access more carefully.</source>
        <target state="translated">Sygnatury dostępu współdzielonego (SAS) są istotną częścią modelu zabezpieczeń każdej aplikacji korzystającej z usługi Azure Storage. Powinny one zapewniać ograniczone i bezpieczne uprawnienia do konta magazynu klientom, którzy nie mają klucza konta. Wszystkie operacje dostępne za pośrednictwem sygnatury dostępu współdzielonego usługi są także dostępne za pośrednictwem sygnatury dostępu współdzielonego konta, co oznacza, że sygnatura dostępu współdzielonego konta daje zbyt szerokie uprawnienia. Dlatego zaleca się, aby korzystać z sygnatury dostępu współdzielonego usługi do ostrożniejszego delegowania dostępu.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseAccountSASMessage">
        <source>Use Service SAS instead of Account SAS for fine grained access control and container-level access policy</source>
        <target state="translated">Użyj sygnatury dostępu współdzielonego usługi zamiast sygnatury dostępu współdzielonego konta w celu uzyskania szczegółowej kontroli dostępu i zasad dostępu na poziomie kontenera</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseBrokenCryptographicAlgorithms">
        <source>Do Not Use Broken Cryptographic Algorithms</source>
        <target state="translated">Nie używaj złamanych algorytmów kryptograficznych</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseBrokenCryptographicAlgorithmsDescription">
        <source>An attack making it computationally feasible to break this algorithm exists. This allows attackers to break the cryptographic guarantees it is designed to provide. Depending on the type and application of this cryptographic algorithm, this may allow attackers to read enciphered messages, tamper with enciphered  messages, forge digital signatures, tamper with hashed content, or otherwise compromise any cryptosystem based on this algorithm. Replace encryption uses with the AES algorithm (AES-256, AES-192 and AES-128 are acceptable) with a key length greater than or equal to 128 bits. Replace hashing uses with a hashing function in the SHA-2 family, such as SHA512, SHA384, or SHA256. Replace digital signature uses with RSA with a key length greater than or equal to 2048-bits, or ECDSA with a key length greater than or equal to 256 bits.</source>
        <target state="translated">Możliwe jest przeprowadzenie ataku umożliwiającego obliczeniowe złamanie tego algorytmu. Pozwala to atakującym na złamanie kryptograficznych gwarancji, jakie powinien zapewniać. W zależności od typu i zastosowania tego algorytmu kryptograficznego może to umożliwić atakującemu odczytanie zaszyfrowanych wiadomości, ingerowanie w zaszyfrowane wiadomości, fałszowanie podpisów cyfrowych, ingerowanie w mieszaną zawartość lub inne naruszenie systemu kryptograficznego opartego na tym algorytmie. Zastąp użycia szyfrowane algorytmem AES (akceptowane są algorytmy AES-256, AES-192 i AES-128) z kluczem o długości równej lub większej niż 128 bitów. Zastąp użycia mieszane funkcją skrótu z rodziny SHA-2, taką jak SHA512, SHA384 lub SHA256. Zastąp użycia podpisu cyfrowego certyfikatem RSA z kluczem o długości równej lub większej niż 2048 bitów lub certyfikatem ECDSA z kluczem o długości równej lub większej niż 256 bitów.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseBrokenCryptographicAlgorithmsMessage">
        <source>{0} uses a broken cryptographic algorithm {1}</source>
        <target state="translated">Element {0} używa złamanych algorytmów kryptograficznych {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDSA">
        <source>Do Not Use Digital Signature Algorithm (DSA)</source>
        <target state="new">Do Not Use Digital Signature Algorithm (DSA)</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDSADescription">
        <source>DSA is too weak to use.</source>
        <target state="new">DSA is too weak to use.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDSAMessage">
        <source>Asymmetric encryption algorithm {0} is weak. Switch to an RSA with at least 2048 key size, ECDH or ECDSA algorithm instead</source>
        <target state="new">Asymmetric encryption algorithm {0} is weak. Switch to an RSA with at least 2048 key size, ECDH or ECDSA algorithm instead</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDeprecatedSecurityProtocols">
        <source>Do Not Use Deprecated Security Protocols</source>
        <target state="translated">Nie używaj przestarzałych protokołów zabezpieczeń</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDeprecatedSecurityProtocolsDescription">
        <source>Using a deprecated security protocol rather than the system default is risky.</source>
        <target state="translated">Używanie przestarzałego protokołu zabezpieczeń zamiast domyślnego ustawienia systemowego jest ryzykowne.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDeprecatedSecurityProtocolsMessage">
        <source>Hard-coded use of deprecated security protocol {0}</source>
        <target state="translated">Zakodowane korzystanie z przestarzałego protokołu zabezpieczeń {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseMD5">
        <source>Do not use insecure cryptographic algorithm MD5.</source>
        <target state="translated">Nie używaj niezabezpieczonego algorytmu kryptograficznego MD5.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseMD5Description">
        <source>This type implements MD5, a cryptographically insecure hashing function. Hash collisions are computationally feasible for the MD5 and HMACMD5 algorithms. Replace this usage with a SHA-2 family hash algorithm (SHA512, SHA384, SHA256).</source>
        <target state="translated">Ten typ implementuje niezabezpieczoną kryptograficznie funkcję skrótu MD5. Istnieje możliwość wystąpienia kolizji skrótów w przypadku algorytmów MD5 i HMACMD5. Zastąp to użycie algorytmem wartości skrótu z rodziny SHA-2 (SHA512, SHA384, SHA256).</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseObsoleteKDFAlgorithm">
        <source>Do not use obsolete key derivation function</source>
        <target state="translated">Nie używaj przestarzałej funkcji wyprowadzenia klucza</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseObsoleteKDFAlgorithmDescription">
        <source>Password-based key derivation should use PBKDF2 with SHA-2. Avoid using PasswordDeriveBytes since it generates a PBKDF1 key. Avoid using Rfc2898DeriveBytes.CryptDeriveKey since it doesn't use the iteration count or salt.</source>
        <target state="translated">Wyprowadzenie klucza oparte na haśle powinno używać funkcji PBKDF2 z algorytmem SHA-2. Unikaj używania klasy PasswordDeriveBytes, ponieważ generuje ona klucz PBKDF1. Unikaj używania klasy Rfc2898DeriveBytes.CryptDeriveKey, ponieważ nie używa ona liczby iteracji ani wartości zaburzającej.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseObsoleteKDFAlgorithmMessage">
        <source>Call to obsolete key derivation function {0}.{1}</source>
        <target state="translated">Wywołanie przestarzałej funkcji wyprowadzania klucza {0}.{1}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSHA1">
        <source>Do not use insecure cryptographic algorithm SHA1.</source>
        <target state="translated">Nie używaj niezabezpieczonego algorytmu kryptograficznego SHA1.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSHA1Description">
        <source>This type implements SHA1, a cryptographically insecure hashing function. Hash collisions are computationally feasible for the SHA-1 and SHA-0 algorithms. Replace this usage with a SHA-2 family hash algorithm (SHA512, SHA384, SHA256).</source>
        <target state="translated">Ten typ implementuje niezabezpieczoną kryptograficznie funkcję skrótu SHA1. Istnieje możliwość wystąpienia kolizji skrótów w przypadku algorytmów SHA-1 i SHA-0. Zastąp to użycie algorytmem wartości skrótu z rodziny SHA-2 (SHA512, SHA384, SHA256).</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakCryptographicAlgorithms">
        <source>Do Not Use Weak Cryptographic Algorithms</source>
        <target state="translated">Nie używaj słabych algorytmów kryptograficznych</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakCryptographicAlgorithmsDescription">
        <source>Cryptographic algorithms degrade over time as attacks become for advances to attacker get access to more computation. Depending on the type and application of this cryptographic algorithm, further degradation of the cryptographic strength of it may allow attackers to read enciphered messages, tamper with enciphered  messages, forge digital signatures, tamper with hashed content, or otherwise compromise any cryptosystem based on this algorithm. Replace encryption uses with the AES algorithm (AES-256, AES-192 and AES-128 are acceptable) with a key length greater than or equal to 128 bits. Replace hashing uses with a hashing function in the SHA-2 family, such as SHA-2 512, SHA-2 384, or SHA-2 256.</source>
        <target state="translated">Algorytmy kryptograficzne pogarszają się z upływem czasu, ponieważ ataki stają się coraz bardziej zaawansowane, a atakujący zyskują dostęp do większej ilości zasobów obliczeniowych. W zależności od typu i zastosowania tego algorytmu kryptograficznego dalsze osłabianie siły kryptograficznej algorytmu może umożliwić atakującemu odczytanie zaszyfrowanych wiadomości, ingerowanie w zaszyfrowane wiadomości, fałszowanie podpisów cyfrowych, ingerowanie w mieszaną zawartość lub inne naruszenie systemu kryptograficznego opartego na tym algorytmie. Zastąp użycia szyfrowane algorytmem AES (akceptowane są algorytmy AES-256, AES-192 i AES-128) z kluczem o długości równej lub większej niż 128 bitów. Zastąp użycia mieszane funkcją skrótu z rodziny SHA-2, taką jak SHA-2 512, SHA-2 384 lub SHA-2 256.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakCryptographicAlgorithmsMessage">
        <source>{0} uses a weak cryptographic algorithm {1}</source>
        <target state="translated">Element {0} używa słabych algorytmów kryptograficznych {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakKDFAlgorithm">
        <source>Do Not Use Weak Key Derivation Function Algorithm</source>
        <target state="new">Do Not Use Weak Key Derivation Function Algorithm</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakKDFAlgorithmDescription">
        <source>Some implementations of the Rfc2898DeriveBytes class allow for a hash algorithm to be specified in a constructor parameter or overwritten in the HashAlgorithm property. If a hash algorithm is specified, then it should be SHA-256 or higher.</source>
        <target state="new">Some implementations of the Rfc2898DeriveBytes class allow for a hash algorithm to be specified in a constructor parameter or overwritten in the HashAlgorithm property. If a hash algorithm is specified, then it should be SHA-256 or higher.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakKDFAlgorithmMessage">
        <source>{0} created with a weak hash algorithm. Use SHA256, SHA384, or SHA512 to create a strong key from a password</source>
        <target state="new">{0} created with a weak hash algorithm. Use SHA256, SHA384, or SHA512 to create a strong key from a password</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseXslTransform">
        <source>Do Not Use XslTransform</source>
        <target state="translated">Nie używaj klasy XslTransform</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseXslTransformMessage">
        <source>Do not use XslTransform. It does not restrict potentially dangerous external references.</source>
        <target state="translated">Nie używaj klasy XslTransform. Nie ogranicza to potencjalnie niebezpiecznych odwołań zewnętrznych.</target>
        <note />
      </trans-unit>
      <trans-unit id="HardCodedSecurityProtocolMessage">
        <source>Avoid hardcoding SecurityProtocolType {0}, and instead use SecurityProtocolType.SystemDefault to allow the operating system to choose the best Transport Layer Security protocol to use.</source>
        <target state="new">Avoid hardcoding SecurityProtocolType {0}, and instead use SecurityProtocolType.SystemDefault to allow the operating system to choose the best Transport Layer Security protocol to use.</target>
        <note />
      </trans-unit>
      <trans-unit id="HardCodedSecurityProtocolTitle">
        <source>Avoid hardcoding SecurityProtocolType value</source>
        <target state="new">Avoid hardcoding SecurityProtocolType value</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeInstallRootCert">
        <source>Ensure Certificates Are Not Added To Root Store</source>
        <target state="new">Ensure Certificates Are Not Added To Root Store</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeInstallRootCertMessage">
        <source>Adding certificates to the operating system's trusted root certificates is insecure. Ensure that the target store is not root store.</source>
        <target state="new">Adding certificates to the operating system's trusted root certificates is insecure. Ensure that the target store is not root store.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseSecureCookiesASPNetCore">
        <source>Ensure Use Secure Cookies In ASP.Net Core</source>
        <target state="new">Ensure Use Secure Cookies In ASP.Net Core</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseSecureCookiesASPNetCoreMessage">
        <source>Ensure that CookieOptions.Secure = true when setting a cookie</source>
        <target state="new">Ensure that CookieOptions.Secure = true when setting a cookie</target>
        <note />
      </trans-unit>
      <trans-unit id="SetViewStateUserKey">
        <source>Set ViewStateUserKey For Classes Derived From Page</source>
        <target state="translated">Ustaw właściwość ViewStateUserKey dla klas pochodzących od klasy Page</target>
        <note />
      </trans-unit>
      <trans-unit id="SetViewStateUserKeyDescription">
        <source>Setting the ViewStateUserKey property can help you prevent attacks on your application by allowing you to assign an identifier to the view-state variable for individual users so that they cannot use the variable to generate an attack. Otherwise, there will be cross-site request forgery vulnerabilities.</source>
        <target state="translated">Ustawienie właściwości ViewStateUserKey może pomóc zapobiec atakom na aplikację, umożliwiając przypisanie identyfikatora do zmiennej view-state dla poszczególnych użytkowników, aby nie mogli użyć zmiennej do wygenerowania ataku. W przeciwnym razie będą istniały luki w zabezpieczeniach przed fałszowaniem żądań międzywitrynowych.</target>
        <note />
      </trans-unit>
      <trans-unit id="SetViewStateUserKeyMessage">
        <source>The subclass {0} of Page does not set the ViewStateUserKey property in method OnInit</source>
        <target state="translated">Podklasa {0} klasy Page nie ustawia właściwości ViewStateUserKey w metodzie OnInit</target>
        <note />
      </trans-unit>
      <trans-unit id="UseContainerLevelAccessPolicy">
        <source>Use Container Level Access Policy</source>
        <target state="new">Use Container Level Access Policy</target>
        <note />
      </trans-unit>
      <trans-unit id="UseContainerLevelAccessPolicyDescription">
        <source>No access policy identifier is specified, making tokens non-revocable.</source>
        <target state="new">No access policy identifier is specified, making tokens non-revocable.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseContainerLevelAccessPolicyMessage">
        <source>Consider using Azure's role-based access control instead of a Shared Access Signature (SAS) if possible. If you still need to use a SAS, use a container-level access policy when creating a SAS</source>
        <target state="new">Consider using Azure's role-based access control instead of a Shared Access Signature (SAS) if possible. If you still need to use a SAS, use a container-level access policy when creating a SAS</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRSAWithSufficientKeySize">
        <source>Use Rivest–Shamir–Adleman (RSA) Algorithm With Sufficient Key Size</source>
        <target state="new">Use Rivest–Shamir–Adleman (RSA) Algorithm With Sufficient Key Size</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRSAWithSufficientKeySizeDescription">
        <source>Encryption algorithms are vulnerable to brute force attacks when too small a key size is used.</source>
        <target state="new">Encryption algorithms are vulnerable to brute force attacks when too small a key size is used.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRSAWithSufficientKeySizeMessage">
        <source>Asymmetric encryption algorithm {0}'s key size is less than 2048. Switch to an RSA with at least 2048 key size, ECDH or ECDSA algorithm instead.</source>
        <target state="new">Asymmetric encryption algorithm {0}'s key size is less than 2048. Switch to an RSA with at least 2048 key size, ECDH or ECDSA algorithm instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSecureCookiesASPNetCoreDescription">
        <source>Applications available over HTTPS must use secure cookies.</source>
        <target state="new">Applications available over HTTPS must use secure cookies.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSharedAccessProtocolHttpsOnly">
        <source>Use SharedAccessProtocol HttpsOnly</source>
        <target state="translated">Użyj SharedAccessProtocol HttpsOnly</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSharedAccessProtocolHttpsOnlyDescription">
        <source>HTTPS encrypts network traffic. Use HttpsOnly, rather than HttpOrHttps, to ensure network traffic is always encrypted to help prevent disclosure of sensitive data.</source>
        <target state="translated">Protokół HTTPS szyfruje ruch sieciowy. Użyj HttpsOnly, a nie HttpOrHttps, aby zapewnić, że ruch sieciowy jest zawsze szyfrowany, aby zapobiec ujawnieniu poufnych danych.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSharedAccessProtocolHttpsOnlyMessage">
        <source>Consider using Azure's role-based access control instead of a Shared Access Signature (SAS) if possible. If you still need to use a SAS, specify SharedAccessProtocol.HttpsOnly</source>
        <target state="translated">Jeśli to możliwe, rozważ użycie kontroli dostępu opartej na rolach platformy Azure, a nie do udostępnionej sygnatury dostępu (SAS). Jeśli nadal potrzebujesz użyć SKOJARZEŃ zabezpieczeń, określ SharedAccessProtocol. HttpsOnly</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderDescription">
        <source>Processing XML from untrusted data may load dangerous external references, which should be restricted by using an XmlReader with a secure resolver or with DTD processing disabled.</source>
        <target state="translated">Przetwarzanie pliku XML na podstawie niezaufanych danych może spowodować załadowanie niebezpiecznych odwołań zewnętrznych, które powinny zostać ograniczone za pomocą czytnika XmlReader z bezpiecznym programem rozpoznawania nazw lub wyłączonym przetwarzaniem elementów DTD.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDataSetReadXml">
        <source>Use XmlReader For DataSet Read Xml</source>
        <target state="translated">Użyj czytnika XmlReader na potrzeby pliku XML odczytu zestawu danych</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDeserialize">
        <source>Use XmlReader For Deserialize</source>
        <target state="translated">Użyj czytnika XmlReader do deserializacji</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForSchemaRead">
        <source>Use XmlReader For Schema Read</source>
        <target state="translated">Użyj czytnika XmlReader do odczytu schematu</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForValidatingReader">
        <source>Use XmlReader For Validating Reader</source>
        <target state="translated">Użyj czytnika XmlReader do weryfikacji czytnika</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForXPathDocument">
        <source>Use XmlReader For XPathDocument</source>
        <target state="translated">Użyj czytnika XmlReader na potrzeby elementu XPathDocument</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderMessage">
        <source>This overload of the {0}.{1} method is potentially unsafe, use an overload that takes a XmlReader instance instead</source>
        <target state="translated">Przeciążenie metody {0}.{1} jest potencjalnie niebezpieczne. Zamiast tego użyj przeciążenia przyjmującego wystąpienie czytnika XmlReader</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="tr" original="../SystemSecurityCryptographyResources.resx">
    <body>
      <trans-unit id="ApprovedCipherMode">
        <source>Do Not Use Unsafe Cipher Modes</source>
        <target state="translated">Güvenli olmayan şifreleme modlarını kullanmayın</target>
        <note />
      </trans-unit>
      <trans-unit id="ApprovedCipherModeDescription">
        <source>These modes are vulnerable to attacks. Use only approved modes (CBC, CTS).</source>
        <target state="translated">Bu modlar saldırılara açıktır. Yalnızca onaylı modları (CBC, CTS) kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="ApprovedCipherModeMessage">
        <source>It uses an unsafe Cipher Mode {0}</source>
        <target state="translated">Güvenli olmayan {0} Şifreleme Modunu kullanıyor</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyInstallRootCert">
        <source>Do Not Add Certificates To Root Store</source>
        <target state="translated">Sertifikaları Kök Depoya Ekleme</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyInstallRootCertMessage">
        <source>Adding certificates to the operating system's trusted root certificates increases the risk of incorrectly authenticating an illegitimate certificate</source>
        <target state="translated">Sertifikaların, işletim sisteminin güvenilen kök sertifikalarına eklenmesi, geçerli olmayan bir sertifikanın hatalı bir şekilde kimliğinin doğrulanması riskini artırır</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseSecureCookiesASPNetCore">
        <source>Use Secure Cookies In ASP.Net Core</source>
        <target state="translated">ASP.Net Core'da Güvenli Tanımlama Bilgileri Kullan</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseSecureCookiesASPNetCoreMessage">
        <source>Set CookieOptions.Secure = true when setting a cookie</source>
        <target state="translated">Tanımlama bilgisi ayarlarken CookieOptions.Secure = true olarak ayarlayın</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddArchiveItemPathToTheTargetFileSystemPath">
        <source>Do Not Add Archive Item's Path To The Target File System Path</source>
        <target state="new">Do Not Add Archive Item's Path To The Target File System Path</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddArchiveItemPathToTheTargetFileSystemPathDescription">
        <source>When extracting files from an archive and using the archive item's path, check if the path is safe. Archive path can be relative and can lead to file system access outside of the expected file system target path, leading to malicious config changes and remote code execution via lay-and-wait technique.</source>
        <target state="new">When extracting files from an archive and using the archive item's path, check if the path is safe. Archive path can be relative and can lead to file system access outside of the expected file system target path, leading to malicious config changes and remote code execution via lay-and-wait technique.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddArchiveItemPathToTheTargetFileSystemPathMessage">
        <source>When creating path for '{0} in method {1}' from relative archive item path to extract file and the source is an untrusted zip archive, make sure to sanitize relative archive item path '{2} in method {3}'</source>
        <target state="new">When creating path for '{0} in method {1}' from relative archive item path to extract file and the source is an untrusted zip archive, make sure to sanitize relative archive item path '{2} in method {3}'</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseWeakKDFInsufficientIterationCount">
        <source>Do Not Use Weak Key Derivation Function With Insufficient Iteration Count</source>
        <target state="new">Do Not Use Weak Key Derivation Function With Insufficient Iteration Count</target>
        <note />
      </trans-unit>
      <trans-unit id="DefinitelyUseWeakKDFInsufficientIterationCountMessage">
        <source>Use at least {0} iterations when deriving a cryptographic key from a password. By default, Rfc2898DeriveByte's IterationCount is only 1000</source>
        <target state="new">Use at least {0} iterations when deriving a cryptographic key from a password. By default, Rfc2898DeriveByte's IterationCount is only 1000</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddSchemaByURL">
        <source>Do Not Add Schema By URL</source>
        <target state="translated">URL'ye Göre Şema Eklemeyin</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddSchemaByURLDescription">
        <source>This overload of XmlSchemaCollection.Add method internally enables DTD processing on the XML reader instance used, and uses UrlResolver for resolving external XML entities. The outcome is information disclosure. Content from file system or network shares for the machine processing the XML can be exposed to attacker. In addition, an attacker can use this as a DoS vector.</source>
        <target state="translated">XmlSchemaCollection.Add metodunun bu aşırı yüklemesi, kullanılan XML okuyucu örneğinde dahili olarak DTD işleme sağlar ve dış XML varlıklarını çözümlemek için UrlResolver kullanır. Bunun sonucunda bilgilerin açığa çıkması durumu ortaya çıkar. Dosya sistemindeki içerikler veya XML'yi işleyen makinenin ağ paylaşımları saldırgana açılabilir. Buna ek olarak, bir saldırgan bunu DoS vektörü olarak kullanabilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotAddSchemaByURLMessage">
        <source>This overload of the Add method is potentially unsafe because it may resolve dangerous external references</source>
        <target state="translated">Tehlikeli dış başvuruları çözümleyebileceğinden Add metodunun bu aşırı yüklemesi güvenli olmayabilir</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallDangerousMethodsInDeserialization">
        <source>Do Not Call Dangerous Methods In Deserialization</source>
        <target state="translated">Seri Durumdan Çıkarırken Tehlikeli Metotlar Çağırma</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallDangerousMethodsInDeserializationDescription">
        <source>Insecure Deserialization is a vulnerability which occurs when untrusted data is used to abuse the logic of an application, inflict a Denial-of-Service (DoS) attack, or even execute arbitrary code upon it being deserialized. It’s frequently possible for malicious users to abuse these deserialization features when the application is deserializing untrusted data which is under their control. Specifically, invoke dangerous methods in the process of deserialization. Successful insecure deserialization attacks could allow an attacker to carry out attacks such as DoS attacks, authentication bypasses, and remote code execution.</source>
        <target state="translated">Güvenli Olmayan Seri Durumdan Çıkarma, güvenilmeyen verilerin bir uygulamanın mantığını kötüye kullanmak, bir Hizmet Reddi (DoS) saldırısı gerçekleştirmek veya seri durumdan çıkarıldığında rastgele kod yürütmek için kullanılması durumunda oluşan bir güvenlik açığıdır. Kötü amaçlı kullanıcıların uygulama kendi denetimlerindeki güvenilmeyen verileri seri durumdan çıkarırken bu seri durumdan çıkarma özelliklerini kötüye kullanması mümkündür. Özellikle, seri durumdan çıkarma işleminde tehlikeli yöntemler çağrılabilir. Başarılı güvenli olmayan seri durumdan çıkarma salgırıları, saldırganların DoS saldırıları gerçekleştirmesine, kimlik doğrulamasını atlamasına ve uzaktan kod yürütmesine olanak sağlar.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallDangerousMethodsInDeserializationMessage">
        <source>When deserializing an instance of class {0}, method {1} can call dangerous method {2}.</source>
        <target state="translated">{0} sınıfının bir örneği seri durumdan çıkarılırken, {1} metodu tehlikeli {2} metodunu çağırabilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableCertificateValidation">
        <source>Do Not Disable Certificate Validation</source>
        <target state="translated">Sertifika Doğrulamasını Devre Dışı Bırakma</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableCertificateValidationDescription">
        <source>A certificate can help authenticate the identity of the server. Clients should validate the server certificate to ensure requests are sent to the intended server. If the ServerCertificateValidationCallback always returns 'true', any certificate will pass validation.</source>
        <target state="translated">Bir sertifika sunucunun kimliğini doğrulamaya yardımcı olabilir. İstemciler, isteklerin doğru sunucuya gönderildiğinden emin olmak için sunucu sertifikasını doğrulamalıdır. ServerCertificateValidationCallback her zaman 'true' döndürüyorsa, tüm sertifikalar doğrulamayı geçer.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableCertificateValidationMessage">
        <source>The ServerCertificateValidationCallback is set to a function that accepts any server certificate, by always returning true. Ensure that server certificates are validated to verify the identity of the server receiving requests.</source>
        <target state="translated">ServerCertificateValidationCallback, her zaman true döndürerek tüm sunucu sertifikatarını kabul eden bir işleve ayarlanmış. Sunucu sertifikalarının istekleri alan sunucunun kimliğini doğrulamak için doğrulandığından emin olun.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableHTTPHeaderChecking">
        <source>Do Not Disable HTTP Header Checking</source>
        <target state="translated">HTTP Üst Bilgisi Denetlemeyi Devre Dışı Bırakmayın</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableHTTPHeaderCheckingDescription">
        <source>HTTP header checking enables encoding of the carriage return and newline characters, \r and \n, that are found in response headers. This encoding can help to avoid injection attacks that exploit an application that echoes untrusted data contained by the header.</source>
        <target state="translated">HTTP üst bilgisi denetleme, yanıt üst bilgilerinde bulunan satır başı ve yeni satır karakterlerinin (\r ve \n) kodlamasını sağlar. Bu kodlama, üst bilginin içerdiği güvenilmeyen verileri yansıtan bi uygulamanın açıklarından yararlanan ekleme saldırılarını önlemeye yardımcı olabilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableHTTPHeaderCheckingMessage">
        <source>Do not disable HTTP header checking</source>
        <target state="translated">HTTP üst bilgisi denetlemeyi devre dışı bırakmayın</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableRequestValidation">
        <source>Do Not Disable Request Validation</source>
        <target state="translated">İstek Doğrulamayı Devre Dışı Bırakmayın</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableRequestValidationDescription">
        <source>Request validation is a feature in ASP.NET that examines HTTP requests and determines whether they contain potentially dangerous content. This check adds protection from markup or code in the URL query string, cookies, or posted form values that might have been added for malicious purposes. So, it is generally desirable and should be left enabled for defense in depth.</source>
        <target state="translated">İstek doğrulama, HTTP isteklerini inceleyen ve bu isteklerin potansiyel olarak tehlikeli içeriğe sahip olup olmadığını belirleyen bir ASP.NET özelliğidir. Bu denetleme, URL sorgu dizesi, tanımlama bilgileri veya kötü amaçlarla eklenmiş olabilecek gönderilmiş form değerlerindeki işaretleme veya kodlara karşı koruma sağlar. Dolayısıyla bu genellikle istenen bir özelliktir ve kapsamlı savunma için etkin olarak bırakılmalıdır.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableRequestValidationMessage">
        <source>{0} has request validation disabled</source>
        <target state="translated">{0} öğesinde istek doğrulama devre dışı</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableSchUseStrongCrypto">
        <source>Do Not Disable SChannel Use of Strong Crypto</source>
        <target state="translated">Güçlü Şifrelemenin Schannel Kullanımını Devre Dışı Bırakma</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableSchUseStrongCryptoDescription">
        <source>Starting with the .NET Framework 4.6, the System.Net.ServicePointManager and System.Net.Security.SslStream classes are recommeded to use new protocols. The old ones have protocol weaknesses and are not supported. Setting Switch.System.Net.DontEnableSchUseStrongCrypto with true will use the old weak crypto check and opt out of the protocol migration.</source>
        <target state="translated">.NET Framework 4.6'dan başlayarak, System.Net.ServicePointManager ve System.Net.Security.SslStream sınıflarının yeni protokoller kullanması önerilir. Eski sınıfların protokol zayıflıkları vardır ve bunlar desteklenmez. Switch.System.Net.DontEnableSchUseStrongCrypto öğesini true olarak ayarlamak eski zayıf şifreleme denetimini kullanır ve protokol geçişini geri çevirir.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotDisableSchUseStrongCryptoMessage">
        <source>{0} disables TLS 1.2 and enables SSLv3</source>
        <target state="translated">{0}, TLS 1.2'yi devre dışı bırakır ve SSLv3'ü etkinleştirir</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInstallRootCertDescription">
        <source>By default, the Trusted Root Certification Authorities certificate store is configured with a set of public CAs that has met the requirements of the Microsoft Root Certificate Program. Since all trusted root CAs can issue certificates for any domain, an attacker can pick a weak or coercible CA that you install by yourself to target for an attack – and a single vulnerable, malicious or coercible CA undermines the security of the entire system. To make matters worse, these attacks can go unnoticed quite easily.</source>
        <target state="translated">Varsayılan olarak, Güvenilen Kök Sertifika Yetkilileri sertifika deposu, Microsoft Kök Sertifika Programı gereksinimlerini karşılayan bir genel CA kümesiyle yapılandırılır. Tüm güvenilen kök CA'lar herhangi bir etki alanı için sertifika verebileceği için, bir saldırgan kendiniz yüklediğiniz savunmasız veya zorlanabilir bir CA'yı saldırı için seçebilir ve tek bir zayıf, kötü amaçlı ya da zorlanabilir CA tüm sistemin güvenliğini tehlikeye atabilir. Daha da kötüsü, bu saldırıların gözden kaçırılması oldukça kolaydır.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotReferSelfInSerializableClass">
        <source>Do Not Refer Self In Serializable Class</source>
        <target state="translated">Serileştirilebilir Sınıfta Kendisine Başvurma</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotReferSelfInSerializableClassDescription">
        <source>This can allow an attacker to DOS or exhaust the memory of the process.</source>
        <target state="translated">Bu, bir saldırganın DOS saldırısı yapmasına veya işlemin belleğini tüketmesine yol açabilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotReferSelfInSerializableClassMessage">
        <source>{0} participates in a potential reference cycle</source>
        <target state="translated">{0}, olası bir başvuru döngüsünde yer alıyor</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotSerializeTypesWithPointerFields">
        <source>Do Not Serialize Types With Pointer Fields</source>
        <target state="translated">İşaretçi Alanlara Sahip Türleri Serileştirmeyin</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotSerializeTypesWithPointerFieldsDescription">
        <source>Pointers are not "type safe" in the sense that you cannot guarantee the correctness of the memory they point at. So, serializing types with pointer fields is dangerous, as it may allow an attacker to control the pointer.</source>
        <target state="translated">İşaretçiler, işaret ettikleri belleğin doğruluğunu garanti edemediğinden "tür kullanımı uyumlu" değildir. Bu nedenle, bir saldırganın işaretçiyi kontrol etmesine olanak sağlayabileceğinden işaretçi alanlara sahip türleri serileştirmek tehlikelidir.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotSerializeTypesWithPointerFieldsMessage">
        <source>Pointer field {0} on serializable type.</source>
        <target state="translated">Serileştirilebilir türde {0} işaretçi alanı.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseAccountSAS">
        <source>Do Not Use Account Shared Access Signature</source>
        <target state="translated">Hesabın Paylaşılan Erişim İmzasını Kullanmayın</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseAccountSASDescription">
        <source>Shared Access Signatures(SAS) are a vital part of the security model for any application using Azure Storage, they should provide limited and safe permissions to your storage account to clients that don't have the account key. All of the operations available via a service SAS are also available via an account SAS, that is, account SAS is too powerful. So it is recommended to use Service SAS to delegate access more carefully.</source>
        <target state="translated">Paylaşılan Erişim İmzaları (SAS), Azure Depolama kullanan tüm uygulamalar için güvenlik modelinin önemli bir bölümüdür, hesap anahtarı olmayan istemciler için depolama hesabınıza yönelik sınırlı ve güvenli izinler sağlar. Hizmet SAS'si üzerinden kullanılabilir olan işlemlerin tümü ayrıca, hesap SAS'sinin çok güçlü olması durumunda hesap SAS'si üzerinden de kullanılabilir. Bu nedenle daha dikkatli bir şekilde erişim vermek için Hizmet SAS'sini kullanmanız önerilir.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseAccountSASMessage">
        <source>Use Service SAS instead of Account SAS for fine grained access control and container-level access policy</source>
        <target state="translated">Ayrıntılı erişim denetimi ve kapsayıcı düzeyinde erişim ilkesi için Hesap SAS'si yerine Hizmet SAS'sini kullanın</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseBrokenCryptographicAlgorithms">
        <source>Do Not Use Broken Cryptographic Algorithms</source>
        <target state="translated">Bozuk Kriptografik Algoritmalar Kullanma</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseBrokenCryptographicAlgorithmsDescription">
        <source>An attack making it computationally feasible to break this algorithm exists. This allows attackers to break the cryptographic guarantees it is designed to provide. Depending on the type and application of this cryptographic algorithm, this may allow attackers to read enciphered messages, tamper with enciphered  messages, forge digital signatures, tamper with hashed content, or otherwise compromise any cryptosystem based on this algorithm. Replace encryption uses with the AES algorithm (AES-256, AES-192 and AES-128 are acceptable) with a key length greater than or equal to 128 bits. Replace hashing uses with a hashing function in the SHA-2 family, such as SHA512, SHA384, or SHA256. Replace digital signature uses with RSA with a key length greater than or equal to 2048-bits, or ECDSA with a key length greater than or equal to 256 bits.</source>
        <target state="translated">Bu algoritmayı bozmayı işlemsel olarak uygun hale getiren bir saldırı var. Bu, saldırganların sağlamak için tasarlanan kriptografik garantileri aşmasına olanak sağlar. Bu kriptografik algoritmanın türü ve uygulamasına bağlı olarak, bu saldırganların şifrelenmiş iletileri okumasına, şifrelenmiş iletilen üzerinde oynamasına, dijital imza sahteciliği yapmasına, karma içerik üzerinde oynamasına veya bu algoritmayı temel alan herhangi bir kriptosistemin güvenliğini bozmasına neden olabilir. AES algoritması (AES-256, AES-192 ve AES-128 kabul edilebilir) ile şifreleme kullanımlarını 128 bit veya daha büyük bir anahtar uzunluğuyla değiştirin. Karma kullanımlarını SHA512, SHA384 veya SHA256 gibi SHA-2 ailesindeki bir karma işleviyle değiştirin. RSA ile dijital imza kullanımlarını 2048 bit veya daha büyük bir anahtar uzunluğuyla veya ECDSA’yı 256 bit veya daha büyük bir anahtar uzunluğuyla değiştirin.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseBrokenCryptographicAlgorithmsMessage">
        <source>{0} uses a broken cryptographic algorithm {1}</source>
        <target state="translated">{0} bozuk {1} kriptografik algoritmasını kullanıyor</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDSA">
        <source>Do Not Use Digital Signature Algorithm (DSA)</source>
        <target state="translated">Dijital İmza Algoritması (DSA) Kullanma</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDSADescription">
        <source>DSA is too weak to use.</source>
        <target state="translated">DSA, kullanmak için çok zayıf.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDSAMessage">
        <source>Asymmetric encryption algorithm {0} is weak. Switch to an RSA with at least 2048 key size, ECDH or ECDSA algorithm instead</source>
        <target state="translated">Asimetrik şifreleme algoritması {0} zayıf. Bunun yerine en az 2048 anahtar boyutuna, ECDH veya ECDSA algoritmasına sahip bir RSA'ya geçiş yapın</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDeprecatedSecurityProtocols">
        <source>Do Not Use Deprecated Security Protocols</source>
        <target state="translated">Kullanım Dışı Güvenlik Protokollerini Kullanmayın</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDeprecatedSecurityProtocolsDescription">
        <source>Using a deprecated security protocol rather than the system default is risky.</source>
        <target state="translated">Sistem varsayılanı yerine bir kullanım dışı güvenlik protokolünü kullanmak risklidir.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseDeprecatedSecurityProtocolsMessage">
        <source>Hard-coded use of deprecated security protocol {0}</source>
        <target state="translated">Kullanım dışı {0} güvenlik protokolünün sabit kodlanmış kullanımı</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseInsecureRandomness">
        <source>Do Not Use Insecure Randomness</source>
        <target state="new">Do Not Use Insecure Randomness</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseInsecureRandomnessDescription">
        <source>Using a cryptographically weak pseudo-random number generator may allow an attacker to predict what sensitive value will be generated.</source>
        <target state="new">Using a cryptographically weak pseudo-random number generator may allow an attacker to predict what sensitive value will be generated.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseInsecureRandomnessMessage">
        <source>{0} is an insecure random number generator. Use cryptographically secure random number generators when randomness is required</source>
        <target state="new">{0} is an insecure random number generator. Use cryptographically secure random number generators when randomness is required</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseMD5">
        <source>Do not use insecure cryptographic algorithm MD5.</source>
        <target state="translated">Güvenli olmayan MD5 kriptografik algoritmasını kullanmayın.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseMD5Description">
        <source>This type implements MD5, a cryptographically insecure hashing function. Hash collisions are computationally feasible for the MD5 and HMACMD5 algorithms. Replace this usage with a SHA-2 family hash algorithm (SHA512, SHA384, SHA256).</source>
        <target state="translated">Bu tür, kriptografik olarak güvenli olmayan bir karma işlevi olan MD5 uygular. MD5 ve HMACMD5 algoritmaları için karma çakışmaları işlemsel olarak uygundur. Bu kullanımı bir SHA-2 aile karma algoritmasıyla (SHA512, SHA384, SHA256) değiştirin.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseObsoleteKDFAlgorithm">
        <source>Do not use obsolete key derivation function</source>
        <target state="translated">Artık kullanılmayan anahtar türetme işlevini kullanma</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseObsoleteKDFAlgorithmDescription">
        <source>Password-based key derivation should use PBKDF2 with SHA-2. Avoid using PasswordDeriveBytes since it generates a PBKDF1 key. Avoid using Rfc2898DeriveBytes.CryptDeriveKey since it doesn't use the iteration count or salt.</source>
        <target state="translated">Parola tabanlı anahtar türetme SHA-2 ile PBKDF2 kullanmalıdır. Bir PBKDF1 anahtarı ürettiğinden PasswordDeriveBytes kullanmaktan kaçının. Yineleme sayısı veya güvenlik dizisi kullanmadığından Rfc2898DeriveBytes.CryptDeriveKey kullanmaktan kaçının.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseObsoleteKDFAlgorithmMessage">
        <source>Call to obsolete key derivation function {0}.{1}</source>
        <target state="translated">Artık kullanılmayan {0}.{1} anahtar türetme işlevine çağrı</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSHA1">
        <source>Do not use insecure cryptographic algorithm SHA1.</source>
        <target state="translated">Güvenli olmayan SHA1 kriptografik algoritmasını kullanmayın.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseSHA1Description">
        <source>This type implements SHA1, a cryptographically insecure hashing function. Hash collisions are computationally feasible for the SHA-1 and SHA-0 algorithms. Replace this usage with a SHA-2 family hash algorithm (SHA512, SHA384, SHA256).</source>
        <target state="translated">Bu tür, kriptografik olarak güvenli olmayan bir karma işlevi olan SHA1 uygular. SHA-1 ve SHA-0 algoritmaları için karma çakışmaları işlemsel olarak uygundur. Bu kullanımı bir SHA-2 aile karma algoritmasıyla (SHA512, SHA384, SHA256) değiştirin.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakCryptographicAlgorithms">
        <source>Do Not Use Weak Cryptographic Algorithms</source>
        <target state="translated">Zayıf Kriptografik Algoritmalar Kullanma</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakCryptographicAlgorithmsDescription">
        <source>Cryptographic algorithms degrade over time as attacks become for advances to attacker get access to more computation. Depending on the type and application of this cryptographic algorithm, further degradation of the cryptographic strength of it may allow attackers to read enciphered messages, tamper with enciphered  messages, forge digital signatures, tamper with hashed content, or otherwise compromise any cryptosystem based on this algorithm. Replace encryption uses with the AES algorithm (AES-256, AES-192 and AES-128 are acceptable) with a key length greater than or equal to 128 bits. Replace hashing uses with a hashing function in the SHA-2 family, such as SHA-2 512, SHA-2 384, or SHA-2 256.</source>
        <target state="translated">Saldırgan daha fazla işlem erişimi elde ettikçe kriptografik algoritmalar zaman içinde zayıflar. Bu kriptografik algoritmanın türü ve uygulamasına bağlı olarak, kriptografik gücün daha da zayıflatılması saldırganların şifrelenmiş iletileri okumasına, şifrelenmiş iletilen üzerinde oynamasına, dijital imza sahteciliği yapmasına, karma içerik üzerinde oynamasına veya bu algoritmayı temel alan herhangi bir kriptosistemin güvenliğini bozmasına neden olabilir. AES algoritması (AES-256, AES-192 ve AES-128 kabul edilebilir) ile şifreleme kullanımlarını 128 bit veya daha büyük bir anahtar uzunluğuyla değiştirin. Karma kullanımlarını SHA-2 512, SHA-2 384 veya SHA-2 256 gibi SHA-2 ailesindeki bir karma işleviyle değiştirin.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakCryptographicAlgorithmsMessage">
        <source>{0} uses a weak cryptographic algorithm {1}</source>
        <target state="translated">{0} zayıf {1} kriptografik algoritmasını kullanıyor</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakKDFAlgorithm">
        <source>Do Not Use Weak Key Derivation Function Algorithm</source>
        <target state="translated">Zayıf Anahtar Türetme İşlevi Algoritmasını Kullanma</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakKDFAlgorithmDescription">
        <source>Some implementations of the Rfc2898DeriveBytes class allow for a hash algorithm to be specified in a constructor parameter or overwritten in the HashAlgorithm property. If a hash algorithm is specified, then it should be SHA-256 or higher.</source>
        <target state="translated">Rfc2898DeriveBytes sınıfının bazı uygulamaları, bir karma algoritması değerinin oluşturucu parametresinde belirtilmesine veya HashAlgorithm özelliğinde üzerine yazılmasına olanak sağlar. Bir karma algoritması belirtilirse SHA-256 veya üzeri olmalıdır.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakKDFAlgorithmMessage">
        <source>{0} created with a weak hash algorithm. Use SHA256, SHA384, or SHA512 to create a strong key from a password</source>
        <target state="translated">{0} zayıf bir karma algoritmasıyla oluşturuldu. Bir paroladan güçlü bir anahtar oluşturmak için SHA256, SHA384 veya SHA512 kullanın</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakKDFInsufficientIterationCountDescription">
        <source>When deriving cryptographic keys from user-provided inputs such as password, use sufficient iteration count (at least 100k).</source>
        <target state="new">When deriving cryptographic keys from user-provided inputs such as password, use sufficient iteration count (at least 100k).</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseXslTransform">
        <source>Do Not Use XslTransform</source>
        <target state="translated">XslTransform Kullanma</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseXslTransformMessage">
        <source>Do not use XslTransform. It does not restrict potentially dangerous external references.</source>
        <target state="translated">XslTransform kullanmayın. Tehlikeli olabilecek dış başvuruları kısıtlamaz.</target>
        <note />
      </trans-unit>
      <trans-unit id="HardCodedSecurityProtocolMessage">
        <source>Avoid hardcoding SecurityProtocolType {0}, and instead use SecurityProtocolType.SystemDefault to allow the operating system to choose the best Transport Layer Security protocol to use.</source>
        <target state="new">Avoid hardcoding SecurityProtocolType {0}, and instead use SecurityProtocolType.SystemDefault to allow the operating system to choose the best Transport Layer Security protocol to use.</target>
        <note />
      </trans-unit>
      <trans-unit id="HardCodedSecurityProtocolTitle">
        <source>Avoid hardcoding SecurityProtocolType value</source>
        <target state="new">Avoid hardcoding SecurityProtocolType value</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeInstallRootCert">
        <source>Ensure Certificates Are Not Added To Root Store</source>
        <target state="translated">Sertifikaların Kök Depoya Eklenmediğinden Emin Olun</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeInstallRootCertMessage">
        <source>Adding certificates to the operating system's trusted root certificates is insecure. Ensure that the target store is not root store.</source>
        <target state="translated">Sertifikaların, işletim sisteminin güvenilen kök sertifikalarına eklenmesi güvenli değildir. Hedef deponun kök depo olmadığından emin olun.</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseSecureCookiesASPNetCore">
        <source>Ensure Use Secure Cookies In ASP.Net Core</source>
        <target state="translated">ASP.Net Core içinde Güvenli Tanımlama Bilgileri Kullanılmasını Sağla</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseSecureCookiesASPNetCoreMessage">
        <source>Ensure that CookieOptions.Secure = true when setting a cookie</source>
        <target state="translated">Tanımlama bilgisi ayarlanırken CookieOptions.Secure = true olduğundan emin olun</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseWeakKDFInsufficientIterationCount">
        <source>Ensure Sufficient Iteration Count When Using Weak Key Derivation Function</source>
        <target state="new">Ensure Sufficient Iteration Count When Using Weak Key Derivation Function</target>
        <note />
      </trans-unit>
      <trans-unit id="MaybeUseWeakKDFInsufficientIterationCountMessage">
        <source>Ensure that the iteration count is at least {0} when deriving a cryptographic key from a password. By default, Rfc2898DeriveByte's IterationCount is only 1000</source>
        <target state="new">Ensure that the iteration count is at least {0} when deriving a cryptographic key from a password. By default, Rfc2898DeriveByte's IterationCount is only 1000</target>
        <note />
      </trans-unit>
      <trans-unit id="SetViewStateUserKey">
        <source>Set ViewStateUserKey For Classes Derived From Page</source>
        <target state="translated">Sayfadan Türetilen Sınıflar için ViewStateUserKey Ayarlayın</target>
        <note />
      </trans-unit>
      <trans-unit id="SetViewStateUserKeyDescription">
        <source>Setting the ViewStateUserKey property can help you prevent attacks on your application by allowing you to assign an identifier to the view-state variable for individual users so that they cannot use the variable to generate an attack. Otherwise, there will be cross-site request forgery vulnerabilities.</source>
        <target state="translated">ViewStateUserKey özelliğini ayarlamak, görüntüleme durumu değişkenine tanımlayıcı atayarak kullanıcıların bu değişkeni uygulamanıza saldırı oluşturmak üzere kullanmasını önlemeye yardımcı olabilir. Aksi halde siteler arası istek sahteciliği güvenlik açıkları meydana gelir.</target>
        <note />
      </trans-unit>
      <trans-unit id="SetViewStateUserKeyMessage">
        <source>The class {0} derived from System.Web.UI.Page does not set the ViewStateUserKey property in the OnInit method or Page_Init method</source>
        <target state="needs-review-translation">Sayfanın {0} alt sınıfı OnInit metodunda ViewStateUserKey özelliğini ayarlamıyor</target>
        <note />
      </trans-unit>
      <trans-unit id="UseContainerLevelAccessPolicy">
        <source>Use Container Level Access Policy</source>
        <target state="translated">Kapsayıcı Düzeyinde Erişim İlkesi Kullan</target>
        <note />
      </trans-unit>
      <trans-unit id="UseContainerLevelAccessPolicyDescription">
        <source>No access policy identifier is specified, making tokens non-revocable.</source>
        <target state="translated">Erişim ilkesi tanımlayıcısı belirtilmediğinden belirteçler iptal edilemez.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseContainerLevelAccessPolicyMessage">
        <source>Consider using Azure's role-based access control instead of a Shared Access Signature (SAS) if possible. If you still need to use a SAS, use a container-level access policy when creating a SAS</source>
        <target state="translated">Mümkünse Paylaşılan Erişim İmzası (SAS) yerine Azure'un rol tabanlı erişim denetimini kullanmayı düşünün. Yine de SAS kullanmanız gerekiyorsa, SAS oluştururken kapsayıcı düzeyinde bir erişim ilkesi kullanın</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRSAWithSufficientKeySize">
        <source>Use Rivest–Shamir–Adleman (RSA) Algorithm With Sufficient Key Size</source>
        <target state="translated">Yeterli Anahtar Boyutuna Sahip Rivest–Shamir–Adleman (RSA) Algoritmasını Kullan</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRSAWithSufficientKeySizeDescription">
        <source>Encryption algorithms are vulnerable to brute force attacks when too small a key size is used.</source>
        <target state="translated">Çok küçük boyutlu bir anahtar kullanıldığında şifreleme algoritmaları deneme yanılma saldırılarına karşı savunmasız durumda kalır.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRSAWithSufficientKeySizeMessage">
        <source>Asymmetric encryption algorithm {0}'s key size is less than 2048. Switch to an RSA with at least 2048 key size, ECDH or ECDSA algorithm instead.</source>
        <target state="translated">Asimetrik şifreleme algoritması {0} anahtar boyutu 2048'den az. Bunun yerine en az 2048 anahtar boyutuna, ECDH veya ECDSA algoritmasına sahip bir RSA'ya geçiş yapın.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSecureCookiesASPNetCoreDescription">
        <source>Applications available over HTTPS must use secure cookies.</source>
        <target state="translated">HTTPS üzerinden kullanılabilen uygulamalar güvenli tanımlama bilgileri kullanmalıdır.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSharedAccessProtocolHttpsOnly">
        <source>Use SharedAccessProtocol HttpsOnly</source>
        <target state="translated">SharedAccessProtocol HttpsOnly Kullan</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSharedAccessProtocolHttpsOnlyDescription">
        <source>HTTPS encrypts network traffic. Use HttpsOnly, rather than HttpOrHttps, to ensure network traffic is always encrypted to help prevent disclosure of sensitive data.</source>
        <target state="translated">HTTPS ağ trafiğini şifreler. Hassas verilerin açıklanmasını önlemeye yardımcı olmak için, ağ trafiğinin her zaman şifrelenmesini sağlamak amacıyla HttpOrHttps yerine HttpsOnly kullanın.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSharedAccessProtocolHttpsOnlyMessage">
        <source>Consider using Azure's role-based access control instead of a Shared Access Signature (SAS) if possible. If you still need to use a SAS, specify SharedAccessProtocol.HttpsOnly</source>
        <target state="translated">Mümkünse Paylaşılan Erişim İmzası (SAS) yerine Azure'un rol tabanlı erişim denetimini kullanmayı düşünün. Yine de SAS kullanmanız gerekiyorsa, SharedAccessProtocol.HttpsOnly belirtin</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderDescription">
        <source>Processing XML from untrusted data may load dangerous external references, which should be restricted by using an XmlReader with a secure resolver or with DTD processing disabled.</source>
        <target state="translated">Güvenilmeyen verilerden XML işlenirse tehlikeli dış başvurular yüklenebilir. Bunun, güvenli bir çözümleyicisi olan bir XmlReader kullanılarak veya DTD işleme devre dışı bırakılarak kısıtlanması gerekir.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDataSetReadXml">
        <source>Use XmlReader For DataSet Read Xml</source>
        <target state="translated">DataSet Xml'i Okuma için XmlReader kullan</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDeserialize">
        <source>Use XmlReader For Deserialize</source>
        <target state="translated">Seri Halden Çıkarma için XmlReader kullan</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForSchemaRead">
        <source>Use XmlReader For Schema Read</source>
        <target state="translated">Şema Okuma için XmlReader kullan</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForValidatingReader">
        <source>Use XmlReader For Validating Reader</source>
        <target state="translated">Okuyucuyu Doğrulamak için XmlReader kullan</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForXPathDocument">
        <source>Use XmlReader For XPathDocument</source>
        <target state="translated">XPathDocument için XmlReader kullan</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderMessage">
        <source>This overload of the {0}.{1} method is potentially unsafe, use an overload that takes a XmlReader instance instead</source>
        <target state="translated">{0}.{1} yönteminin bu aşırı yüklemesi güvenli olmayabilir. Bunun yerine bir XmlReader örneğini alan bir aşırı yükleme kullanın</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
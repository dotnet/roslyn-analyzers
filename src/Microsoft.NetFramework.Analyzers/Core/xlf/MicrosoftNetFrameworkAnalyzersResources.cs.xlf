<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="cs" original="../MicrosoftNetFrameworkAnalyzersResources.resx">
    <body>
      <trans-unit id="SpecifyMessageBoxOptionsTitle">
        <source>Specify MessageBoxOptions</source>
        <target state="translated">Zadejte MessageBoxOptions</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMessageBoxOptionsDescription">
        <source>To correctly display a message box for cultures that use a right-to-left reading order, the RightAlign and RtlReading members of the MessageBoxOptions enumeration must be passed to the Show method.</source>
        <target state="translated">Aby se okno se zprávou zobrazovalo správně pro jazykové verze, jejichž text se čte zprava doleva, musí se metodě Show předat členy RightAlign a RtlReading výčtu MessageBoxOptions.</target>
        <note />
      </trans-unit>
      <trans-unit id="SpecifyMessageBoxOptionsMessage">
        <source>Specify MessageBoxOptions</source>
        <target state="translated">Zadejte MessageBoxOptions</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateAcceleratorsTitle">
        <source>Avoid duplicate accelerators</source>
        <target state="translated">Vyhněte se duplicitním klávesovým zkratkám</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateAcceleratorsDescription">
        <source>An access key, also known as an accelerator, enables keyboard access to a control by using the ALT key. When multiple controls have duplicate access keys, the behavior of the access key is not well defined.</source>
        <target state="translated">Přístupová klávesa, které se říká taky klávesová zkratka, umožňuje používat ovládací prvek pomocí klávesy ALT. Když několik ovládacích prvků má duplicitní klávesové zkratky, chování přístupové klávesy není dostatečně definované.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidDuplicateAcceleratorsMessage">
        <source>Avoid duplicate accelerators</source>
        <target state="translated">Vyhněte se duplicitním klávesovým zkratkám</target>
        <note />
      </trans-unit>
      <trans-unit id="SetLocaleForDataTypesTitle">
        <source>Set locale for data types</source>
        <target state="translated">Nastavte národní prostředí pro datové typy</target>
        <note />
      </trans-unit>
      <trans-unit id="SetLocaleForDataTypesDescription">
        <source>The locale determines culture-specific presentation elements for data, such as formatting that is used for numeric values, currency symbols, and sort order. When you create a DataTable or DataSet, you should explicitly set the locale.</source>
        <target state="translated">Národní prostředí určuje elementy prezentace dat specifické pro určitou jazykovou verzi, třeba formátování číselných hodnot, symboly měn a pořadí řazení. Když vytváříte DataTable nebo DataSet, měli byste národní prostředí zadat explicitně.</target>
        <note />
      </trans-unit>
      <trans-unit id="SetLocaleForDataTypesMessage">
        <source>Set locale for data types</source>
        <target state="translated">Nastavte národní prostředí pro datové typy</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkServicedComponentsWithWebMethodTitle">
        <source>Do not mark serviced components with WebMethod</source>
        <target state="translated">Neoznačujte komponenty služeb jako WebMethod</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkServicedComponentsWithWebMethodDescription">
        <source>A method in a type that inherits from System.EnterpriseServices.ServicedComponent is marked by using System.Web.Services.WebMethodAttribute. Because WebMethodAttribute and a ServicedComponent method have conflicting behavior and requirements for context and transaction flow, the behavior of the method will be incorrect in some scenarios.</source>
        <target state="translated">Metoda v typu, která dědí ze System.EnterpriseServices.ServicedComponent, se označuje atributem System.Web.Services.WebMethodAttribute. Vzhledem k tomu, že WebMethodAttribute a ServicedComponent mají konfliktní chování a požadavky na kontext a tok transakcí, metoda se v některých případech nebude chovat správně.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMarkServicedComponentsWithWebMethodMessage">
        <source>Do not mark serviced components with WebMethod</source>
        <target state="translated">Neoznačujte komponenty služeb jako WebMethod</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationConstructorsTitle">
        <source>Implement serialization constructors</source>
        <target state="translated">Implementujte serializační konstruktory</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationConstructorsDescription">
        <source>To fix a violation of this rule, implement the serialization constructor. For a sealed class, make the constructor private; otherwise, make it protected.</source>
        <target state="translated">Pokud chcete napravit porušení tohoto pravidla, implementujte serializační konstruktor. U zapečetěných tříd vytvořte privátní konstruktor, u ostatních pak chráněný.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationConstructorsMessageCreateMagicConstructor">
        <source>Add a constructor to {0} with the following signature: 'protected {0}(SerializationInfo info, StreamingContext context)'.</source>
        <target state="translated">Přidejte do {0} konstruktor s následující signaturou: protected {0}(SerializationInfo info, StreamingContext context)</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationConstructorsMessageMakeUnsealedMagicConstructorFamily">
        <source>Declare the serialization constructor of {0}, an unsealed type, as protected.</source>
        <target state="translated">Pro nezapečetěný typ {0} deklarujte serializační konstruktor jako chráněný.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationConstructorsMessageMakeSealedMagicConstructorPrivate">
        <source>Declare the serialization constructor of {0}, a sealed type, as private.</source>
        <target state="translated">Pro zapečetěný typ {0} deklarujte serializační konstruktor jako privátní.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationConstructorsCodeActionTitle">
        <source>Implement Serialization constructor</source>
        <target state="translated">Implementujte serializační konstruktor</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkWindowsFormsEntryPointsWithStaThreadTitle">
        <source>Mark Windows Forms entry points with STAThread</source>
        <target state="translated">Označte vstupní body Windows Forms jako STAThread</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkWindowsFormsEntryPointsWithStaThreadDescription">
        <source>STAThreadAttribute indicates that the COM threading model for the application is a single-threaded apartment. This attribute must be present on the entry point of any application that uses Windows Forms; if it is omitted, the Windows components might not work correctly.</source>
        <target state="translated">STAThreadAttribute označuje, že podprocesový model COM pro aplikaci je STA (single-threaded apartment). Tento atribut se musí zadat na vstupní bod každé aplikace, která používá Windows Forms. Pokud se vynechá, komponenty Windows nemusí fungovat správně.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkWindowsFormsEntryPointsWithStaThreadMessage">
        <source>Mark Windows Forms entry points with STAThread</source>
        <target state="translated">Označte vstupní body Windows Forms jako STAThread</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAllNonSerializableFieldsTitle">
        <source>Mark all non-serializable fields</source>
        <target state="translated">Označte všechna neserializovatelná pole</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAllNonSerializableFieldsDescription">
        <source>An instance field of a type that is not serializable is declared in a type that is serializable.</source>
        <target state="translated">V typu, který se dá serializovat, se deklarovala instance pole typu, který serializovatelný není.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkAllNonSerializableFieldsMessage">
        <source>Field {0} is a member of type {1} which is serializable but is of type {2} which is not serializable</source>
        <target state="translated">Pole {0} je člen typu {1}, který se dá serializovat, ale samo je typu {2}, který se serializovat nedá.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallBaseClassMethodsOnISerializableTypesTitle">
        <source>Call base class methods on ISerializable types</source>
        <target state="translated">Zavolejte metody základních tříd pro typy ISerializable</target>
        <note />
      </trans-unit>
      <trans-unit id="CallBaseClassMethodsOnISerializableTypesDescription">
        <source>To fix a violation of this rule, call the base type GetObjectData method or serialization constructor from the corresponding derived type method or constructor.</source>
        <target state="translated">Pokud chcete napravit porušení tohoto pravidla, zavolejte metodu GetObjectData základního typu nebo serializační konstruktor z metody odpovídajícího odvozeného typu nebo konstruktoru.</target>
        <note />
      </trans-unit>
      <trans-unit id="CallBaseClassMethodsOnISerializableTypesMessage">
        <source>Call base class methods on ISerializable types</source>
        <target state="translated">Zavolejte metody základních tříd pro typy ISerializable</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkISerializableTypesWithSerializableTitle">
        <source>Mark ISerializable types with serializable</source>
        <target state="translated">Označte typy ISerializable jako serializable</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkISerializableTypesWithSerializableDescription">
        <source>To be recognized by the common language runtime as serializable, types must be marked by using the SerializableAttribute attribute even when the type uses a custom serialization routine through implementation of the ISerializable interface.</source>
        <target state="translated">Aby mohl modul CLR (Common Language Runtime) rozpoznat typy jako serializovatelné, musí se označit atributem SerializableAttribute i v případě, že typ používá vlastní rutinu serializace prostřednictvím implementace rozhraní ISerializable.</target>
        <note />
      </trans-unit>
      <trans-unit id="MarkISerializableTypesWithSerializableMessage">
        <source>Add [Serializable] to {0} as this type implements ISerializable</source>
        <target state="translated">Přidejte [Serializable] k {0}, protože tento typ implementuje ISerializable</target>
        <note />
      </trans-unit>
      <trans-unit id="AddSerializableAttributeCodeActionTitle">
        <source>Add Serializable attribute</source>
        <target state="translated">Přidejte atribut Serializable</target>
        <note />
      </trans-unit>
      <trans-unit id="AddNonSerializedAttributeCodeActionTitle">
        <source>Add the 'NonSerialized' attribute to this field.</source>
        <target state="translated">Přidejte k tomuto poli atribut NonSerialized.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyTitle">
        <source>Implement serialization methods correctly</source>
        <target state="translated">Implementujte správně serializační metody</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyDescription">
        <source>A method that handles a serialization event does not have the correct signature, return type, or visibility.</source>
        <target state="translated">Metoda, která zpracovává událost serializace, nemá správnou signaturu, návratový typ nebo viditelnost.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyMessageVisibility">
        <source>Because {0} is marked with OnSerializing, OnSerialized, OnDeserializing, or OnDeserialized, change its accessibility to private.</source>
        <target state="translated">Vzhledem k tomu, že metoda {0} je označená jako OnSerializing, OnSerialized, OnDeserializing nebo OnDeserialized, změňte její přístupnost na privátní.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyMessageReturnType">
        <source>Because {0} is marked with OnSerializing, OnSerialized, OnDeserializing, or OnDeserialized, change its return type from {1} to void (Sub in Visual Basic).</source>
        <target state="translated">Vzhledem k tomu, že metoda {0} je označená jako OnSerializing, OnSerialized, OnDeserializing nebo OnDeserialized, změňte její návratový typ z {1} na void (Sub ve Visual Basicu).</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyMessageParameters">
        <source>Because {0} is marked with OnSerializing, OnSerialized, OnDeserializing, or OnDeserialized, change its signature so that it takes a single parameter of type 'System.Runtime.Serialization.StreamingContext'.</source>
        <target state="translated">Vzhledem k tomu, že metoda {0} je označená jako OnSerializing, OnSerialized, OnDeserializing nebo OnDeserialized, změňte její signaturu tak, aby přijímala jen jeden parametr typu System.Runtime.Serialization.StreamingContext.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyMessageGeneric">
        <source>Because {0} is marked with OnSerializing, OnSerialized, OnDeserializing, or OnDeserialized, change its signature so that it is no longer generic.</source>
        <target state="translated">Vzhledem k tomu, že metoda {0} je označená jako OnSerializing, OnSerialized, OnDeserializing nebo OnDeserialized, změňte její signaturu tak, aby už nebyla obecná.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementSerializationMethodsCorrectlyMessageStatic">
        <source>Because {0} is marked with OnSerializing, OnSerialized, OnDeserializing, or OnDeserialized, change it from static (Shared in Visual Basic) to an instance method.</source>
        <target state="translated">Vzhledem k tomu, že metoda {0} je označená jako OnSerializing, OnSerialized, OnDeserializing nebo OnDeserialized, změňte ji ze static (Shared ve Visual Basicu) na metodu instance.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideDeserializationMethodsForOptionalFieldsTitle">
        <source>Provide deserialization methods for optional fields</source>
        <target state="translated">Zadejte deserializační metody pro nepovinná pole</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideDeserializationMethodsForOptionalFieldsDescription">
        <source>A type has a field that is marked by using the System.Runtime.Serialization.OptionalFieldAttribute attribute, and the type does not provide deserialization event handling methods.</source>
        <target state="translated">Typ má pole označené atributem System.Runtime.Serialization.OptionalFieldAttribute, ale neposkytuje metody pro zpracování událostí deserializace.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideDeserializationMethodsForOptionalFieldsMessageOnDeserialized">
        <source>Add a 'private void OnDeserialized(StreamingContext)' method to type {0} and attribute it with the System.Runtime.Serialization.OnDeserializedAttribute.</source>
        <target state="translated">Přidejte do typu {0} metodu private void OnDeserialized(StreamingContext) a označte ji atributem System.Runtime.Serialization.OnDeserializedAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="ProvideDeserializationMethodsForOptionalFieldsMessageOnDeserializing">
        <source>Add a 'private void OnDeserializing(StreamingContext)' method to type {0} and attribute it with the System.Runtime.Serialization.OnDeserializingAttribute.</source>
        <target state="translated">Přidejte do typu {0} metodu private void OnDeserializing(StreamingContext) a označte ji atributem System.Runtime.Serialization.OnDeserializingAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementISerializableCorrectlyTitle">
        <source>Implement ISerializable correctly</source>
        <target state="translated">Implementujte správně ISerializable</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementISerializableCorrectlyDescription">
        <source>To fix a violation of this rule, make the GetObjectData method visible and overridable, and make sure that all instance fields are included in the serialization process or explicitly marked by using the NonSerializedAttribute attribute.</source>
        <target state="translated">Pokud chcete napravit porušení tohoto pravidla, nastavte metodu GetObjectData tak, aby byla viditelná a dala se přepsat, a ujistěte se, že všechna pole instancí se zahrnula do procesu serializace nebo explicitně označila atributem NonSerializedAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementISerializableCorrectlyMessageDefault">
        <source>Add an implementation of GetObjectData to type {0}.</source>
        <target state="translated">Přidejte k typu {0} implementaci metody GetObjectData.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementISerializableCorrectlyMessageMakeVisible">
        <source>Increase the accessibility of {0}.GetObjectData so that it is visible to derived types.</source>
        <target state="translated">Zvyšte přístupnost metody {0}.GetObjectData, aby ji mohly používat i odvozené typy.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplementISerializableCorrectlyMessageMakeOverridable">
        <source>Make {0}.GetObjectData virtual and overridable.</source>
        <target state="translated">Nastavte metodu {0}.GetObjectData jako virtuální a přepsatelnou.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDataSetReadXmlTitle">
        <source>Use XmlReader for DataSet ReadXml</source>
        <target state="translated">Pro DataSet ReadXml použijte XmlReader</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDataSetReadXmlDescription">
        <source>Do not use unsafe overloads of System.Data.DataSet.ReadXml. This API internally enables DTD processing on the XML reader instance used, and uses UrlResolver for resolving external XML entities. The outcome is information disclosure. Content from file system or network shares for the machine processing the XML can be exposed to attacker. In addition, an attacker can use this as a DoS vector.</source>
        <target state="translated">Nepoužívejte nebezpečná přetížení metody System.Data.DataSet.ReadXml. Toto rozhraní API umožňuje zpracovávat DTD v instanci používané čtečky XML a pomocí UrlResolveru překládá externí entity XML. Výsledkem je odhalení informací. Obsah systému souborů nebo sdílených síťových složek počítače, který zpracovává kód XML, může zjistit útočník. Kromě toho může toto útočník využít jako místo pro útok DoS.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDataSetReadXmlMessage">
        <source>Use XmlReader for DataSet ReadXml</source>
        <target state="translated">Pro DataSet ReadXml použijte XmlReader</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDataSetReadXmlSchemaTitle">
        <source>Use XmlReader for DataSet ReadXmlSchema</source>
        <target state="translated">Pro DataSet ReadXmlSchema použijte XmlReader</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDataSetReadXmlSchemaDescription">
        <source>Do not use unsafe overloads of System.Data.DataSet.ReadXmlSchema. This API internally enables DTD processing on the XML reader instance used, and uses UrlResolver for resolving external XML entities. The outcome is information disclosure. Content from file system or network shares for the machine processing the XML can be exposed to attacker. In addition, an attacker can use this as a DoS vector.</source>
        <target state="translated">Nepoužívejte nebezpečná přetížení metody System.Data.DataSet.ReadXmlSchema. Toto rozhraní API umožňuje zpracovávat DTD v instanci používané čtečky XML a pomocí UrlResolveru překládá externí entity XML. Výsledkem je odhalení informací. Obsah systému souborů nebo sdílených síťových složek počítače, který zpracovává kód XML, může zjistit útočník. Kromě toho může toto útočník využít jako místo pro útok DoS.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDataSetReadXmlSchemaMessage">
        <source>Use XmlReader for DataSet ReadXmlSchema</source>
        <target state="translated">Pro DataSet ReadXmlSchema použijte XmlReader</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewDataViewCollectionStringTitle">
        <source>Review DataView CollectionString</source>
        <target state="translated">Zkontrolujte DataView CollectionString</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewDataViewCollectionStringDescription">
        <source>Review code to insure that usage of System.Data.DataViewManager.DataViewSettingCollectionString input is sanitized to not contain DTD. Enabling DTD processing on the XML reader and using UrlResolver for resolving external XML entities may lead to information disclosure. Content from file system or network shares for the machine processing the XML can be exposed to attacker. In addition, an attacker can use this as a DoS vector.</source>
        <target state="translated">Zkontrolujte kód a ujistěte se, že vstup System.Data.DataViewManager.DataViewSettingCollectionString se upravil tak, aby neobsahoval DTD. Když se ve čtečce XML povolí zpracování DTD a k překladu externích entit XML se použije UrlResolver, může dojít k odhalení informací. Obsah systému souborů nebo sdílených síťových složek počítače, který zpracovává kód XML, může zjistit útočník. Kromě toho může toto útočník využít jako místo pro útok DoS.</target>
        <note />
      </trans-unit>
      <trans-unit id="ReviewDataViewCollectionStringMessage">
        <source>Review DataView CollectionString</source>
        <target state="translated">Zkontrolujte DataView CollectionString</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDataTableReadXmlTitle">
        <source>Use XmlReader for DataTable ReadXml</source>
        <target state="translated">Pro DataTable ReadXml použijte XmlReader</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDataTableReadXmlDescription">
        <source>Do not use unsafe overloads of System.Data.DataTable.ReadXml. This API internally enables DTD processing on the XML reader instance used, and uses UrlResolver for resolving external XML entities. The outcome is information disclosure. Content from file system or network shares for the machine processing the XML can be exposed to attacker. In addition, an attacker can use this as a DoS vector.</source>
        <target state="translated">Nepoužívejte nebezpečná přetížení metody System.Data.DataTable.ReadXml. Toto rozhraní API umožňuje zpracovávat DTD v instanci používané čtečky XML a pomocí UrlResolveru překládá externí entity XML. Výsledkem je odhalení informací. Obsah systému souborů nebo sdílených síťových složek počítače, který zpracovává kód XML, může zjistit útočník. Kromě toho může toto útočník využít jako místo pro útok DoS.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDataTableReadXmlMessage">
        <source>Use XmlReader for DataTable ReadXml</source>
        <target state="translated">Pro DataTable ReadXml použijte XmlReader</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDataTableReadXmlSchemaTitle">
        <source>Use XmlReader for DataTable ReadXmlSchema</source>
        <target state="translated">Pro DataTable ReadXmlSchema použijte XmlReader</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDataTableReadXmlSchemaDescription">
        <source>Checks for usage of an unsafe overload of  System.Data.DataTable.ReadXmlSchema. This API internally enables DTD processing on the XML reader instance used, and uses UrlResolver for resolving external XML entities. The outcome is information disclosure. Content from file system or network shares for the machine processing the XML can be exposed to attacker. In addition, an attacker can use this as a DoS vector.</source>
        <target state="translated">Zkontroluje, jestli se nepoužilo nebezpečné přetížení metody System.Data.DataTable.ReadXmlSchema. Toto rozhraní API umožňuje zpracovávat DTD v instanci používané čtečky XML a pomocí UrlResolveru překládá externí entity XML. Výsledkem je odhalení informací. Obsah systému souborů nebo sdílených síťových složek počítače, který zpracovává kód XML, může zjistit útočník. Kromě toho může toto útočník využít jako místo pro útok DoS.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseXmlReaderForDataTableReadXmlSchemaMessage">
        <source>Use XmlReader for DataTable ReadXmlSchema</source>
        <target state="translated">Pro DataTable ReadXmlSchema použijte XmlReader</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchCorruptedStateExceptions">
        <source>Do Not Catch Corrupted State Exceptions</source>
        <target state="translated">Nezachytávejte výjimky poškozující stav procesu</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchCorruptedStateExceptionsDescription">
        <source>Catching corrupted state exceptions could mask errors (such as access violations), resulting in inconsistent state of execution or making it easier for attackers to compromise system. Instead, catch and handle a more specific set of exception type(s) or re-throw the exception</source>
        <target state="translated">Zachytávání výjimek poškozující stav procesu může skrýt chyby (třeba narušení přístupu). To může vést k nekonzistentnímu stavu spuštění, ale taky usnadnit útočníkům průnik do systému. Místo toho zachyťte a zpracujte konkrétnější sadu typů výjimek nebo danou výjimku znovu vyvolejte.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCatchCorruptedStateExceptionsMessage">
        <source>{0} is catching corrupted state exception.</source>
        <target state="translated">{0} zachytává výjimku poškozující stav procesu.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseBrokenCryptographicAlgorithms">
        <source>Do Not Use Broken Cryptographic Algorithms</source>
        <target state="translated">Nepoužívejte prolomené kryptografické algoritmy</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseBrokenCryptographicAlgorithmsDescription">
        <source>An attack making it computationally feasible to break this algorithm exists. This allows attackers to break the cryptographic guarantees it is designed to provide. Depending on the type and application of this cryptographic algorithm, this may allow attackers to read enciphered messages, tamper with enciphered  messages, forge digital signatures, tamper with hashed content, or otherwise compromise any cryptosystem based on this algorithm. Replace encryption uses with the AES algorithm (AES-256, AES-192 and AES-128 are acceptable) with a key length greater than or equal to 128 bits. Replace hashing uses with a hashing function in the SHA-2 family, such as SHA512, SHA384, or SHA256. Replace digital signature uses with RSA with a key length greater than or equal to 2048-bits, or ECDSA with a key length greater than or equal to 256 bits.</source>
        <target state="translated">Existuje útok, který je výpočetně dostatečně výkonný na to, aby prolomil tento algoritmus. Díky tomu můžou útočníci překonat kryptografické zabezpečení, které má algoritmus poskytovat. Podle typu aplikace a kryptografického algoritmu to může útočníkovi umožnit číst šifrované zprávy, upravovat je, falšovat digitální podpisy, upravovat hodnotu hash obsahu nebo jinak útočit na kryptografický systém založený na tomto algoritmu. Nahraďte místa, kde se používá šifrování, algoritmem AES (přípustné jsou varianty AES-256, AES-192 a AES-128) s délkou klíče alespoň 128 bitů. Nahraďte místa, kde se používá algoritmus hash, hashovací funkcí řady SHA-2, třeba SHA512, SHA384 nebo SHA256. Nahraďte místa, kde se používá digitální podpis, šifrováním RSA s délkou klíče alespoň 2048 bitů nebo algoritmem ECDSA s délkou klíče alespoň 256 bitů.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseBrokenCryptographicAlgorithmsMessage">
        <source>{0} uses a broken cryptographic algorithm {1}</source>
        <target state="translated">{0} používá prolomený kryptografický algoritmus {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakCryptographicAlgorithms">
        <source>Do Not Use Weak Cryptographic Algorithms</source>
        <target state="translated">Nepoužívejte slabé kryptografické algoritmy</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakCryptographicAlgorithmsDescription">
        <source>Cryptographic algorithms degrade over time as attacks become for advances to attacker get access to more computation. Depending on the type and application of this cryptographic algorithm, further degradation of the cryptographic strength of it may allow attackers to read enciphered messages, tamper with enciphered  messages, forge digital signatures, tamper with hashed content, or otherwise compromise any cryptosystem based on this algorithm. Replace encryption uses with the AES algorithm (AES-256, AES-192 and AES-128 are acceptable) with a key length greater than or equal to 128 bits. Replace hashing uses with a hashing function in the SHA-2 family, such as SHA-2 512, SHA-2 384, or SHA-2 256.</source>
        <target state="translated">Výkonnost kryptografických algoritmů časem klesá, protože útoky se stávají stále sofistikovanější a útočníci získávají přístup k vyššímu výpočetnímu výkonu. Podle typu aplikace a kryptografického algoritmu může další snižování jeho kryptografické síly umožnit útočníkovi číst šifrované zprávy, upravovat je, falšovat digitální podpisy, upravovat hodnotu hash obsahu nebo jinak útočit na kryptografický systém založený na tomto algoritmu. Nahraďte místa, kde se používá šifrování, algoritmem AES (přípustné jsou varianty AES-256, AES-192 a AES-128) s délkou klíče alespoň 128 bitů. Nahraďte místa, kde se používá algoritmus hash, hashovací funkcí řady SHA-2, třeba SHA-2 512, SHA-2 384 nebo SHA-2 256.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseWeakCryptographicAlgorithmsMessage">
        <source>{0} uses a weak cryptographic algorithm {1}</source>
        <target state="translated">{0} používá slabý kryptografický algoritmus {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesShouldNotExtendCertainBaseTypesTitle">
        <source>Types should not extend certain base types</source>
        <target state="translated">Typy by neměly rozšiřovat určité základní typy</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesShouldNotExtendCertainBaseTypesDescription">
        <source>An externally visible type extends certain base types. Use one of the alternatives.</source>
        <target state="translated">Externě viditelný typ rozšiřuje určité základní typy. Použijte jednu z alternativ.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesShouldNotExtendCertainBaseTypesMessageSystemXmlXmlDocument">
        <source>Change the base type of {0} so that it no longer extends {1}. The preferred design is to decouple the underlying XmlDocument representation from the type's interface by using containment instead of inheritance.</source>
        <target state="translated">Změňte základní typ {0} tak, aby už nerozšiřoval {1}. Při návrhu se dává přednost tomu, že se základní reprezentace XmlDocument oddělí od rozhraní typu pomocí obsahování místo dědičnosti.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesShouldNotExtendCertainBaseTypesMessageSystemApplicationException">
        <source>Change the base type of {0} so that it no longer extends {1}. This base exception type does not provide any additional value for framework classes. Extend 'System.Exception' or an existing unsealed exception type instead. Do not create a new exception base type unless there is specific value in enabling the creation of a catch handler for an entire class of exceptions.</source>
        <target state="translated">Změňte základní typ {0} tak, aby už nerozšiřoval {1}. Tento základní typ výjimky neposkytuje třídám architektury žádnou další hodnotu. Rozšiřte místo toho System.Exception nebo existující nezapečetěný typ výjimky. Nevytvářejte nový základní typ výjimky, pokud pro to, abyste umožnili vytváření zachytávacího bloku pro celou třídu výjimky, nemáte konkrétní důvod.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesShouldNotExtendCertainBaseTypesMessageSystemCollectionsCollectionBase">
        <source>Change the base type of {0} from {1} to its generic equivalent 'System.Collections.ObjectModel.Collection'.</source>
        <target state="translated">Změňte základní typ {0} z {1} na obecný ekvivalent System.Collections.ObjectModel.Collection.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesShouldNotExtendCertainBaseTypesMessageSystemCollectionsDictionaryBase">
        <source>Change the base type of {0} from {1} to its generic equivalent 'System.Collections.ObjectModel.KeyedCollection'.</source>
        <target state="translated">Změňte základní typ {0} z {1} na obecný ekvivalent System.Collections.ObjectModel.KeyedCollection.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesShouldNotExtendCertainBaseTypesMessageSystemCollectionsQueue">
        <source>Change the base type of {0} from {1} to its generic equivalent 'System.Collections.Generic.Queue'.</source>
        <target state="translated">Změňte základní typ {0} z {1} na obecný ekvivalent System.Collections.Generic.Queue.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesShouldNotExtendCertainBaseTypesMessageSystemCollectionsReadOnlyCollectionBase">
        <source>Change the base type of {0} from {1} to its generic equivalent 'System.Collections.ObjectModel.ReadOnlyCollection'.</source>
        <target state="translated">Změňte základní typ {0} z {1} na obecný ekvivalent System.Collections.ObjectModel.ReadOnlyCollection.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesShouldNotExtendCertainBaseTypesMessageSystemCollectionsSortedList">
        <source>Change the base type of {0} from {1} to its generic equivalent 'System.Collections.Generic.SortedList'.</source>
        <target state="translated">Změňte základní typ {0} z {1} na obecný ekvivalent System.Collections.Generic.SortedList.</target>
        <note />
      </trans-unit>
      <trans-unit id="TypesShouldNotExtendCertainBaseTypesMessageSystemCollectionsStack">
        <source>Change the base type of {0} from {1} to its generic equivalent 'System.Collections.Generic.Stack'.</source>
        <target state="translated">Změňte základní typ {0} z {1} na obecný ekvivalent System.Collections.Generic.Stack.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseInsecureDtdProcessingDescription">
        <source>Using XmlTextReader.Load(), creating an insecure XmlReaderSettings instance when invoking XmlReader.Create(), setting the InnerXml property of the XmlDocument and enabling DTD processing using XmlUrlResolver insecurely can lead to information disclosure. Replace it with a call to the Load() method overload that takes an XmlReader instance, use XmlReader.Create() to accept XmlReaderSettings arguments or consider explicitly setting secure values. The DataViewSettingCollectionString property of DataViewManager should always be assigned from a trusted source, the DtdProcessing property should be set to false, and the XmlResolver property should be changed to XmlSecureResolver or null. </source>
        <target state="translated">Používání metody XmlTextReader.Load(), vytváření nezabezpečené instance XmlReaderSettings při volání metody XmlReader.Create(), nastavování vlastnosti InnerXml dokumentu XmlDocument a zapínání nezabezpečeného zpracování DTD pomocí nástroje XmlUrlResolver může vést k odhalení informací. Nahraďte je voláním přetížení metody Load(), která přijímá instanci XmlReader, pomocí metody XmlReader.Create() přijměte argumenty XmlReaderSettings nebo zvažte možnost explicitně nastavit bezpečné hodnoty. Vlastnost DataViewSettingCollectionString třídy DataViewManager by se vždy měla přiřazovat z důvěryhodného zdroje, vlastnost DtdProcessing by měla být nastavená na false a vlastnost XmlResolver by se měla změnit na XmlSecureResolver nebo null. </target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="DoNotUseDtdProcessingOverloadsMessage">
        <source>Unsafe overload of '{0}' method</source>
        <target state="translated">Nebezpečné přetížení metody {0}</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="DoNotUseDtdProcessingOverloads">
        <source>Insecure DTD Processing</source>
        <target state="translated">Nezabezpečené zpracování DTD</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="DoNotUseSetInnerXmlMessage">
        <source>Uses the unsafe setter of InnerXml property of System.Xml.XmlDocument.</source>
        <target state="translated">Používá nebezpečnou metodu setter vlastnosti InnerXml třídy System.Xml.XmlDocument.</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="InsecureXmlDtdProcessing">
        <source>Insecure DTD processing in XML</source>
        <target state="translated">Nezabezpečené zpracování DTD v XML</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="ReviewDtdProcessingPropertiesMessage">
        <source>Property in {0} might be set from an untrusted source.</source>
        <target state="translated">Vlastnost v {0} se mohla nastavit z nedůvěryhodného zdroje.</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="XmlDocumentWithNoSecureResolverMessage">
        <source>An XmlDocument instance is created without setting its XmlResolver property to a secure value.</source>
        <target state="translated">Instance XmlDocument se vytvořila bez toho, aby se vlastnost XmlResolver nastavila na bezpečnou hodnotu.</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="XmlReaderCreateInsecureConstructedMessage">
        <source>An insecure XmlReaderSettings instance is provided to XmlReader.Create method.</source>
        <target state="translated">Metodě XmlReader.Create se poskytla nezabezpečená instance XmlReaderSettings.</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="XmlReaderCreateInsecureInputMessage">
        <source>A potentially insecure XmlReaderSettings instance is provided to XmlReader.Create method.</source>
        <target state="translated">Metodě XmlReader.Create se poskytla potenciálně nezabezpečená instance XmlReaderSettings.</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="XmlReaderCreateWrongOverloadMessage">
        <source>An insecure overload of XmlReader.Create which does not accept an XmlReaderSettings argument.</source>
        <target state="translated">Nezabezpečené přetížení metody XmlReader.Create, která nepřijímá argument XmlReaderSettings</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="XmlTextReaderConstructedWithNoSecureResolutionMessage">
        <source>XmlTextReader instance created with insecure default settings.</source>
        <target state="translated">Instance XmlTextReader se vytvořila s nezabezpečenými výchozími nastaveními.</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="XmlTextReaderSetInsecureResolutionMessage">
        <source>XmlTextReader instance is set with insecure values.</source>
        <target state="translated">Instance XmlTextReader má nastavené nezabezpečené hodnoty.</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="DoNotUseInsecureDtdProcessingGenericMessage">
        <source>{0}</source>
        <target state="translated">{0}</target>
        <note>CA3075</note>
      </trans-unit>
      <trans-unit id="InsecureDtdProcessingInApiDesign">
        <source>Insecure Processing in API Design, XmlDocument and XmlTextReader</source>
        <target state="translated">Nezabezpečené zpracování v návrhu rozhraní API a třídách XmlDocument a XmlTextReader</target>
        <note>CA3077</note>
      </trans-unit>
      <trans-unit id="DoNotUseInsecureDtdProcessingInApiDesignDescription">
        <source>Enabling DTD processing on all instances derived from XmlTextReader or  XmlDocument and using XmlUrlResolver for resolving external XML entities may lead to information disclosure. Ensure to set the XmlResolver property to null, create an instance of XmlSecureResolver when processing untrusted input, or use XmlReader.Create method with a secure XmlReaderSettings argument. Unless you need to enable it, ensure the DtdProcessing property is set to false. </source>
        <target state="translated">Když se ve všech instancích odvozených od třídy XmlTextReader nebo XmlDocument povolí zpracování DTD a k překladu externích entit XML se použije XmlUrlResolver, může dojít k odhalení informací. Ujistěte se, že jste nastavili vlastnost XmlResolver na null, při zpracování nedůvěryhodného vstupu vytvořte instanci třídy XmlSecureResolver nebo použijte metodu XmlReader.Create s bezpečným argumentem XmlReaderSettings. Pokud nepotřebujete povolit vlastnost DtdProcessing, ujistěte se, že je nastavená na false. </target>
        <note>CA3077</note>
      </trans-unit>
      <trans-unit id="XmlDocumentDerivedClassConstructorNoSecureXmlResolverMessage">
        <source>Constructor of XmlDocument derived class {0} implicitly uses insecure default value for DTD processing.</source>
        <target state="translated">Konstruktor odvozené třídy XmlDocument {0} implicitně používá pro zpracování DTD nezabezpečenou výchozí hodnotu.</target>
        <note>CA3077</note>
      </trans-unit>
      <trans-unit id="XmlDocumentDerivedClassNoConstructorMessage">
        <source>XmlDocument derived class {0} doesn't explictily define a constructor.</source>
        <target state="translated">Odvozená třída XmlDocument {0} nedefinuje explicitně konstruktor.</target>
        <note>CA3077</note>
      </trans-unit>
      <trans-unit id="XmlDocumentDerivedClassSetInsecureXmlResolverInMethodMessage">
        <source>Method {0} of XmlDocument derived class sets XmlResolver property to an insecure value.</source>
        <target state="translated">Metoda {0} odvozené třídy XmlDocument nastavuje vlastnost XmlResolver na nezabezpečenou hodnotu.</target>
        <note>CA3077</note>
      </trans-unit>
      <trans-unit id="XmlTextReaderDerivedClassConstructorNoSecureSettingsMessage">
        <source>Constructor of XmlTextReader derived class {0} uses insecure default values for DTD processing.</source>
        <target state="translated">Konstruktor odvozené třídy XmlTextReader {0} používá pro zpracování DTD nezabezpečené výchozí hodnoty.</target>
        <note>CA3077</note>
      </trans-unit>
      <trans-unit id="XmlTextReaderDerivedClassNoConstructorMessage">
        <source>XmlTextReader derived class {0} doesn't explictily define a constructor.</source>
        <target state="translated">Odvozená třída XmlTextReader {0} nedefinuje explicitně konstruktor.</target>
        <note>CA3077</note>
      </trans-unit>
      <trans-unit id="XmlTextReaderDerivedClassSetInsecureSettingsInMethodMessage">
        <source>{0} method of XmlTextReader derived class sets XmlResolver and/or DtdProcessing property to insecure value.</source>
        <target state="translated">Metoda {0} odvozené třídy XmlTextReader nastavuje vlastnosti XmlResolver a/nebo DtdProcessing na nezabezpečenou hodnotu.</target>
        <note>CA3077</note>
      </trans-unit>
      <trans-unit id="InsecureXsltScriptProcessingMessage">
        <source>Insecure XSLT script processing.</source>
        <target state="translated">Nezabezpečené zpracování skriptu XSLT</target>
        <note>CA3076</note>
      </trans-unit>
      <trans-unit id="DoNotUseInsecureXSLTScriptExecutionDescription">
        <source>Providing an insecure XsltSettings instance and an insecure XmlResolver instance to XslCompiledTransform.Load method is potentially unsafe as it allows processing script within XSL, which on an untrusted XSL input may lead to malicious code execution. Either replace the insecure XsltSettings argument with XsltSettings.Default or an instance that has disabled document function and script execution, or replace the XmlResolver argurment with null or an XmlSecureResolver instance. This message may be suppressed if the input is known to be from a trusted source and external resource resolution from locations that are not known in advance must be supported.</source>
        <target state="translated">Poskytnutí nezabezpečených instancí XsltSettings a XmlResolver metodě XslCompiledTransform.Load je potenciálně nebezpečné, protože to umožňuje zpracovat skript v šabloně stylů XSL, který při zpracování nedůvěryhodného vstupu XSL může vést ke spuštění škodlivého kódu. Buď nahraďte nezabezpečený argument XsltSettings hodnotou XsltSettings.Default nebo instancí, která má zakázané funkce dokumentů a spouštění skriptů, nebo nahraďte argument XmlResolver hodnotou null nebo instancí XmlSecureResolver. Pokud víte, že vstup pochází z důvěryhodného zdroje, a musíte podporovat překlad externích prostředků z umístění, která předem neznáte, dá se tato zpráva potlačit.</target>
        <note>CA3076</note>
      </trans-unit>
      <trans-unit id="XslCompiledTransformLoadInsecureConstructedMessage">
        <source>In {0} an insecure combination of XsltSettings and XmlResolver instances are provided to XslCompiledTransfor.Load as arguments.</source>
        <target state="translated">V argumentech metody XslCompiledTransfor.Load v {0} se předala nezabezpečená kombinace instancí XsltSettings a XmlResolver.</target>
        <note>CA3076</note>
      </trans-unit>
      <trans-unit id="XslCompiledTransformLoadInsecureInputMessage">
        <source>In {0} an insecure combination of XsltSettings and XmlResolver instances are provided to XslCompiledTransfor.Load as arguments.</source>
        <target state="translated">V argumentech metody XslCompiledTransfor.Load v {0} se předala nezabezpečená kombinace instancí XsltSettings a XmlResolver.</target>
        <note>CA3076</note>
      </trans-unit>
    </body>
  </file>
</xliff>
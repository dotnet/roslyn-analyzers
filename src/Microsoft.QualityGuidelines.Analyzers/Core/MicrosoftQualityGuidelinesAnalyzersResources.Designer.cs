//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Microsoft.QualityGuidelines.Analyzers {
    using System;
    using System.Reflection;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class MicrosoftQualityGuidelinesAnalyzersResources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal MicrosoftQualityGuidelinesAnalyzersResources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Microsoft.QualityGuidelines.Analyzers.MicrosoftQualityGuidelinesAnalyzersResource" +
                            "s", typeof(MicrosoftQualityGuidelinesAnalyzersResources).GetTypeInfo().Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Because an exceptional event might occur that will prevent the finalizer of an object from running, the object should be explicitly disposed before all references to it are out of scope..
        /// </summary>
        internal static string DisposeObjectsBeforeLosingScopeDescription {
            get {
                return ResourceManager.GetString("DisposeObjectsBeforeLosingScopeDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Dispose Objects Before Losing Scope.
        /// </summary>
        internal static string DisposeObjectsBeforeLosingScopeMessage {
            get {
                return ResourceManager.GetString("DisposeObjectsBeforeLosingScopeMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Dispose Objects Before Losing Scope.
        /// </summary>
        internal static string DisposeObjectsBeforeLosingScopeTitle {
            get {
                return ResourceManager.GetString("DisposeObjectsBeforeLosingScopeTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not call overridable methods in constructors.
        /// </summary>
        internal static string DoNotCallOverridableMethodsInConstructors {
            get {
                return ResourceManager.GetString("DoNotCallOverridableMethodsInConstructors", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Virtual methods defined on the class should not be called from constructors. If a derived class has overridden the method, the derived class version will be called (before the derived class constructor is called)..
        /// </summary>
        internal static string DoNotCallOverridableMethodsInConstructorsDescription {
            get {
                return ResourceManager.GetString("DoNotCallOverridableMethodsInConstructorsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The common language runtime initializes all fields to their default values before running the constructor. In most cases, initializing a field to its default value in a constructor is redundant, which degrades performance and adds to maintenance costs. One case where it is not redundant occurs when the constructor calls another constructor of the same class or a base class constructor and that constructor initializes the field to a non-default value. In this case, changing the value of the field back to its [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string DoNotInitializeUnnecessarilyDescription {
            get {
                return ResourceManager.GetString("DoNotInitializeUnnecessarilyDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not initialize unnecessarily.
        /// </summary>
        internal static string DoNotInitializeUnnecessarilyMessage {
            get {
                return ResourceManager.GetString("DoNotInitializeUnnecessarilyMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not initialize unnecessarily.
        /// </summary>
        internal static string DoNotInitializeUnnecessarilyTitle {
            get {
                return ResourceManager.GetString("DoNotInitializeUnnecessarilyTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Members that do not access instance data or call instance methods can be marked as static (Shared in Visual Basic). After you mark the methods as static, the compiler will emit nonvirtual call sites to these members. This can give you a measurable performance gain for performance-sensitive code..
        /// </summary>
        internal static string MarkMembersAsStaticDescription {
            get {
                return ResourceManager.GetString("MarkMembersAsStaticDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mark members as static.
        /// </summary>
        internal static string MarkMembersAsStaticMessage {
            get {
                return ResourceManager.GetString("MarkMembersAsStaticMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mark members as static.
        /// </summary>
        internal static string MarkMembersAsStaticTitle {
            get {
                return ResourceManager.GetString("MarkMembersAsStaticTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A jagged array is an array whose elements are arrays. The arrays that make up the elements can be of different sizes, leading to less wasted space for some sets of data..
        /// </summary>
        internal static string PreferJaggedArraysOverMultidimensionalDescription {
            get {
                return ResourceManager.GetString("PreferJaggedArraysOverMultidimensionalDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} uses a multidimensional array of {1}. Replace it with a jagged array if possible..
        /// </summary>
        internal static string PreferJaggedArraysOverMultidimensionalMessageBody {
            get {
                return ResourceManager.GetString("PreferJaggedArraysOverMultidimensionalMessageBody", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} is a multidimensional array. Replace it with a jagged array if possible..
        /// </summary>
        internal static string PreferJaggedArraysOverMultidimensionalMessageDefault {
            get {
                return ResourceManager.GetString("PreferJaggedArraysOverMultidimensionalMessageDefault", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} returns a multidimensional array of {1}. Replace it with a jagged array if possible..
        /// </summary>
        internal static string PreferJaggedArraysOverMultidimensionalMessageReturn {
            get {
                return ResourceManager.GetString("PreferJaggedArraysOverMultidimensionalMessageReturn", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Prefer jagged arrays over multidimensional.
        /// </summary>
        internal static string PreferJaggedArraysOverMultidimensionalTitle {
            get {
                return ResourceManager.GetString("PreferJaggedArraysOverMultidimensionalTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove empty Finalizers.
        /// </summary>
        internal static string RemoveEmptyFinalizers {
            get {
                return ResourceManager.GetString("RemoveEmptyFinalizers", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Finalizers should be avoided where possible, to avoid the additional performance overhead involved in tracking object lifetime..
        /// </summary>
        internal static string RemoveEmptyFinalizersDescription {
            get {
                return ResourceManager.GetString("RemoveEmptyFinalizersDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Re-throwing caught exception changes stack information..
        /// </summary>
        internal static string RethrowToPreserveStackDetailsMessage {
            get {
                return ResourceManager.GetString("RethrowToPreserveStackDetailsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Rethrow to preserve stack details..
        /// </summary>
        internal static string RethrowToPreserveStackDetailsTitle {
            get {
                return ResourceManager.GetString("RethrowToPreserveStackDetailsTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A public or protected event-handling method was detected. Event-handling methods should not be exposed unless absolutely necessary..
        /// </summary>
        internal static string ReviewVisibleEventHandlersDescription {
            get {
                return ResourceManager.GetString("ReviewVisibleEventHandlersDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Consider making {0} not externally visible..
        /// </summary>
        internal static string ReviewVisibleEventHandlersMessageDefault {
            get {
                return ResourceManager.GetString("ReviewVisibleEventHandlersMessageDefault", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Consider making {0} not externally visible or ensure that it is benign code..
        /// </summary>
        internal static string ReviewVisibleEventHandlersMessageSecurity {
            get {
                return ResourceManager.GetString("ReviewVisibleEventHandlersMessageSecurity", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Review visible event handlers.
        /// </summary>
        internal static string ReviewVisibleEventHandlersTitle {
            get {
                return ResourceManager.GetString("ReviewVisibleEventHandlersTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An inheritable public type provides an overridable method implementation of an internal (Friend in Visual Basic) interface. To fix a violation of this rule, prevent the method from being overridden outside the assembly..
        /// </summary>
        internal static string SealMethodsThatSatisfyPrivateInterfacesDescription {
            get {
                return ResourceManager.GetString("SealMethodsThatSatisfyPrivateInterfacesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Seal methods that satisfy private interfaces.
        /// </summary>
        internal static string SealMethodsThatSatisfyPrivateInterfacesMessage {
            get {
                return ResourceManager.GetString("SealMethodsThatSatisfyPrivateInterfacesMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Seal methods that satisfy private interfaces.
        /// </summary>
        internal static string SealMethodsThatSatisfyPrivateInterfacesTitle {
            get {
                return ResourceManager.GetString("SealMethodsThatSatisfyPrivateInterfacesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to A field is declared static and read-only (Shared and ReadOnly in Visual Basic), and is initialized by using a value that is computable at compile time. Because the value that is assigned to the targeted field is computable at compile time, change the declaration to a const (Const in Visual Basic) field so that the value is computed at compile time instead of at run?time..
        /// </summary>
        internal static string UseLiteralsWhereAppropriateDescription {
            get {
                return ResourceManager.GetString("UseLiteralsWhereAppropriateDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Field {0} is declared as &apos;static readonly&apos; but is initialized with a constant value &apos;{1}&apos;. Mark this field as &apos;const&apos; instead..
        /// </summary>
        internal static string UseLiteralsWhereAppropriateMessageDefault {
            get {
                return ResourceManager.GetString("UseLiteralsWhereAppropriateMessageDefault", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Field {0} is declared as &apos;static readonly&apos; but is initialized with an empty string (&quot;&quot;). Mark this field as &apos;const&apos; instead..
        /// </summary>
        internal static string UseLiteralsWhereAppropriateMessageEmptyString {
            get {
                return ResourceManager.GetString("UseLiteralsWhereAppropriateMessageEmptyString", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use literals where appropriate.
        /// </summary>
        internal static string UseLiteralsWhereAppropriateTitle {
            get {
                return ResourceManager.GetString("UseLiteralsWhereAppropriateTitle", resourceCulture);
            }
        }
    }
}

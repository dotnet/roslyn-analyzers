<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="es" original="../RoslynDiagnosticsAnalyzersResources.resx">
    <body>
      <trans-unit id="ExportedPartsShouldHaveImportingConstructorCodeFix_ImplicitConstructor">
        <source>Explicitly define the importing constructor</source>
        <target state="translated">Definir explícitamente el constructor de importación</target>
        <note />
      </trans-unit>
      <trans-unit id="ExportedPartsShouldHaveImportingConstructorCodeFix_MissingAttribute">
        <source>Add 'ImportingConstructor' attribute</source>
        <target state="translated">Agregar el atributo "ImportingConstructor"</target>
        <note />
      </trans-unit>
      <trans-unit id="ExportedPartsShouldHaveImportingConstructorCodeFix_NonPublicConstructor">
        <source>Make constructor public</source>
        <target state="translated">Convertir el constructor en público</target>
        <note />
      </trans-unit>
      <trans-unit id="ExportedPartsShouldHaveImportingConstructorDescription">
        <source>Exported parts should have [ImportingConstructor]</source>
        <target state="translated">Las partes exportadas deben tener [ImportingConstructor]</target>
        <note />
      </trans-unit>
      <trans-unit id="ExportedPartsShouldHaveImportingConstructorMessage">
        <source>'{0}' is MEF-exported and should have a single importing constructor of the correct form</source>
        <target state="translated">MEF exporta "{0}" y debe tener un único constructor de importación con el formato correcto.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExportedPartsShouldHaveImportingConstructorTitle">
        <source>Exported parts should have [ImportingConstructor]</source>
        <target state="translated">Las partes exportadas deben tener [ImportingConstructor]</target>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteCodeFix_ErrorSetToFalse">
        <source>Set ObsoleteAttribute.Error to true</source>
        <target state="translated">Establecer ObsoleteAttribute.Error en true</target>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteCodeFix_IncorrectDescription">
        <source>Use correct ObsoleteAttribute message</source>
        <target state="translated">Usa el mensaje ObsoleteAttribute correcto.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteCodeFix_MissingAttribute">
        <source>Add ObsoleteAttribute</source>
        <target state="translated">Agregar ObsoleteAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteCodeFix_MissingDescription">
        <source>Configure ObsoleteAttribute for importing constructor</source>
        <target state="translated">Configura ObsoleteAttribute para el constructor de importación.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteCodeFix_MissingError">
        <source>Set ObsoleteAttribute.Error to true</source>
        <target state="translated">Establecer ObsoleteAttribute.Error en true</target>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteDescription">
        <source>Importing constructor should be [Obsolete]</source>
        <target state="translated">El constructor de importación debe ser [Obsolete]</target>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteMessage">
        <source>Importing constructor should be [Obsolete]</source>
        <target state="translated">El constructor de importación debe ser [Obsolete]</target>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteTitle">
        <source>Importing constructor should be [Obsolete]</source>
        <target state="translated">El constructor de importación debe ser [Obsolete]</target>
        <note />
      </trans-unit>
      <trans-unit id="TestExportsShouldNotBeDiscoverableCodeFix">
        <source>Apply PartNotDiscoverableAttribute</source>
        <target state="translated">Aplicar PartNotDiscoverableAttribute</target>
        <note />
      </trans-unit>
      <trans-unit id="TestExportsShouldNotBeDiscoverableDescription">
        <source>Test exports should not be discoverable</source>
        <target state="translated">Las exportaciones de prueba no deben poder detectarse</target>
        <note />
      </trans-unit>
      <trans-unit id="TestExportsShouldNotBeDiscoverableMessage">
        <source>'{0}' is exported for test purposes and should be marked PartNotDiscoverable</source>
        <target state="translated">"{0}" se exporta con fines de prueba y debe marcarse como PartNotDiscoverable.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestExportsShouldNotBeDiscoverableTitle">
        <source>Test exports should not be discoverable</source>
        <target state="translated">Las exportaciones de prueba no deben poder detectarse</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpecializedCollectionsEmptyEnumerableTitle">
        <source>Use SpecializedCollections.EmptyEnumerable()</source>
        <target state="translated">Usar SpecializedCollections.EmptyEnumerable()</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpecializedCollectionsEmptyEnumerableDescription">
        <source>#N/A</source>
        <target state="translated">#N/D</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpecializedCollectionsEmptyEnumerableMessage">
        <source>Use SpecializedCollections.EmptyEnumerable()</source>
        <target state="translated">Usar SpecializedCollections.EmptyEnumerable()</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpecializedCollectionsSingletonEnumerableTitle">
        <source>Use SpecializedCollections.SingletonEnumerable()</source>
        <target state="translated">Usar SpecializedCollections.SingletonEnumerable()</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpecializedCollectionsSingletonEnumerableDescription">
        <source>#N/A</source>
        <target state="translated">#N/D</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpecializedCollectionsSingletonEnumerableMessage">
        <source>Use SpecializedCollections.SingletonEnumerable()</source>
        <target state="translated">Usar SpecializedCollections.SingletonEnumerable()</target>
        <note />
      </trans-unit>
      <trans-unit id="InvokeTheCorrectPropertyToEnsureCorrectUseSiteDiagnosticsTitle">
        <source>Invoke the correct property to ensure correct use site diagnostics.</source>
        <target state="translated">Invoque la propiedad correcta para garantizar el diagnóstico de uso de sitio correcto.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvokeTheCorrectPropertyToEnsureCorrectUseSiteDiagnosticsDescription">
        <source>#N/A</source>
        <target state="translated">#N/D</target>
        <note />
      </trans-unit>
      <trans-unit id="InvokeTheCorrectPropertyToEnsureCorrectUseSiteDiagnosticsMessage">
        <source>Invoke the correct property to ensure correct use site diagnostics.</source>
        <target state="translated">Invoque la propiedad correcta para garantizar el diagnóstico de uso de sitio correcto.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseGenericCodeActionCreateToCreateCodeActionTitle">
        <source>Do not use generic CodeAction.Create to create CodeAction</source>
        <target state="translated">No utilizar CodeAction.Create genérico para crear CodeAction</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseGenericCodeActionCreateToCreateCodeActionDescription">
        <source>#N/A</source>
        <target state="translated">#N/D</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseGenericCodeActionCreateToCreateCodeActionMessage">
        <source>Do not use generic CodeAction.Create to create CodeAction</source>
        <target state="translated">No utilizar CodeAction.Create genérico para crear CodeAction</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsObjectWhenImplementingIequatableTitle">
        <source>Override Object.Equals(object) when implementing Iequatable</source>
        <target state="translated">Reemplazar Object.Equals(object) al implementar Iequatable</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsObjectWhenImplementingIequatableDescription">
        <source>#N/A</source>
        <target state="translated">#N/D</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsObjectWhenImplementingIequatableMessage">
        <source>Override Object.Equals(object) when implementing Iequatable</source>
        <target state="translated">Reemplazar Object.Equals(object) al implementar Iequatable</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInvokeDiagnosticDescriptorTitle">
        <source>Do not invoke Diagnostic.Descriptor</source>
        <target state="translated">No invocar Diagnostic.Descriptor</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInvokeDiagnosticDescriptorDescription">
        <source>Accessing the Descriptor property of Diagnostic in compiler layer leads to unnecessary string allocations for fields of the descriptor that are not utilized in command line compilation. Hence, you should avoid accessing the Descriptor of the compiler diagnostics here. Instead you should directly access these properties off the Diagnostic type.</source>
        <target state="translated">El acceso a la propiedad Descriptor de Diagnostic en la capa del compilador provoca asignaciones de cadena innecesarias para los campos del descriptor que no se utilizan en la compilación de la línea de comandos. Por lo tanto, debe evitar el acceso a Descriptor del diagnóstico del compilador aquí. En su lugar, debe acceder directamente a estas propiedades desde fuera del tipo de Diagnostic.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInvokeDiagnosticDescriptorMessage">
        <source>Do not invoke property '{0}' on type '{1}', instead directly access the required member{2} on '{1}'</source>
        <target state="translated">No invoque a la propiedad "{0}" en el tipo "{1}", acceda directamente en su lugar al miembro requerido {2} en "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="SymbolDeclaredEventMustBeGeneratedForSourceSymbolsTitle">
        <source>SymbolDeclaredEvent must be generated for source symbols</source>
        <target state="translated">Debe generarse SymbolDeclaredEvent para los símbolos de origen.</target>
        <note />
      </trans-unit>
      <trans-unit id="SymbolDeclaredEventMustBeGeneratedForSourceSymbolsDescription">
        <source>Compilation event queue is required to generate symbol declared events for all declared source symbols. Hence, every source symbol type or one of its base types must generate a symbol declared event.</source>
        <target state="translated">Se requiere la cola del evento de compilación para generar eventos declarados de símbolos para todos los símbolos de origen declarados. Por lo tanto, todos los tipos de símbolos de origen de uno de sus tipos base debe generar un evento declarado de símbolos.</target>
        <note />
      </trans-unit>
      <trans-unit id="SymbolDeclaredEventMustBeGeneratedForSourceSymbolsMessage">
        <source>SymbolDeclaredEvent must be generated for source symbols</source>
        <target state="translated">Debe generarse SymbolDeclaredEvent para los símbolos de origen.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMixAttributesFromDifferentVersionsOfMEFTitle">
        <source>Do not mix attributes from different versions of MEF</source>
        <target state="translated">No se deben mezclar atributos de distintas versiones de MEF.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMixAttributesFromDifferentVersionsOfMEFDescription">
        <source>Do not mix attributes from different versions of MEF</source>
        <target state="translated">No se deben mezclar atributos de distintas versiones de MEF.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMixAttributesFromDifferentVersionsOfMEFMessage">
        <source>Attribute '{0}' comes from a different version of MEF than the export attribute on '{1}'</source>
        <target state="translated">El atributo “{0}” procede de una versión de MEF distinta a la del atributo de exportación en “{1}”.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartsExportedWithMEFv2MustBeMarkedAsSharedTitle">
        <source>Parts exported with MEFv2 must be marked as Shared</source>
        <target state="translated">Las partes exportadas con MEFv2 deben marcarse como Shared</target>
        <note />
      </trans-unit>
      <trans-unit id="PartsExportedWithMEFv2MustBeMarkedAsSharedDescription">
        <source>Part exported with MEFv2 must be marked with the Shared attribute.</source>
        <target state="translated">Las partes exportadas con MEFv2 deben marcarse con el atributo Shared.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartsExportedWithMEFv2MustBeMarkedAsSharedMessage">
        <source>'{0}' is exported with MEFv2 and hence must be marked as Shared</source>
        <target state="translated">“{0}” se exporta con MEFv2 y, por lo tanto, debe marcarse como Shared.</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
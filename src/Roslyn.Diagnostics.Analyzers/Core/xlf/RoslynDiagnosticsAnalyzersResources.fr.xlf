<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="fr" original="../RoslynDiagnosticsAnalyzersResources.resx">
    <body>
      <trans-unit id="ExportedPartsShouldHaveImportingConstructorCodeFix_ImplicitConstructor">
        <source>Explicitly define the importing constructor</source>
        <note />
      </trans-unit>
      <trans-unit id="ExportedPartsShouldHaveImportingConstructorCodeFix_MissingAttribute">
        <source>Add 'ImportingConstructor' attribute</source>
        <note />
      </trans-unit>
      <trans-unit id="ExportedPartsShouldHaveImportingConstructorCodeFix_NonPublicConstructor">
        <source>Make constructor public</source>
        <note />
      </trans-unit>
      <trans-unit id="ExportedPartsShouldHaveImportingConstructorDescription">
        <source>Exported parts should have [ImportingConstructor]</source>
        <note />
      </trans-unit>
      <trans-unit id="ExportedPartsShouldHaveImportingConstructorMessage">
        <source>'{0}' is MEF-exported and should have a single importing constructor of the correct form</source>
        <note />
      </trans-unit>
      <trans-unit id="ExportedPartsShouldHaveImportingConstructorTitle">
        <source>Exported parts should have [ImportingConstructor]</source>
        <note />
      </trans-unit>
      <trans-unit id="ExternalApiShouldBeAccessibleDescription">
        <source>External API should be accessible</source>
        <target state="new">External API should be accessible</target>
        <note />
      </trans-unit>
      <trans-unit id="ExternalApiShouldBeAccessibleMessage">
        <source>External API references internal symbol '{0}'</source>
        <target state="new">External API references internal symbol '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ExternalApiShouldBeAccessibleTitle">
        <source>External API should be accessible</source>
        <target state="new">External API should be accessible</target>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteCodeFix_ErrorSetToFalse">
        <source>Set ObsoleteAttribute.Error to true</source>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteCodeFix_IncorrectDescription">
        <source>Use correct ObsoleteAttribute message</source>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteCodeFix_MissingAttribute">
        <source>Add ObsoleteAttribute</source>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteCodeFix_MissingDescription">
        <source>Configure ObsoleteAttribute for importing constructor</source>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteCodeFix_MissingError">
        <source>Set ObsoleteAttribute.Error to true</source>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteDescription">
        <source>Importing constructor should be [Obsolete]</source>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteMessage">
        <source>Importing constructor should be [Obsolete]</source>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteTitle">
        <source>Importing constructor should be [Obsolete]</source>
        <note />
      </trans-unit>
      <trans-unit id="LinkedEnumerationShouldHaveAllMembersDescription">
        <source>Linked enumeration should have all members</source>
        <target state="new">Linked enumeration should have all members</target>
        <note />
      </trans-unit>
      <trans-unit id="LinkedEnumerationShouldHaveAllMembersFix">
        <source>Synchronize missing members</source>
        <target state="new">Synchronize missing members</target>
        <note />
      </trans-unit>
      <trans-unit id="LinkedEnumerationShouldHaveAllMembersMessage">
        <source>Linked enumeration should have all members</source>
        <target state="new">Linked enumeration should have all members</target>
        <note />
      </trans-unit>
      <trans-unit id="LinkedEnumerationShouldHaveAllMembersTitle">
        <source>Linked enumeration should have all members</source>
        <target state="new">Linked enumeration should have all members</target>
        <note />
      </trans-unit>
      <trans-unit id="LinkedEnumerationShouldMatchNameDescription">
        <source>Linked enumeration member should be present in the source enumeration</source>
        <target state="new">Linked enumeration member should be present in the source enumeration</target>
        <note />
      </trans-unit>
      <trans-unit id="LinkedEnumerationShouldMatchNameFix">
        <source>Synchronize name</source>
        <target state="new">Synchronize name</target>
        <note />
      </trans-unit>
      <trans-unit id="LinkedEnumerationShouldMatchNameMessage">
        <source>Linked enumeration member should be present in the source enumeration</source>
        <target state="new">Linked enumeration member should be present in the source enumeration</target>
        <note />
      </trans-unit>
      <trans-unit id="LinkedEnumerationShouldMatchNameTitle">
        <source>Linked enumeration member should be present in the source enumeration</source>
        <target state="new">Linked enumeration member should be present in the source enumeration</target>
        <note />
      </trans-unit>
      <trans-unit id="LinkedEnumerationShouldMatchValueDescription">
        <source>Linked enumeration member should match the value of the source enumeration member</source>
        <target state="new">Linked enumeration member should match the value of the source enumeration member</target>
        <note />
      </trans-unit>
      <trans-unit id="LinkedEnumerationShouldMatchValueFix">
        <source>Synchronize value</source>
        <target state="new">Synchronize value</target>
        <note />
      </trans-unit>
      <trans-unit id="LinkedEnumerationShouldMatchValueMessage">
        <source>Linked enumeration member should match the value of the source enumeration member</source>
        <target state="new">Linked enumeration member should match the value of the source enumeration member</target>
        <note />
      </trans-unit>
      <trans-unit id="LinkedEnumerationShouldMatchValueTitle">
        <source>Linked enumeration member should match the value of the source enumeration member</source>
        <target state="new">Linked enumeration member should match the value of the source enumeration member</target>
        <note />
      </trans-unit>
      <trans-unit id="TestExportsShouldNotBeDiscoverableCodeFix">
        <source>Apply PartNotDiscoverableAttribute</source>
        <note />
      </trans-unit>
      <trans-unit id="TestExportsShouldNotBeDiscoverableDescription">
        <source>Test exports should not be discoverable</source>
        <note />
      </trans-unit>
      <trans-unit id="TestExportsShouldNotBeDiscoverableMessage">
        <source>'{0}' is exported for test purposes and should be marked PartNotDiscoverable</source>
        <note />
      </trans-unit>
      <trans-unit id="TestExportsShouldNotBeDiscoverableTitle">
        <source>Test exports should not be discoverable</source>
        <note />
      </trans-unit>
      <trans-unit id="UseSpecializedCollectionsEmptyEnumerableTitle">
        <source>Use SpecializedCollections.EmptyEnumerable()</source>
        <target state="translated">Utiliser SpecializedCollections.EmptyEnumerable()</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpecializedCollectionsEmptyEnumerableDescription">
        <source>#N/A</source>
        <target state="translated">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpecializedCollectionsEmptyEnumerableMessage">
        <source>Use SpecializedCollections.EmptyEnumerable()</source>
        <target state="translated">Utiliser SpecializedCollections.EmptyEnumerable()</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpecializedCollectionsSingletonEnumerableTitle">
        <source>Use SpecializedCollections.SingletonEnumerable()</source>
        <target state="translated">Utiliser SpecializedCollections.SingletonEnumerable()</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpecializedCollectionsSingletonEnumerableDescription">
        <source>#N/A</source>
        <target state="translated">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpecializedCollectionsSingletonEnumerableMessage">
        <source>Use SpecializedCollections.SingletonEnumerable()</source>
        <target state="translated">Utiliser SpecializedCollections.SingletonEnumerable()</target>
        <note />
      </trans-unit>
      <trans-unit id="InvokeTheCorrectPropertyToEnsureCorrectUseSiteDiagnosticsTitle">
        <source>Invoke the correct property to ensure correct use site diagnostics.</source>
        <target state="translated">Appelez la propriété appropriée pour garantir l'utilisation adéquate des diagnostics de site.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvokeTheCorrectPropertyToEnsureCorrectUseSiteDiagnosticsDescription">
        <source>#N/A</source>
        <target state="translated">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="InvokeTheCorrectPropertyToEnsureCorrectUseSiteDiagnosticsMessage">
        <source>Invoke the correct property to ensure correct use site diagnostics.</source>
        <target state="translated">Appelez la propriété appropriée pour garantir l'utilisation adéquate des diagnostics de site.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseGenericCodeActionCreateToCreateCodeActionTitle">
        <source>Do not use generic CodeAction.Create to create CodeAction</source>
        <target state="translated">Ne pas utiliser de CodeAction.Create générique pour créer CodeAction</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseGenericCodeActionCreateToCreateCodeActionDescription">
        <source>#N/A</source>
        <target state="translated">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseGenericCodeActionCreateToCreateCodeActionMessage">
        <source>Do not use generic CodeAction.Create to create CodeAction</source>
        <target state="translated">Ne pas utiliser de CodeAction.Create générique pour créer CodeAction</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsObjectWhenImplementingIequatableTitle">
        <source>Override Object.Equals(object) when implementing Iequatable</source>
        <target state="translated">Remplacer Object.Equals(object) au moment d'implémenter Iequatable</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsObjectWhenImplementingIequatableDescription">
        <source>#N/A</source>
        <target state="translated">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsObjectWhenImplementingIequatableMessage">
        <source>Override Object.Equals(object) when implementing Iequatable</source>
        <target state="translated">Remplacer Object.Equals(object) au moment d'implémenter Iequatable</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInvokeDiagnosticDescriptorTitle">
        <source>Do not invoke Diagnostic.Descriptor</source>
        <target state="translated">Ne pas appeler Diagnostic.Descriptor</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInvokeDiagnosticDescriptorDescription">
        <source>Accessing the Descriptor property of Diagnostic in compiler layer leads to unnecessary string allocations for fields of the descriptor that are not utilized in command line compilation. Hence, you should avoid accessing the Descriptor of the compiler diagnostics here. Instead you should directly access these properties off the Diagnostic type.</source>
        <target state="translated">L'accès à la propriété Descriptor de Diagnostic dans la couche du compilateur entraîne des allocations de chaînes inutiles pour les champs du descripteur qui ne sont pas utilisés durant la compilation de la ligne de commande. Vous devez donc éviter d'accéder au descripteur des diagnostics du compilateur ici. À la place, accédez directement à ces propriétés hors du type Diagnostic.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInvokeDiagnosticDescriptorMessage">
        <source>Do not invoke property '{0}' on type '{1}', instead directly access the required member{2} on '{1}'</source>
        <target state="translated">N'appelez pas la propriété '{0}' sur le type '{1}'. À la place, accédez directement au membre nécessaire {2} sur '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="SymbolDeclaredEventMustBeGeneratedForSourceSymbolsTitle">
        <source>SymbolDeclaredEvent must be generated for source symbols</source>
        <target state="translated">SymbolDeclaredEvent doit être généré pour les symboles sources</target>
        <note />
      </trans-unit>
      <trans-unit id="SymbolDeclaredEventMustBeGeneratedForSourceSymbolsDescription">
        <source>Compilation event queue is required to generate symbol declared events for all declared source symbols. Hence, every source symbol type or one of its base types must generate a symbol declared event.</source>
        <target state="translated">Une file d'attente d'événements de compilation est nécessaire afin de générer les événements de déclaration de symbole pour tous les symboles sources déclarés. Ainsi, chaque type de symbole source ou l'un de ses types de base doit générer un événement de déclaration de symbole.</target>
        <note />
      </trans-unit>
      <trans-unit id="SymbolDeclaredEventMustBeGeneratedForSourceSymbolsMessage">
        <source>SymbolDeclaredEvent must be generated for source symbols</source>
        <target state="translated">SymbolDeclaredEvent doit être généré pour les symboles sources</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMixAttributesFromDifferentVersionsOfMEFTitle">
        <source>Do not mix attributes from different versions of MEF</source>
        <target state="translated">Ne pas mélanger les attributs de différentes versions de MEF</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMixAttributesFromDifferentVersionsOfMEFDescription">
        <source>Do not mix attributes from different versions of MEF</source>
        <target state="translated">Ne pas mélanger les attributs de différentes versions de MEF</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMixAttributesFromDifferentVersionsOfMEFMessage">
        <source>Attribute '{0}' comes from a different version of MEF than the export attribute on '{1}'</source>
        <target state="translated">L'attribut '{0}' provient d'une autre version de MEF que l'attribut d'exportation sur '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="PartsExportedWithMEFv2MustBeMarkedAsSharedTitle">
        <source>Parts exported with MEFv2 must be marked as Shared</source>
        <target state="translated">Les parties exportées avec MEFv2 doivent être marquées comme étant Shared</target>
        <note />
      </trans-unit>
      <trans-unit id="PartsExportedWithMEFv2MustBeMarkedAsSharedDescription">
        <source>Part exported with MEFv2 must be marked with the Shared attribute.</source>
        <target state="translated">La partie exportée avec MEFv2 doit être marquée avec l'attribut Shared.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartsExportedWithMEFv2MustBeMarkedAsSharedMessage">
        <source>'{0}' is exported with MEFv2 and hence must be marked as Shared</source>
        <target state="translated">'{0}' est exporté avec MEFv2 et doit donc être marqué comme étant Shared</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>
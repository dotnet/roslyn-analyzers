<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ko" original="../RoslynDiagnosticsAnalyzersResources.resx">
    <body>
      <trans-unit id="ExportedPartsShouldHaveImportingConstructorCodeFix_ImplicitConstructor">
        <source>Explicitly define the importing constructor</source>
        <note />
      </trans-unit>
      <trans-unit id="ExportedPartsShouldHaveImportingConstructorCodeFix_MissingAttribute">
        <source>Add 'ImportingConstructor' attribute</source>
        <note />
      </trans-unit>
      <trans-unit id="ExportedPartsShouldHaveImportingConstructorCodeFix_NonPublicConstructor">
        <source>Make constructor public</source>
        <note />
      </trans-unit>
      <trans-unit id="ExportedPartsShouldHaveImportingConstructorDescription">
        <source>Exported parts should have [ImportingConstructor]</source>
        <note />
      </trans-unit>
      <trans-unit id="ExportedPartsShouldHaveImportingConstructorMessage">
        <source>'{0}' is MEF-exported and should have a single importing constructor of the correct form</source>
        <note />
      </trans-unit>
      <trans-unit id="ExportedPartsShouldHaveImportingConstructorTitle">
        <source>Exported parts should have [ImportingConstructor]</source>
        <note />
      </trans-unit>
      <trans-unit id="ExternalApiShouldBeAccessibleDescription">
        <source>External API should be accessible</source>
        <target state="new">External API should be accessible</target>
        <note />
      </trans-unit>
      <trans-unit id="ExternalApiShouldBeAccessibleMessage">
        <source>External API references internal symbol '{0}'</source>
        <target state="new">External API references internal symbol '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="ExternalApiShouldBeAccessibleTitle">
        <source>External API should be accessible</source>
        <target state="new">External API should be accessible</target>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteCodeFix_ErrorSetToFalse">
        <source>Set ObsoleteAttribute.Error to true</source>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteCodeFix_IncorrectDescription">
        <source>Use correct ObsoleteAttribute message</source>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteCodeFix_MissingAttribute">
        <source>Add ObsoleteAttribute</source>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteCodeFix_MissingDescription">
        <source>Configure ObsoleteAttribute for importing constructor</source>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteCodeFix_MissingError">
        <source>Set ObsoleteAttribute.Error to true</source>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteDescription">
        <source>Importing constructor should be [Obsolete]</source>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteMessage">
        <source>Importing constructor should be [Obsolete]</source>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteTitle">
        <source>Importing constructor should be [Obsolete]</source>
        <note />
      </trans-unit>
      <trans-unit id="LinkedEnumerationShouldHaveAllMembersDescription">
        <source>Linked enumeration should have all members</source>
        <target state="new">Linked enumeration should have all members</target>
        <note />
      </trans-unit>
      <trans-unit id="LinkedEnumerationShouldHaveAllMembersFix">
        <source>Synchronize missing members</source>
        <target state="new">Synchronize missing members</target>
        <note />
      </trans-unit>
      <trans-unit id="LinkedEnumerationShouldHaveAllMembersMessage">
        <source>Linked enumeration should have all members</source>
        <target state="new">Linked enumeration should have all members</target>
        <note />
      </trans-unit>
      <trans-unit id="LinkedEnumerationShouldHaveAllMembersTitle">
        <source>Linked enumeration should have all members</source>
        <target state="new">Linked enumeration should have all members</target>
        <note />
      </trans-unit>
      <trans-unit id="LinkedEnumerationShouldMatchNameDescription">
        <source>Linked enumeration member should be present in the source enumeration</source>
        <target state="new">Linked enumeration member should be present in the source enumeration</target>
        <note />
      </trans-unit>
      <trans-unit id="LinkedEnumerationShouldMatchNameFix">
        <source>Synchronize name</source>
        <target state="new">Synchronize name</target>
        <note />
      </trans-unit>
      <trans-unit id="LinkedEnumerationShouldMatchNameMessage">
        <source>Linked enumeration member should be present in the source enumeration</source>
        <target state="new">Linked enumeration member should be present in the source enumeration</target>
        <note />
      </trans-unit>
      <trans-unit id="LinkedEnumerationShouldMatchNameTitle">
        <source>Linked enumeration member should be present in the source enumeration</source>
        <target state="new">Linked enumeration member should be present in the source enumeration</target>
        <note />
      </trans-unit>
      <trans-unit id="LinkedEnumerationShouldMatchValueDescription">
        <source>Linked enumeration member should match the value of the source enumeration member</source>
        <target state="new">Linked enumeration member should match the value of the source enumeration member</target>
        <note />
      </trans-unit>
      <trans-unit id="LinkedEnumerationShouldMatchValueFix">
        <source>Synchronize value</source>
        <target state="new">Synchronize value</target>
        <note />
      </trans-unit>
      <trans-unit id="LinkedEnumerationShouldMatchValueMessage">
        <source>Linked enumeration member should match the value of the source enumeration member</source>
        <target state="new">Linked enumeration member should match the value of the source enumeration member</target>
        <note />
      </trans-unit>
      <trans-unit id="LinkedEnumerationShouldMatchValueTitle">
        <source>Linked enumeration member should match the value of the source enumeration member</source>
        <target state="new">Linked enumeration member should match the value of the source enumeration member</target>
        <note />
      </trans-unit>
      <trans-unit id="TestExportsShouldNotBeDiscoverableCodeFix">
        <source>Apply PartNotDiscoverableAttribute</source>
        <note />
      </trans-unit>
      <trans-unit id="TestExportsShouldNotBeDiscoverableDescription">
        <source>Test exports should not be discoverable</source>
        <note />
      </trans-unit>
      <trans-unit id="TestExportsShouldNotBeDiscoverableMessage">
        <source>'{0}' is exported for test purposes and should be marked PartNotDiscoverable</source>
        <note />
      </trans-unit>
      <trans-unit id="TestExportsShouldNotBeDiscoverableTitle">
        <source>Test exports should not be discoverable</source>
        <note />
      </trans-unit>
      <trans-unit id="UseSpecializedCollectionsEmptyEnumerableTitle">
        <source>Use SpecializedCollections.EmptyEnumerable()</source>
        <target state="translated">SpecializedCollections.EmptyEnumerable()을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpecializedCollectionsEmptyEnumerableDescription">
        <source>#N/A</source>
        <target state="translated">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpecializedCollectionsEmptyEnumerableMessage">
        <source>Use SpecializedCollections.EmptyEnumerable()</source>
        <target state="translated">SpecializedCollections.EmptyEnumerable()을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpecializedCollectionsSingletonEnumerableTitle">
        <source>Use SpecializedCollections.SingletonEnumerable()</source>
        <target state="translated">SpecializedCollections.SingletonEnumerable()을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpecializedCollectionsSingletonEnumerableDescription">
        <source>#N/A</source>
        <target state="translated">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpecializedCollectionsSingletonEnumerableMessage">
        <source>Use SpecializedCollections.SingletonEnumerable()</source>
        <target state="translated">SpecializedCollections.SingletonEnumerable()을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvokeTheCorrectPropertyToEnsureCorrectUseSiteDiagnosticsTitle">
        <source>Invoke the correct property to ensure correct use site diagnostics.</source>
        <target state="translated">올바른 속성을 호출하여 사이트 진단을 올바르게 사용하는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvokeTheCorrectPropertyToEnsureCorrectUseSiteDiagnosticsDescription">
        <source>#N/A</source>
        <target state="translated">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="InvokeTheCorrectPropertyToEnsureCorrectUseSiteDiagnosticsMessage">
        <source>Invoke the correct property to ensure correct use site diagnostics.</source>
        <target state="translated">올바른 속성을 호출하여 사이트 진단을 올바르게 사용하는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseGenericCodeActionCreateToCreateCodeActionTitle">
        <source>Do not use generic CodeAction.Create to create CodeAction</source>
        <target state="translated">제네릭 CodeAction.Create를 사용하여 CodeAction을 만들지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseGenericCodeActionCreateToCreateCodeActionDescription">
        <source>#N/A</source>
        <target state="translated">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseGenericCodeActionCreateToCreateCodeActionMessage">
        <source>Do not use generic CodeAction.Create to create CodeAction</source>
        <target state="translated">제네릭 CodeAction.Create를 사용하여 CodeAction을 만들지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsObjectWhenImplementingIequatableTitle">
        <source>Override Object.Equals(object) when implementing Iequatable</source>
        <target state="translated">IEquatable을 구현할 때 Object.Equals(개체)를 재정의하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsObjectWhenImplementingIequatableDescription">
        <source>#N/A</source>
        <target state="translated">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsObjectWhenImplementingIequatableMessage">
        <source>Override Object.Equals(object) when implementing Iequatable</source>
        <target state="translated">IEquatable을 구현할 때 Object.Equals(개체)를 재정의하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInvokeDiagnosticDescriptorTitle">
        <source>Do not invoke Diagnostic.Descriptor</source>
        <target state="translated">Diagnostic.Descriptor를 호출하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInvokeDiagnosticDescriptorDescription">
        <source>Accessing the Descriptor property of Diagnostic in compiler layer leads to unnecessary string allocations for fields of the descriptor that are not utilized in command line compilation. Hence, you should avoid accessing the Descriptor of the compiler diagnostics here. Instead you should directly access these properties off the Diagnostic type.</source>
        <target state="translated">컴파일러 레이어에서 진단의 설명자 속성에 액세스하면 명령줄 컴파일에서 사용되지 않는 설명자의 필드에 대해 불필요한 문자열 할당이 발생합니다. 따라서 여기에서 컴파일러 진단의 설명자에 액세스하지 않아야 합니다. 대신 이 진단 형식의 속성에 직접 액세스해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotInvokeDiagnosticDescriptorMessage">
        <source>Do not invoke property '{0}' on type '{1}', instead directly access the required member{2} on '{1}'</source>
        <target state="translated">'{1}' 형식에서 '{0}' 속성을 호출하지 마세요. 대신 '{1}'에서 필수 멤버 {2}에 직접 액세스하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="SymbolDeclaredEventMustBeGeneratedForSourceSymbolsTitle">
        <source>SymbolDeclaredEvent must be generated for source symbols</source>
        <target state="translated">SymbolDeclaredEvent는 소스 기호에 대해 생성되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SymbolDeclaredEventMustBeGeneratedForSourceSymbolsDescription">
        <source>Compilation event queue is required to generate symbol declared events for all declared source symbols. Hence, every source symbol type or one of its base types must generate a symbol declared event.</source>
        <target state="translated">선언된 모든 소스 기호에 대해 기호가 선언된 이벤트를 생성하는 데 컴파일 이벤트 대기열이 필요합니다. 그러므로 모든 소스 기호 형식 또는 소스 기호의 기본 형식 중 하나는 기호가 선언된 이벤트를 생성해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SymbolDeclaredEventMustBeGeneratedForSourceSymbolsMessage">
        <source>SymbolDeclaredEvent must be generated for source symbols</source>
        <target state="translated">SymbolDeclaredEvent는 소스 기호에 대해 생성되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMixAttributesFromDifferentVersionsOfMEFTitle">
        <source>Do not mix attributes from different versions of MEF</source>
        <target state="translated">다른 버전의 MEF 특성을 조합하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMixAttributesFromDifferentVersionsOfMEFDescription">
        <source>Do not mix attributes from different versions of MEF</source>
        <target state="translated">다른 버전의 MEF 특성을 조합하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMixAttributesFromDifferentVersionsOfMEFMessage">
        <source>Attribute '{0}' comes from a different version of MEF than the export attribute on '{1}'</source>
        <target state="translated">'{0}' 특성은 '{1}'의 export 특성이 아닌 다른 버전의 MEF에서 가져온 것입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartsExportedWithMEFv2MustBeMarkedAsSharedTitle">
        <source>Parts exported with MEFv2 must be marked as Shared</source>
        <target state="translated">MEFv2를 통해 내보낸 파트는 Shared로 표시되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartsExportedWithMEFv2MustBeMarkedAsSharedDescription">
        <source>Part exported with MEFv2 must be marked with the Shared attribute.</source>
        <target state="translated">MEFv2를 통해 내보낸 파트는 Shared 특성으로 표시되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartsExportedWithMEFv2MustBeMarkedAsSharedMessage">
        <source>'{0}' is exported with MEFv2 and hence must be marked as Shared</source>
        <target state="translated">'{0}'을(를) MEFv2를 통해 내보냈으므로 Shared로 표시해야 합니다.</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>